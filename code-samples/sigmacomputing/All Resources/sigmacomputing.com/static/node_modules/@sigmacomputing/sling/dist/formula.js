"use strict";

exports.__esModule = true;
exports.INVALID_ARG_TYPE = exports.INVALID_NARGS = exports.UNKNOWN_FUNCTION = exports.UNKNOWN_NAME = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.nullVal = nullVal;
exports.toNull = toNull;
exports.boolVal = boolVal;
exports.toBool = toBool;
exports.numVal = numVal;
exports.toNum = toNum;
exports.strVal = strVal;
exports.toStr = toStr;
exports.datetimeVal = datetimeVal;
exports.toDatetime = toDatetime;
exports.parseConstVal = parseConstVal;
exports.unboxConstVal = unboxConstVal;
exports.empty = empty;
exports.literal = literal;
exports.unOp = unOp;
exports.binOp = binOp;
exports.callOp = callOp;
exports.nameRef = nameRef;
exports.unboundNameRef = unboundNameRef;
exports.paren = paren;
exports.validateFormula = validateFormula;

var _functions = require("./functions");

function nullVal() {
  return { type: "null" };
}

// eslint-disable-next-line no-unused-vars
function toNull(v) {
  return null;
}

function boolVal(b) {
  if (b != null) {
    return { type: "bool", val: b };
  } else {
    return nullVal();
  }
}

function toBool(v) {
  return v.val;
}

function numVal(n) {
  if (n != null) {
    return { type: "number", val: n };
  } else {
    return nullVal();
  }
}

function toNum(v) {
  return v.val;
}

function strVal(s) {
  if (s != null) {
    return { type: "string", val: s };
  } else {
    return nullVal();
  }
}

function toStr(v) {
  return v.val;
}

function datetimeVal(d) {
  if (d != null) {
    return { type: "datetime", val: d };
  } else {
    return nullVal();
  }
}

function toDatetime(v) {
  return v.val;
}

function parseConstVal(val, typ) {
  if (val == null) {
    return nullVal();
  }

  switch (typ) {
    case _functions.TY_LOGICAL:
      return boolVal(val.toLowerCase() === "true");
    case _functions.TY_NUMBER:
      return numVal(parseFloat(val));
    case _functions.TY_TEXT:
      return strVal(val);
    case _functions.TY_DATE:
      return datetimeVal(val);
    default:
      throw new TypeError("Unexpected type " + typ);
  }
}

function unboxConstVal(v) {
  if (v.type === "null") {
    return null;
  } else {
    return v.val;
  }
}

function empty() {
  return { type: "empty" };
}

function literal(val) {
  return { type: "const", val: val };
}

function unOp(op, x) {
  return { type: "unOp", op: op, x: x };
}

function binOp(x, op, y) {
  return { type: "binOp", op: op, x: x, y: y };
}

function callOp(op, args) {
  // normalize function name
  var f = funcMap.get(op.toLowerCase());
  return { type: "callOp", op: f ? f.name : op, args: args };
}

function nameRef(_ref) {
  var id = _ref[0],
      parent = _ref[1];

  if (parent) return { type: "nameRef", id: id, parent: parent };
  return { type: "nameRef", id: id };
}

function unboundNameRef(name) {
  return { type: "unboundNameRef", name: name };
}

function paren(x) {
  return { type: "paren", x: x };
}

var UNKNOWN_NAME = exports.UNKNOWN_NAME = "Unknown name";
var UNKNOWN_FUNCTION = exports.UNKNOWN_FUNCTION = "Unknown function";
var INVALID_NARGS = exports.INVALID_NARGS = "Invalid number of args";
var INVALID_ARG_TYPE = exports.INVALID_ARG_TYPE = "Invalid arg type";

var unOpMap = new Map(_functions.unaryOps.map(function (op) {
  return [op.name.toLowerCase(), op];
}));
var binOpMap = new Map(_functions.binaryOps.map(function (op) {
  return [op.name.toLowerCase(), op];
}));
var funcMap = new Map(_functions.functions.map(function (f) {
  return [f.name.toLowerCase(), f];
}));

function mkErr(err) {
  return {
    ty: "error",
    err: err
  };
}

function mkSuccess(ty) {
  // XXX JDF: I feel like Flow should be able to handle this, but it can't.
  // $FlowFixMe
  return { ty: ty };
}

function validateFormula(inFormula, refFn) {
  if (inFormula.type === "empty") return mkSuccess(null);

  function validate(formula) {
    switch (formula.type) {
      case "const":
        switch (formula.val.type) {
          case "null":
            return mkSuccess(null);
          case "bool":
            return mkSuccess(_functions.TY_LOGICAL);
          case "number":
            return mkSuccess(_functions.TY_NUMBER);
          case "datetime":
            return mkSuccess(_functions.TY_DATE);
          case "string":
            return mkSuccess(_functions.TY_TEXT);
          default:
            throw new Error("Unknown const type: " + formula.val.type);
        }

      case "empty":
        // The parser should never generate this.
        throw new Error("Unexpected empty node.");

      case "unOp":
        {
          var fdef = unOpMap.get(formula.op);
          if (!fdef) {
            // The parser should never generate this.
            throw new Error("Unknown binary op: " + formula.op);
          }
          return validateFuncArgs(fdef, [formula.x]);
        }

      case "binOp":
        {
          var _fdef = binOpMap.get(formula.op);
          if (!_fdef) {
            // The parser should never generate this.
            throw new Error("Unknown binary op: " + formula.op);
          }
          return validateFuncArgs(_fdef, [formula.x, formula.y]);
        }

      case "callOp":
        return validateCall(formula.op, formula.args);

      case "nameRef":
        {
          var _id = formula.id,
              _parent = formula.parent;

          var res = refFn(_id, _parent);
          if (res === "Cycle") {
            if (_parent) throw new Error("Invalid cycle with parent " + _parent);
            return mkErr({ type: "Ref Cycle", id: _id });
          } else if (res === "Missing") {
            return mkErr({ type: "Ref Missing", id: _id, parent: _parent });
          } else if (res.ty === "error") {
            return mkErr({ type: "Ref Error", id: _id, parent: _parent });
          } else {
            return res;
          }
        }

      case "paren":
        return validate(formula.x);
      case "unboundNameRef":
        return mkErr({ type: UNKNOWN_NAME, name: formula.name });
      default:
        throw new Error("Unknown formula type: " + formula.type);
    }
  }

  function validateCall(op, args) {
    var f = funcMap.get(op.toLowerCase());
    if (!f) {
      return mkErr({ type: UNKNOWN_FUNCTION, name: op });
    }

    if (f.name === "If") return validateIfArgs(f, args);
    return validateFuncArgs(f, args);
  }

  function validateFuncArgs(fdef, args) {
    var retTy = fdef.returnTy;
    var boundTy = null;
    var splatTy = void 0;
    var idx = 0;

    var _loop = function _loop() {
      var argRes = validate(args[idx]);
      var argTy = argRes.ty;
      if (argTy === "error") return {
          v: argRes
        };

      // Find the param to match up with `argTy`.
      var paramTy = splatTy;
      if (!paramTy) {
        if (fdef.params.length <= idx) {
          // Too many args
          return {
            v: mkErr({ type: INVALID_NARGS, given: args.length, f: fdef })
          };
        }

        var param = fdef.params[idx];
        paramTy = param.type;
        if (param.splat) {
          // This is the parameter type from here on out.
          splatTy = paramTy;
        }
      }

      // Check that `paramTy` matches up with `argTy`.

      if (argTy === null) return "continue";

      var failParam = function failParam() {
        return mkErr({ type: INVALID_ARG_TYPE, ty: argTy, idx: idx, f: fdef });
      };
      if (Array.isArray(paramTy) && !paramTy.includes(argTy)) return {
          v: failParam()
        };

      if (Array.isArray(paramTy) || paramTy === "any") {
        if (!boundTy) {
          boundTy = argTy;
        } else if (boundTy !== argTy) {
          return {
            v: failParam()
          };
        }
      } else if (argTy !== paramTy) return {
          v: failParam()
        };
    };

    for (; idx < args.length; idx += 1) {
      var _ret = _loop();

      switch (_ret) {
        case "continue":
          continue;

        default:
          if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
      }
    }

    // Any unused parameters must be optional.
    if (idx < fdef.params.length && !fdef.params[idx].optional) {
      // Not enough args
      return mkErr({ type: INVALID_NARGS, given: args.length, f: fdef });
    }

    if (retTy === "bound") retTy = boundTy;

    return mkSuccess(retTy);
  }

  function validateIfArgs(fdef, args) {
    if (args.length < 2) {
      return mkErr({ type: INVALID_NARGS, given: args.length, f: fdef });
    }

    var retTy = null;
    for (var _idx = 0; _idx < args.length; _idx++) {
      var res = validate(args[_idx]);
      var _argTy = res.ty;
      if (_argTy === "error") return res;
      if (!_argTy) continue;

      if (_idx % 2 === 0 && _idx !== args.length - 1) {
        // case condition
        if (_argTy !== _functions.TY_LOGICAL) return mkErr({ type: INVALID_ARG_TYPE, ty: _argTy, idx: _idx, f: fdef });
      } else {
        // case result or else
        if (_argTy) {
          if (retTy && _argTy !== retTy) return mkErr({ type: INVALID_ARG_TYPE, ty: _argTy, idx: _idx, f: fdef });else retTy = _argTy;
        }
      }
    }

    return mkSuccess(retTy);
  }

  return validate(inFormula);
}


//////////////////
// WEBPACK FOOTER
// ./node_modules/@sigmacomputing/sling/dist/formula.js
// module id = 168
// module chunks = 1