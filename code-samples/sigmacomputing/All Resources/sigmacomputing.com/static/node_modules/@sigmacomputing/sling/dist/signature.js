"use strict";

exports.__esModule = true;
exports.getSignature = getSignature;

var _lex = require("./lex");

var _lex2 = _interopRequireDefault(_lex);

var _functions = require("./functions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function matchSym(token, sym) {
  return token.type === _lex.TOKENS.SYM && token.value === sym;
}

var FUNC_MAP = {};
_functions.functions.forEach(function (def) {
  FUNC_MAP[def.name.toLowerCase()] = def;
});

function getSignature(text) {
  var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : text.length;

  var lexer = new _lex2.default(text);

  var sigStack = [];
  var curArg = 0;
  var lParenCount = 0;

  var prevToken = lexer.next();
  if (prevToken.type === _lex.TOKENS.EOF || prevToken.type === _lex.TOKENS.FAILURE) return null;

  var curToken = lexer.next();
  while (curToken.type !== _lex.TOKENS.EOF && curToken.type !== _lex.TOKENS.FAILURE && curToken.pos[0] <= position) {
    if (matchSym(curToken, "(")) {
      if (prevToken.type === _lex.TOKENS.IDENT && !Array.isArray(prevToken.value)) {
        sigStack.push({
          fname: prevToken.value,
          curArg: curArg,
          lParenCount: lParenCount
        });
        curArg = 0;
        lParenCount = 0;
      } else {
        ++lParenCount;
      }
    } else if (matchSym(curToken, ")")) {
      if (lParenCount > 0) {
        --lParenCount;
      } else {
        var _sig = sigStack.pop();
        if (_sig) {
          curArg = _sig.curArg;
          lParenCount = _sig.lParenCount;
        }
      }
    } else if (matchSym(curToken, ",")) {
      ++curArg;
    }

    prevToken = curToken;
    curToken = lexer.next();
  }

  var sig = sigStack.pop();
  if (!sig) return null;
  var def = FUNC_MAP[sig.fname.toLowerCase()];
  if (!def) return null;

  return { def: def, curArg: curArg };
}


//////////////////
// WEBPACK FOOTER
// ./node_modules/@sigmacomputing/sling/dist/signature.js
// module id = 1323
// module chunks = 1