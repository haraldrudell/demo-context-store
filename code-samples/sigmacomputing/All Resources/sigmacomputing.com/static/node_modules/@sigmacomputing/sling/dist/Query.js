"use strict";

exports.__esModule = true;
exports.mkUniqName = mkUniqName;
exports.newInput = newInput;
exports.inputGetName = inputGetName;
exports.inputGetColumns = inputGetColumns;

var _uuid = require("uuid");

var _uuid2 = _interopRequireDefault(_uuid);

var _baseX = require("base-x");

var _baseX2 = _interopRequireDefault(_baseX);

var _startCase = require("lodash/startCase");

var _startCase2 = _interopRequireDefault(_startCase);

var _values = require("lodash/values");

var _values2 = _interopRequireDefault(_values);

var _formula = require("./formula");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BASE62 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
var bs62 = (0, _baseX2.default)(BASE62);

function _genId() {
  var id = _uuid2.default.v4();
  var bytes = Buffer.from(id.replace(/-/g, ""), "hex");
  return bs62.encode(bytes);
}

// Generates a name based on prefix that doesn't conflict with the existing names
function mkUniqName(existing, prefix) {
  var names = new Set(existing);

  if (!names.has(prefix)) return prefix;

  for (var i = 1;; i++) {
    var _n = prefix + " (" + i + ")";
    if (!names.has(_n)) return _n;
  }
  throw new Error("never reached"); // eslint-disable-line no-unreachable
}

function newInput(table) {
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Query.genId();

  return {
    type: "external",
    id: id,
    table: table
  };
}

function inputGetName(input) {
  return input.type === "external" ? input.table.name : input.type === "customSQL" ? "raw" : /* subQuery */"composition";
}

function inputGetColumns(input) {
  return input.type === "external" ? input.table.columns : input.type === "customSQL" ? input.columns : /* subQuery */input.columns;
}

// range is inclusive

var Query = function () {
  Query.genId = function genId() {
    return _genId();
  }; // deprecated


  function Query(input) {
    var _this = this;

    _classCallCheck(this, Query);

    if (!input) {
      // Creating a new Query through Query.parse(queryStr)
      return;
    }

    this.input = input;
    this.relationships = [];
    this.levels = [];
    this.columns = {};
    this.root = input.id;

    var labels = {};

    this.global = {
      id: "global",
      columns: [],
      sortKeys: [],
      isCollapsed: false
    };

    this.base = {
      id: "base",
      columns: inputGetColumns(input).map(function (ecol) {
        var id = Query.genId();
        _this.columns[id] = {
          id: id,
          def: { type: "formula", def: (0, _formula.nameRef)([ecol.name, _this.input.id]) },
          isHidden: false,
          isGrouped: false
        };
        labels[id] = (0, _startCase2.default)(ecol.name);
        return id;
      }),
      sortKeys: [],
      isCollapsed: false
    };

    this.view = {
      queryLabel: (0, _startCase2.default)(inputGetName(input)),
      labels: labels,
      columnWidths: {},
      formats: {},
      levelHidden: {}
    };

    this.formatVersion = 3;
  }

  Query.prototype.getColumn = function getColumn(columnId) {
    var column = this.columns[columnId];
    if (!column) {
      throw new Error("Invalid column id: " + columnId);
    }
    return column;
  };

  Query.prototype.levelIdxIsBase = function levelIdxIsBase(levelIdx) {
    return levelIdx === 0 || levelIdx === this.base.id;
  };

  Query.prototype.levelIdxIsGlobal = function levelIdxIsGlobal(levelIdx) {
    return levelIdx === this.levels.length + 1 || levelIdx === this.global.id;
  };

  Query.prototype.levelIdxIsGroup = function levelIdxIsGroup(levelIdx) {
    return !(this.levelIdxIsBase(levelIdx) || this.levelIdxIsGlobal(levelIdx));
  };

  Query.prototype.getLevelIdx = function getLevelIdx(levelIdx) {
    if (typeof levelIdx === "string") {
      if (this.base.id === levelIdx) return 0;
      if (this.global.id === levelIdx) return this.levels.length + 1;
      var idx = this.levels.findIndex(function (level) {
        return level.id === levelIdx;
      });
      if (idx < 0) throw new Error("Invalid level id: " + levelIdx);
      return idx + 1;
    } else {
      if (levelIdx < 0 || levelIdx > this.levels.length + 1) {
        throw new Error("Invalid level idx: " + levelIdx);
      }
      return levelIdx;
    }
  };

  Query.prototype.getLevel = function getLevel(levelIdx) {
    var idx = this.getLevelIdx(levelIdx);
    if (idx === 0) return this.base;
    if (idx === this.levels.length + 1) return this.global;
    return this.levels[idx - 1];
  };

  Query.prototype.getGroupLevel = function getGroupLevel(levelIdx) {
    var idx = this.getLevelIdx(levelIdx);
    if (idx === 0 || idx === this.levels.length + 1) throw new Error("Cannot access non-grouped level as group level");
    return this.levels[idx - 1];
  };

  Query.prototype.findColumnLevel = function findColumnLevel(columnId) {
    if (this.base.columns.includes(columnId)) return this.base.id;
    if (this.global.columns.includes(columnId)) return this.global.id;

    var levelIdx = this.levels.findIndex(function (level) {
      return level.columns.includes(columnId);
    });
    if (levelIdx < 0) throw new Error("Unknown column " + columnId);
    return this.levels[levelIdx].id;
  };

  Query.parse = function parse(queryStr) {
    var queryData = JSON.parse(queryStr);

    if (queryData.formatVersion === 2) {
      queryData.global = {
        id: "global",
        columns: [],
        sortKeys: [],
        isCollapsed: true
      };

      queryData.formatVersion = 3;
    }

    if (queryData.formatVersion !== 3) {
      throw new Error("Unknown Query formatVersion: " + queryData.formatVersion);
    }

    var query = new Query();
    query.input = queryData.input;
    query.relationships = queryData.relationships;
    query.global = queryData.global;
    query.levels = queryData.levels;
    query.base = queryData.base;
    query.columns = queryData.columns;
    query.view = queryData.view;
    query.root = queryData.root;
    query.formatVersion = queryData.formatVersion;

    return query;
  };

  Query.prototype.serializeForStorage = function serializeForStorage() {
    var queryData = {
      input: this.input,
      relationships: this.relationships,
      global: this.global,
      levels: this.levels,
      base: this.base,
      columns: this.columns,
      view: this.view,
      root: this.root,
      formatVersion: this.formatVersion
    };

    return JSON.stringify(queryData);
  };

  Query.prototype.serializeForEval = function serializeForEval(now, pager) {
    return {
      input: this.input,
      relationships: this.relationships,
      global: this.global,
      levels: this.levels,
      base: this.base,
      columns: this.columns,
      view: this.view,
      root: this.root,
      formatVersion: this.formatVersion,
      pager: pager,
      session: {
        now: now
      }
    };
  };

  Query.prototype.mkUniqColumnName = function mkUniqColumnName(label) {
    return mkUniqName((0, _values2.default)(this.view.labels), label);
  };

  Query.prototype.mkUniqRelationshipName = function mkUniqRelationshipName(label) {
    var existingRelationships = this.relationships.map(function (r) {
      return r.name;
    });
    return mkUniqName(existingRelationships, label);
  };

  Query.prototype.addFormulaColumn = function addFormulaColumn(levelIdx) {
    var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "New Column";
    var formula = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _formula.empty)();
    var columnId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Query.genId();

    var level = this.getLevel(levelIdx);

    if (this.columns[columnId]) {
      throw new Error("Reused column id: " + columnId);
    }

    var column = {
      id: columnId,
      def: {
        type: "formula",
        def: formula
      },
      isHidden: false,
      isGrouped: false
    };

    this.columns[columnId] = column;
    this.view.labels[columnId] = this.mkUniqColumnName(label);
    level.columns.push(columnId);

    return columnId;
  };

  Query.prototype.deleteColumn = function deleteColumn(columnId, levelIdx) {
    var column = this.getColumn(columnId);
    if (column.isGrouped) {
      throw new Error("Cannot delete grouped column");
    }

    var level = this.getLevel(levelIdx);
    var idx = level.columns.indexOf(columnId);
    if (idx < 0) {
      throw new Error("Corrupt query: column " + columnId + " missing from level " + levelIdx);
    }
    level.columns.splice(idx, 1);

    var sortIdx = level.sortKeys.findIndex(function (sortCol) {
      return sortCol.column === columnId;
    });
    if (sortIdx >= 0) {
      level.sortKeys.splice(sortIdx, 1);
    }

    delete this.columns[columnId];
    delete this.view.labels[columnId];
    delete this.view.columnWidths[columnId];
  };

  Query.prototype.reorderColumns = function reorderColumns(levelIdx, columns, after) {
    var _level$columns;

    var level = this.getLevel(levelIdx);
    if (after !== undefined && level.columns.indexOf(after) === -1) {
      throw new Error("After column " + after + " not in level");
    }
    columns.forEach(function (columnId) {
      if (level.columns.indexOf(columnId) === -1) {
        throw new Error("Target column " + columnId + " not in level");
      }
    });

    level.columns = level.columns.filter(function (columnId) {
      return columns.indexOf(columnId) === -1;
    });
    var idx = after === undefined ? 0 : level.columns.indexOf(after) + 1;
    (_level$columns = level.columns).splice.apply(_level$columns, [idx, 0].concat(columns));
  };

  Query.prototype.setColumnFormula = function setColumnFormula(columnId, formula) {
    var column = this.getColumn(columnId);
    if (column.def.type === "formula") {
      column.def.def = formula;
    } else {
      throw new Error("Cannot set formula for non-formula column " + columnId);
    }
  };

  Query.prototype.columnHideToggle = function columnHideToggle(columnId) {
    var column = this.getColumn(columnId);
    column.isHidden = !column.isHidden;
  };

  Query.prototype.columnLabelSet = function columnLabelSet(columnId, label) {
    this.getColumn(columnId);
    this.view.labels[columnId] = this.mkUniqColumnName(label);
  };

  Query.prototype.columnUpdateWidth = function columnUpdateWidth(columnId, width) {
    this.getColumn(columnId);
    this.view.columnWidths[columnId] = width;
  };

  Query.prototype.queryLabelSet = function queryLabelSet(label) {
    this.view.queryLabel = label;
  };

  Query.prototype.setInput = function setInput(input) {
    this.input = input;
  };

  Query.prototype.columnFormatSet = function columnFormatSet(columnId, format) {
    this.getColumn(columnId);
    this.view.formats[columnId] = format;
  };

  Query.prototype.setIncludeFilter = function setIncludeFilter(columnId, values) {
    var column = this.getColumn(columnId);
    column.filter = {
      type: "include",
      values: values
    };
  };

  Query.prototype.setExcludeFilter = function setExcludeFilter(columnId, values) {
    var column = this.getColumn(columnId);
    column.filter = {
      type: "exclude",
      values: values
    };
  };

  Query.prototype.setRangeFilter = function setRangeFilter(columnId, low, high) {
    var nulls = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    var column = this.getColumn(columnId);
    column.filter = {
      type: "range",
      low: low,
      high: high,
      includeNulls: nulls
    };
  };

  Query.prototype.setRelativeDateFilter = function setRelativeDateFilter(columnId, unit, mode) {
    var anchor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var nulls = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

    var column = this.getColumn(columnId);
    column.filter = {
      type: "relativeDate",
      includeNulls: nulls,
      anchor: anchor && anchor.toISOString(),
      unit: unit,
      mode: mode
    };
  };

  Query.prototype.setRankLimitFilter = function setRankLimitFilter(columnId, low, high, mode) {
    var asc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var nulls = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

    var column = this.getColumn(columnId);
    column.filter = {
      type: "rankLimit",
      includeNulls: nulls,
      isAsc: asc,
      low: low,
      high: high,
      mode: mode
    };
  };

  Query.prototype.clearFilter = function clearFilter(columnId) {
    var column = this.getColumn(columnId);
    column.filter = undefined;
  };

  Query.prototype.levelCollapseToggle = function levelCollapseToggle(levelIdx) {
    var level = this.getLevel(levelIdx);
    level.isCollapsed = !level.isCollapsed;
  };

  Query.prototype.levelToggleHide = function levelToggleHide(levelId) {
    if (!this.view.levelHidden) {
      this.view.levelHidden = {};
    }
    this.view.levelHidden[levelId] = !this.view.levelHidden[levelId];
  };

  Query.prototype.checkPotentialGroupKeys = function checkPotentialGroupKeys(keys) {
    var _this2 = this;

    if (keys.length === 0) {
      throw new Error("Cannot group empty set of keys");
    }

    keys.forEach(function (columnId) {
      // XXX JDF: need to check that keys are computed prior to `afterLevelIdx`
      var column = _this2.getColumn(columnId);
      if (column.isGrouped) {
        throw new Error("Cannot create new group from already grouped column " + columnId);
      }
    });
  };

  Query.prototype.markGroupKeys = function markGroupKeys(keys, grouped) {
    var _this3 = this;

    keys.forEach(function (columnId) {
      var column = _this3.getColumn(columnId);
      column.isGrouped = grouped;
    });
  };

  Query.prototype.createGroup = function createGroup(keys, afterLevelIdx) {
    var levelId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Query.genId();

    if (this.levelIdxIsGlobal(afterLevelIdx)) throw new Error("Cannot create new group after globals");
    this.checkPotentialGroupKeys(keys);

    if (this.levels.findIndex(function (level) {
      return level.id === levelId;
    }) >= 0) {
      throw new Error("Reused level id: " + levelId);
    }

    var afterIdx = this.getLevelIdx(afterLevelIdx);
    this.levels.splice(afterIdx, 0, {
      id: levelId,
      columns: [],
      sortKeys: [],
      isCollapsed: false,
      keys: keys
    });

    this.markGroupKeys(keys, true);
  };

  Query.prototype.deleteGroup = function deleteGroup(levelIdx) {
    var _this4 = this;

    var level = this.getGroupLevel(levelIdx);
    this.markGroupKeys(level.keys, false);

    level.columns.forEach(function (columnId) {
      // XXX JDF: alternatively we could move these computed columns to a
      // different level, although they may not compute there
      delete _this4.columns[columnId];
      delete _this4.view.labels[columnId];
    });

    var idx = this.getLevelIdx(levelIdx);
    this.levels.splice(idx - 1, 1);
  };

  Query.prototype.setGroupKeys = function setGroupKeys(keys, levelIdx) {
    var level = this.getGroupLevel(levelIdx);
    this.markGroupKeys(level.keys, false);
    this.checkPotentialGroupKeys(keys);
    level.sortKeys = level.sortKeys.filter(function (sortKey) {
      return keys.indexOf(sortKey.column) >= 0;
    });
    level.keys = keys;
    this.markGroupKeys(keys, true);
  };

  Query.prototype.addGroupKeys = function addGroupKeys(keys, levelIdx) {
    this.checkPotentialGroupKeys(keys);

    var level = this.getGroupLevel(levelIdx);
    level.keys = level.keys.concat(keys);

    this.markGroupKeys(keys, true);
  };

  Query.prototype.dropGroupKeys = function dropGroupKeys(keys, levelIdx) {
    var level = this.getGroupLevel(levelIdx);

    level.sortKeys = level.sortKeys.filter(function (sortKey) {
      return keys.indexOf(sortKey.column) === -1;
    });
    level.keys = level.keys.filter(function (key) {
      return keys.indexOf(key) === -1;
    });
    if (level.keys.length === 0) {
      throw new Error("We screwed up and dropped all group keys");
    }

    this.markGroupKeys(keys, false);
  };

  Query.prototype.reorderGroupKeys = function reorderGroupKeys(levelIdx, keys, after) {
    var _level$keys;

    var level = this.getGroupLevel(levelIdx);
    if (after !== undefined && level.keys.indexOf(after) === -1) {
      throw new Error("After column " + after + " not in level");
    }
    keys.forEach(function (columnId) {
      if (level.keys.indexOf(columnId) < 0) {
        throw new Error("Invalid group key " + columnId + " for level " + levelIdx);
      }
    });

    level.keys = level.keys.filter(function (columnId) {
      return keys.indexOf(columnId) === -1;
    });
    var idx = after === undefined ? 0 : level.keys.indexOf(after) + 1;
    (_level$keys = level.keys).splice.apply(_level$keys, [idx, 0].concat(keys));
  };

  Query.prototype.setLevelSort = function setLevelSort(levelIdx, sortKeys) {
    var level = this.getLevel(levelIdx);
    var groupLevel = !this.levelIdxIsBase(levelIdx) && this.getGroupLevel(levelIdx);

    sortKeys.forEach(function (sortKey) {
      if (groupLevel && groupLevel.keys.indexOf(sortKey.column) >= 0) return;
      if (level.columns.indexOf(sortKey.column) < 0) {
        throw new Error("Invalid sort column " + sortKey.column + " for level " + levelIdx);
      }
    });

    level.sortKeys = sortKeys;
  };

  // Move columns from one level to another.


  Query.prototype.moveColumns = function moveColumns(columns, fromLevelIdx, toLevelIdx) {
    var fromLevel = this.getLevel(fromLevelIdx);
    var toLevel = this.getLevel(toLevelIdx);

    columns.forEach(function (columnId) {
      if (fromLevel.columns.indexOf(columnId) === -1) {
        throw new Error("Target column " + columnId + " not in from level");
      }
    });

    if (fromLevelIdx === toLevelIdx) return;

    fromLevel.columns = fromLevel.columns.filter(function (columnId) {
      return columns.indexOf(columnId) === -1;
    });
    fromLevel.sortKeys = fromLevel.sortKeys.filter(function (sortKey) {
      return columns.indexOf(sortKey.column) === -1;
    });
    toLevel.columns = toLevel.columns.concat(columns);
  };

  // Test that this structure maintains all of its invariants.


  Query.prototype.validate = function validate() {
    var _this5 = this;

    Object.keys(this.columns).forEach(function (columnId) {
      var column = _this5.columns[columnId];
      _this5.validateColumn(column);
    });

    if (this.columns.length !== this.view.labels.length) {
      throw new Error("More view.labels than columns!");
    }

    this.relationships.forEach(function (rel) {
      _this5.validateRelationship(rel);
    });

    this.validateLevel(this.global);

    this.levels.forEach(function (level) {
      level.keys.forEach(function (key) {
        _this5.getColumn(key);
      });
      _this5.validateLevel(level, level.keys);
    });

    this.validateLevel(this.base);
  };

  Query.prototype.validateLevel = function validateLevel(level, groupKeys) {
    var _this6 = this;

    level.columns.forEach(function (columnId) {
      _this6.getColumn(columnId);
    });

    level.sortKeys.forEach(function (sortKey) {
      if (groupKeys && groupKeys.find(function (colId) {
        return colId === sortKey.column;
      })) return;
      if (!level.columns.find(function (colId) {
        return colId === sortKey.column;
      })) {
        throw new Error("Sort column " + sortKey.column + " missing from level");
      }
    });
  };

  Query.prototype.validateColumn = function validateColumn(column) {
    var storedColumn = this.columns[column.id];
    if (!storedColumn || storedColumn.id !== column.id) {
      throw new Error("Column " + column.id + " not indexed correctly");
    }

    if (!(column.id in this.view.labels)) {
      throw new Error("Column " + column.id + " missing label");
    }
  };

  Query.prototype.validateRelationship = function validateRelationship(rel) {
    var _this7 = this;

    if (rel.sourceKeys.length !== rel.targetKeys.length) {
      throw new Error("Relationship " + rel.target.id + " has mismatched keys");
    }

    rel.sourceKeys.forEach(function (ref) {
      _this7.validateColumnRef(ref);
    });

    rel.targetKeys.forEach(function (id) {
      _this7.validateColumnRef([rel.target.id, id]);
    });
  };

  Query.prototype.getInput = function getInput(id) {
    if (this.input.id === id) return this.input;
    var rel = this.getRelationship(id);
    return rel.target;
  };

  Query.prototype.validateColumnRef = function validateColumnRef(_ref) {
    var inputId = _ref[0],
        colId = _ref[1];

    if (!inputId) {
      if (!this.columns[colId]) {
        throw new Error("ColumnRef " + colId + " invalid");
      }
    } else {
      var input = this.getInput(inputId);
      if (!inputGetColumns(input).find(function (ecol) {
        return ecol.name === colId;
      })) {
        throw new Error("ColumnRef " + inputId + "/" + colId + " invalid");
      }
    }
  };

  Query.prototype.addRelationship = function addRelationship(rel) {
    if (this.relationships.find(function (erel) {
      return erel.target.id === rel.target.id;
    })) {
      throw new Error("Relationship already exists: " + rel.target.id);
    }
    rel.name = this.mkUniqRelationshipName(rel.name);
    this.relationships.push(rel);
    this.validateRelationship(rel);
  };

  Query.prototype.getRelationshipIdx = function getRelationshipIdx(id) {
    var idx = this.relationships.findIndex(function (rel) {
      return rel.target.id === id;
    });
    if (idx < 0) {
      throw new Error("Unknown relationship " + id);
    }
    return idx;
  };

  Query.prototype.getRelationship = function getRelationship(id) {
    return this.relationships[this.getRelationshipIdx(id)];
  };

  Query.prototype.setRelationshipName = function setRelationshipName(id, name) {
    var rel = this.getRelationship(id);
    rel.name = this.mkUniqRelationshipName(name);
  };

  Query.prototype.setRelationshipKeys = function setRelationshipKeys(id, sourceKeys, targetKeys) {
    var rel = this.getRelationship(id);
    rel.sourceKeys = sourceKeys;
    rel.targetKeys = targetKeys;
    this.validateRelationship(rel);
  };

  Query.prototype.setRelationshipTarget = function setRelationshipTarget(id, sourceKeys, target, targetKeys) {
    var rel = this.getRelationship(id);
    rel.sourceKeys = sourceKeys;
    rel.target = target;
    rel.targetKeys = targetKeys;
    this.validateRelationship(rel);
  };

  Query.prototype.deleteRelationship = function deleteRelationship(id) {
    var idx = this.getRelationshipIdx(id);
    this.relationships.splice(idx, 1);
  };

  Query.prototype.lookupId = function lookupId(id, parent) {
    if (!parent) {
      return this.view.labels[id];
    }

    var input = void 0;
    var baseName = void 0;
    if (parent === this.input.id) {
      input = this.input;
      baseName = inputGetName(this.input);
    } else {
      var relationship = this.relationships.find(function (rel) {
        return rel.target.id === parent;
      });
      if (!relationship) return null;
      input = relationship.target;
      baseName = relationship.name;
    }

    var col = inputGetColumns(input).find(function (c) {
      return c.name === id;
    });
    return col ? [baseName, col.name] : null;
  };

  Query.prototype.lookupName = function lookupName(name) {
    var path = Array.isArray(name) ? name : [name];
    switch (path.length) {
      case 1:
        {
          var label = path[0].toLowerCase();
          for (var _iterator = Object.keys(this.view.labels), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref2 = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref2 = _i.value;
            }

            var _id = _ref2;

            if (this.view.labels[_id].toLowerCase() === label) {
              return [_id, null];
            }
          }
          return null;
        }

      case 2:
        {
          var inputName = path[0].toLowerCase();
          var colName = path[1].toLowerCase();

          var input = void 0;
          if (inputGetName(this.input).toLowerCase() === inputName) {
            input = this.input;
          } else {
            var rel = this.relationships.find(function (r) {
              return r.name.toLowerCase() === inputName;
            });
            if (!rel) return null;
            input = rel.target;
          }

          var col = inputGetColumns(input).find(function (c) {
            return c.name.toLowerCase() === colName;
          });
          return col ? [col.name, input.id] : null;
        }

      default:
        {
          return null;
        }
    }
  };

  return Query;
}();

exports.default = Query;


//////////////////
// WEBPACK FOOTER
// ./node_modules/@sigmacomputing/sling/dist/Query.js
// module id = 264
// module chunks = 1