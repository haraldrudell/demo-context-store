"use strict";

exports.__esModule = true;

var _formula = require("./formula");

var formula = _interopRequireWildcard(_formula);

var _lex = require("./lex");

var _lex2 = _interopRequireDefault(_lex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// converts name --> id
var Stream = function () {
  function Stream(input, lookupName) {
    _classCallCheck(this, Stream);

    this.lexer = new _lex2.default(input);
    // We buffer tokens so that we can peek ahead more than one token at a
    // time.
    this.tokens = [];
    this.consumedCount = 0;
    this.lookupName = lookupName;
  }

  Stream.prototype.fetchToken = function fetchToken() {
    this.tokens.push(this.lexer.next());
  };

  Stream.prototype.advance = function advance() {
    if (this.tokens.length > 0) {
      this.consumedCount++;
      var tok = this.tokens.shift();
      this.lastPos = tok.pos;
    }
  };

  Stream.prototype.peek = function peek(idx) {
    for (var i = this.tokens.length; i <= idx; i += 1) {
      this.fetchToken();
    }
    return this.tokens[idx];
  };

  return Stream;
}();

function makeSuccess(value) {
  return {
    status: true,
    value: value
  };
}

function makeFailure(_ref, expected) {
  var type = _ref.type,
      value = _ref.value,
      pos = _ref.pos;

  return {
    status: false,
    found: { type: type, value: value },
    pos: pos,
    expected: expected
  };
}

function mergeResult(result, prev) {
  if (!prev) return result;

  if (result.status) return result;
  // We don't support unwinding, so found and pos should be the same.
  var found = result.found,
      pos = result.pos,
      expected = result.expected;

  return {
    status: false,
    found: found,
    pos: pos,
    expected: (prev.expected || []).concat(expected)
  };
}

// Return a parser that doesn't consume anything and always yields `value`.
function succeed(value) {
  return new Parser(function () {
    return makeSuccess(value);
  });
}

// Take a list of parsers and create a parser that applies them in order,
// producing the value of the first one that succeeds.
function any() {
  for (var _len = arguments.length, parsers = Array(_len), _key = 0; _key < _len; _key++) {
    parsers[_key] = arguments[_key];
  }

  return new Parser(function (stream) {
    var result = void 0;
    for (var i = 0; i < parsers.length; i++) {
      var curConsumedCount = stream.consumedCount;
      var curResult = parsers[i].run(stream);
      if (curResult.status) return curResult;
      // If we've consumed any tokens then we must fail, since no later parser
      // will be able to see them.
      if (stream.consumedCount > curConsumedCount) return curResult;
      result = mergeResult(curResult, result);
    }
    return result;
  });
}

// Take a list of parsers and create a parser that applies them in order,
// producing an array of results.
function seq() {
  for (var _len2 = arguments.length, parsers = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    parsers[_key2] = arguments[_key2];
  }

  return new Parser(function (stream) {
    var result = void 0;
    var accum = new Array(parsers.length);
    for (var i = 0; i < parsers.length; i++) {
      result = mergeResult(parsers[i].run(stream), result);
      if (!result.status) return result;
      accum[i] = result.value;
    }
    return mergeResult(makeSuccess(accum), result);
  });
}

// Take a parser and create a parser that returns `value` if it succeeds,
// otherwise producing `undefined`.
function optional(parser) {
  return new Parser(function (stream) {
    var curConsumedCount = stream.consumedCount;
    var result = parser.run(stream);
    if (result.status) return result;
    // If we've consumed any tokens then we must fail, since no later parser
    // will be able to see them.
    if (stream.consumedCount > curConsumedCount) return result;
    return makeSuccess(undefined);
  });
}

function matchToken(tok, type, val) {
  return tok && tok.type === type && (val === undefined || tok.value === val);
}

function useInsertRepair(curToken, type, val) {
  // Insert closing paren if we're missing it and at eof
  return curToken.type === _lex.TOKENS.EOF && type === _lex.TOKENS.SYM && val === ")";
}

// Take a token type (i.e. one of TOKENS) and create a parser that matches
// against the current token, return the token value on success. A token value
// can be optionally passed in to be matched.
function token(type, val) {
  return new Parser(function (stream) {
    var curToken = stream.peek(0);
    if (matchToken(curToken, type, val)) {
      var curValue = curToken.value;
      stream.advance();
      return makeSuccess(curValue);
    } else if (useInsertRepair(curToken, type, val)) {
      // repair the token stream by inserting the expected value
      // if this is the first error, stash it so we
      // report the original error if the parse still fails
      if (!stream.origFailure) {
        stream.origFailure = makeFailure(curToken, type);
      }
      return makeSuccess(val);
    } else {
      // XXX JDF: lex errors?
      return stream.origFailure || makeFailure(curToken, type);
    }
  });
}

function lazy(fn) {
  var parser = new Parser(function (stream) {
    parser.run = fn().run;
    return parser.run(stream);
  });
  return parser;
}

// Take parsers for start, end, and middle and return the result of the middle.
function between(start, end, middle) {
  return seq(start, middle, end).map(function (results) {
    return results[1];
  });
}

function sepBy1(parser, separator) {
  var pairs = separator.then(parser).many();
  return parser.chain(function (r) {
    return pairs.map(function (rs) {
      return [r].concat(rs);
    });
  });
}

function sepBy(parser, separator) {
  return any(sepBy1(parser, separator), succeed([]));
}

// eslint-disable-next-line no-unused-vars
function many1(parser) {
  return parser.chain(function (r) {
    return parser.many().map(function (rs) {
      return [r].concat(rs);
    });
  });
}

var Parser = function () {
  function Parser(action) {
    _classCallCheck(this, Parser);

    this.run = action;
  }

  Parser.prototype.chain = function chain(fn) {
    var _this = this;

    return new Parser(function (stream) {
      var result = _this.run(stream);
      if (!result.status) return result;
      var nextParser = fn(result.value);
      return mergeResult(nextParser.run(stream), result);
    });
  };

  Parser.prototype.many = function many() {
    var _this2 = this;

    return new Parser(function (stream) {
      var result = void 0;
      var accum = [];
      for (;;) {
        var curConsumedCount = stream.consumedCount;
        result = mergeResult(_this2.run(stream), result);
        if (result.status) {
          accum.push(result.value);
        } else if (stream.consumedCount > curConsumedCount) {
          // If we've consumed any tokens then we must fail, since no later parser
          // will be able to see them.
          return result;
        } else {
          return mergeResult(makeSuccess(accum), result);
        }
      }
    });
  };

  Parser.prototype.map = function map(fn) {
    var _this3 = this;

    return new Parser(function (stream) {
      var result = _this3.run(stream);
      if (!result.status) {
        return result;
      }
      return mergeResult(makeSuccess(fn(result.value, stream)), result);
    });
  };

  Parser.prototype.then = function then(nextParser) {
    return seq(this, nextParser).map(function (results) {
      return results[1];
    });
  };

  Parser.prototype.parse = function parse(input, lookupName) {
    var stream = new Stream(input, lookupName);
    var result = this.run(stream);
    return result.status ? {
      status: true,
      value: result.value
    } : {
      status: false,
      expected: result.expected,
      found: result.found,
      pos: {
        start: result.pos[0],
        end: result.pos[1]
      }
    };
  };

  return Parser;
}();

function sym(s) {
  return token(_lex.TOKENS.SYM, s);
}

function op(o) {
  return token(_lex.TOKENS.OP, o);
}

function eof() {
  return token(_lex.TOKENS.EOF);
}

function constLiteral() {
  return any(sym("Null").map(function () {
    return formula.literal(formula.nullVal());
  }), sym("True").map(function () {
    return formula.literal(formula.boolVal(true));
  }), sym("False").map(function () {
    return formula.literal(formula.boolVal(false));
  }), token(_lex.TOKENS.STRING).map(function (v) {
    return formula.literal(formula.strVal(v));
  }), token(_lex.TOKENS.NUMBER).map(function (v) {
    return formula.literal(formula.numVal(v));
  }));
}

function callSuffix() {
  return between(sym("("), sym(")"), sepBy(expr(), sym(",")));
}

function unaryOp() {
  return lazy(function () {
    return seq(any(op("-"), op("not")), term()).map(function (_ref2) {
      var o = _ref2[0],
          e = _ref2[1];
      return formula.unOp(o, e);
    });
  });
}

function nameRef(name, stream) {
  var binding = stream.lookupName(name, stream.lastPos);
  return binding ? formula.nameRef(binding) : formula.unboundNameRef(name);
}

function term() {
  return any(constLiteral(), between(sym("("), sym(")"), expr()).map(formula.paren), seq(token(_lex.TOKENS.IDENT), optional(callSuffix())).map(function (_ref3, stream) {
    var name = _ref3[0],
        args = _ref3[1];
    return args ? formula.callOp(name, args) : nameRef(name, stream);
  }), unaryOp());
}

function ops() {
  for (var _len3 = arguments.length, opList = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    opList[_key3] = arguments[_key3];
  }

  return any.apply(undefined, opList.map(function (o) {
    return op(o);
  }));
}

// Right-associatively parse binary expressions at this precedence level with a
// parser that parses everything at the next precedence level.
function binaryRight(opParser, nextParser, fn) {
  var parser = lazy(function () {
    return nextParser.chain(function (next) {
      return any(seq(opParser, succeed(next), parser).map(function (_ref4) {
        var o = _ref4[0],
            left = _ref4[1],
            right = _ref4[2];
        return fn(left, o, right);
      }), succeed(next));
    });
  });
  return parser;
}

// Left-associatively parse binary expressions at this precedence level with a
// parser that parses everything at the next precedence level.
function binaryLeft(opParser, nextParser, fn) {
  return seq(nextParser, seq(opParser, nextParser).many()).map(function (_ref5) {
    var first = _ref5[0],
        rest = _ref5[1];
    return rest.reduce(function (left, _ref6) {
      var o = _ref6[0],
          right = _ref6[1];
      return fn(left, o, right);
    }, first);
  });
}

// All of our binary operators, sorted by highest precedence.
var BINOP_TABLE = [{ type: binaryRight, ops: ops("^") }, { type: binaryLeft, ops: ops("*", "/", "%") }, { type: binaryLeft, ops: ops("+", "-", "&") }, { type: binaryLeft, ops: ops("<", "<=", ">=", ">") }, { type: binaryLeft, ops: ops("=", "!=") }, { type: binaryLeft, ops: ops("and") }, { type: binaryLeft, ops: ops("or") }];

var binaryOp = BINOP_TABLE.reduce(function (acc, level) {
  return level.type(level.ops, acc, formula.binOp);
}, term());

function expr() {
  return new Parser(function (stream) {
    return binaryOp.run(stream);
  });
}

function parse(input, lookupName) {
  return any(eof().map(function () {
    return formula.empty();
  }), seq(expr(), eof()).map(function (_ref7) {
    var e = _ref7[0];
    return e;
  })).parse(input, lookupName);
}

exports.default = parse;


//////////////////
// WEBPACK FOOTER
// ./node_modules/@sigmacomputing/sling/dist/parse.js
// module id = 1288
// module chunks = 1