"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SIMPLE_SYMBOLS = ",()";
var SIMPLE_OPS = "+-*/%^&=";
var WHITESPACE_CHARS = " \t\r\v";

var ERRORS = exports.ERRORS = {
  EMPTY_IDENT: "Empty Identifier",
  INVALID_IDENT_CHAR: "Invalid identifier character",
  INVALID_ESCAPE: "Invalid escape",
  INVALID_NUMBER: "Invalid number literal",
  UNRECOGNIZED_TOKEN: "Unrecognized token",
  UNTERMINATED_ESCAPE: "Unterminated escape",
  UNTERMINATED_IDENT: "Untermainated identifier",
  UNTERMINATED_STRING: "Unterminated string literal"
};

var TOKENS = exports.TOKENS = {
  SYM: "Symbol",
  OP: "Op",
  IDENT: "Identifier",
  NUMBER: "Number",
  STRING: "String",
  FAILURE: "Failure",
  EOF: "End of input"
};

function spanned(tok, start, end) {
  return Object.assign(tok, { pos: [start, end] });
}

function isDigit(c) {
  // eslint-disable-next-line yoda
  return "0" <= c && c <= "9";
}

function isIdentifierStart(c) {
  return (
    // eslint-disable-next-line yoda
    "a" <= c && c <= "z" ||
    // eslint-disable-next-line yoda
    "A" <= c && c <= "Z"
  );
}

function isIdentifierContinue(c) {
  return isIdentifierStart(c) || isDigit(c) || c === "_";
}

function sym(s) {
  return { type: TOKENS.SYM, value: s };
}

function op(o) {
  return { type: TOKENS.OP, value: o };
}

function failure(err) {
  return { type: TOKENS.FAILURE, value: err };
}

var Lexer = function () {
  function Lexer(input) {
    _classCallCheck(this, Lexer);

    this.input = input;
    this.pos = 0;

    this.bump();
  }

  Lexer.prototype.bump = function bump() {
    if (this.pos >= this.input.length) {
      this.lookahead = spanned({ type: TOKENS.EOF }, this.input.length, this.input.length);
    } else {
      this.lookahead = this.input.charAt(this.pos);
      this.pos++;
    }
    return this.lookahead;
  };

  Lexer.prototype.next = function next() {
    while (this.lookahead.type !== TOKENS.EOF) {
      var c = this.lookahead;
      var i = this.pos - 1;

      if (SIMPLE_SYMBOLS.indexOf(c) >= 0) {
        this.bump();
        return spanned(sym(c), i, i + 1);
      } else if (SIMPLE_OPS.indexOf(c) >= 0) {
        this.bump();
        return spanned(op(c), i, i + 1);
      } else if (c === "!") {
        var c2 = this.bump();
        if (c2 === "=") {
          this.bump();
          return spanned(op("!="), i, i + 2);
        }
        return spanned(failure(ERRORS.UNRECOGNIZED_TOKEN), i, i + 1);
      } else if (c === "<") {
        var _c = this.bump();
        if (_c === "=") {
          this.bump();
          return spanned(op("<="), i, i + 2);
        }
        return spanned(op("<"), i, i + 1);
      } else if (c === ">") {
        var _c2 = this.bump();
        if (_c2 === "=") {
          this.bump();
          return spanned(op(">="), i, i + 2);
        }
        return spanned(op(">"), i, i + 1);
      } else if (c === '"') {
        this.bump();
        return this.stringLiteral(i);
      } else if (c === "[") {
        this.bump();
        return this.bracketedIdentifier(i);
      } else if (isIdentifierStart(c)) {
        return this.identifer(i);
      } else if (isDigit(c)) {
        return this.number(i);
      } else if (c === ".") {
        var _c3 = this.bump();
        if (isDigit(_c3)) {
          // Number lead by a decimal point, like ".2"
          return this.number(i, true);
        }
        return spanned(failure(ERRORS.UNRECOGNIZED_TOKEN), i, i + 1);
      } else if (WHITESPACE_CHARS.indexOf(c) >= 0) {
        this.bump();
        continue;
      }

      return spanned(failure(ERRORS.UNRECOGNIZED_TOKEN), i, i + 1);
    }

    // EOF
    return this.lookahead;
  };

  Lexer.prototype.stringLiteral = function stringLiteral(start) {
    var _this = this;

    var escapeNext = false;
    var buf = "";
    var err = void 0;
    var terminate = function terminate(c) {
      if (escapeNext) {
        escapeNext = false;
        switch (c) {
          case '"':
            buf += '"';
            break;
          case "\\":
            buf += "\\";
            break;
          case "0":
            buf += "\0";
            break;
          case "n":
            buf += "\n";
            break;
          case "t":
            buf += "\t";
            break;
          case "r":
            buf += "\r";
            break;
          default:
            err = spanned(failure(ERRORS.INVALID_ESCAPE), _this.pos - 1, _this.pos);
            return true;
        }
        return false;
      } else if (c === "\\") {
        escapeNext = true;
        return false;
      } else if (c === '"') {
        return true;
      } else {
        buf += c;
        return false;
      }
    };

    var end = this.takeUntil(terminate);
    if (!end) {
      return spanned(failure(ERRORS.UNTERMINATED_STRING), start, this.input.length);
    }
    if (err) return err;
    this.bump(); // consume the '"'
    return spanned({ type: TOKENS.STRING, value: buf }, start, end + 1);
  };

  Lexer.prototype.bracketedIdentifier = function bracketedIdentifier(start) {
    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var identStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : start;

    var stopChar = void 0;
    var end = this.takeUntil(function (c) {
      stopChar = c;
      return c === "]" || c === "[" || c === "/";
    });

    if (!end) {
      return spanned(failure(ERRORS.UNTERMINATED_IDENT), start, this.input.length);
    }

    if (stopChar === "[") {
      return spanned(failure(ERRORS.INVALID_IDENT_CHAR), start, this.input.length);
    }

    var identPart = this.input.slice(identStart + 1, end);
    this.bump();
    if (identPart <= 2) {
      return spanned(failure(ERRORS.EMPTY_IDENT), start, end + 1);
    }

    if (stopChar === "/") {
      return this.bracketedIdentifier(start, path.concat([identPart]), end);
    }
    var ident = path.concat([identPart]);
    return spanned({ type: TOKENS.IDENT, value: ident }, start, end + 1);
  };

  Lexer.prototype.identifer = function identifer(start) {
    var end = this.takeUntil(function (c) {
      return !isIdentifierContinue(c);
    }) || this.input.length;
    var ident = this.input.slice(start, end);

    switch (ident.toLowerCase()) {
      case "and":
        return spanned(op("and"), start, end);
      case "false":
        return spanned(sym("False"), start, end);
      case "not":
        return spanned(op("not"), start, end);
      case "null":
        return spanned(sym("Null"), start, end);
      case "or":
        return spanned(op("or"), start, end);
      case "true":
        return spanned(sym("True"), start, end);
      default:
        return spanned({ type: TOKENS.IDENT, value: ident }, start, end);
    }
  };

  Lexer.prototype.number = function number(start) {
    var leadingDecimal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var foundDecimal = leadingDecimal;
    function terminate(c) {
      if (c === ".") {
        if (foundDecimal) return true;
        foundDecimal = true;
        return false;
      } else {
        return !isDigit(c);
      }
    }

    var end = this.takeUntil(terminate) || this.input.length;
    var num = Number(this.input.slice(start, end));
    if (Number.isNaN(num)) {
      return spanned(failure(ERRORS.INVALID_NUMBER), start, end);
    }

    return spanned({ type: TOKENS.NUMBER, value: num }, start, end);
  };

  Lexer.prototype.takeUntil = function takeUntil(terminate) {
    while (this.lookahead.type !== TOKENS.EOF) {
      if (terminate(this.lookahead)) {
        return this.pos - 1;
      }
      this.bump();
    }

    return undefined;
  };

  return Lexer;
}();

exports.default = Lexer;


//////////////////
// WEBPACK FOOTER
// ./node_modules/@sigmacomputing/sling/dist/lex.js
// module id = 263
// module chunks = 1