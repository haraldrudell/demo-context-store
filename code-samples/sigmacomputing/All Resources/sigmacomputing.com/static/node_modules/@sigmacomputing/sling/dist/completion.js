"use strict";

exports.__esModule = true;
exports.getCompletions = getCompletions;

var _lex = require("./lex");

var _lex2 = _interopRequireDefault(_lex);

var _functions = require("./functions");

require("./formula");

var _Query = require("./Query");

var _Query2 = _interopRequireDefault(_Query);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// A more minimal version of CompletionItem from LSP:
//
// https://github.com/Microsoft/language-server-protocol
var NO_COMPLETIONS = [];

function strComp(aIn, bIn) {
  var a = aIn.toLowerCase();
  var b = bIn.toLowerCase();
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}

var SORTED_FUNCTIONS = _functions.functions.slice().sort(function (a, b) {
  return strComp(a.name, b.name);
});

var KEYWORDS = ["and", "or", "not", "True", "False", "Null"].sort(strComp);

function getCompletions(query, current, text) {
  var position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : text.length;

  var lexer = new _lex2.default(text);

  var nextToken = lexer.next();
  var curToken = nextToken;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    if (nextToken.type === _lex.TOKENS.EOF || nextToken.pos[0] >= position) break;
    // An error token swallows the remainder, so update `curToken` in case we hit one.
    curToken = nextToken;
    if (nextToken.type === _lex.TOKENS.FAILURE) break;
    nextToken = lexer.next();
  }

  if (curToken.pos[1] < position) return NO_COMPLETIONS;

  function completeColumn(from) {
    var path = Array.isArray(from) ? from : [from];
    var pathPrefix = path.length > 1 ? path.slice(0, -1).join("/") + "/" : "";
    var lastPathElem = (path.length === 0 ? "" : path[path.length - 1]).toLowerCase();

    var range = {
      start: curToken.pos[0],
      end: curToken.pos[1]
    };

    var matches = [];
    for (var _iterator = Object.keys(query.view.labels), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _id = _ref;

      if (_id === current) continue;
      var _label = query.view.labels[_id];
      if (_label.toLowerCase().startsWith(lastPathElem)) {
        var _newText = "[" + pathPrefix + _label + "]";
        if (_newText.length === range.end - range.start && position === range.end && _newText === text.slice(range.start, range.end)) {
          // We don't want to offer a completion that has no affect. See
          // https://github.com/sigmacomputing/demo/issues/716
          continue;
        }
        matches.push({
          label: _label,
          kind: {
            ty: "column",
            id: _id
          },
          edit: { range: range, newText: _newText }
        });
      }
    }

    return matches;
  }

  function completeFunction(from) {
    var prefix = from.toLowerCase();
    var matchingDefs = [];
    for (var _iterator2 = SORTED_FUNCTIONS, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var _def = _ref2;

      if (_def.deprecated) {
        continue;
      }
      var fName = _def.name.toLowerCase();
      if (fName.startsWith(prefix)) {
        matchingDefs.push(_def);
      }
    }

    if (matchingDefs.length === 0) return NO_COMPLETIONS;

    var range = {
      start: curToken.pos[0],
      end: curToken.pos[1]
    };
    if (nextToken.type === _lex.TOKENS.SYM && nextToken.value === "(") {
      // Overwrite existing "(" so we don't break the formula.
      range.end += 1;
    }
    return matchingDefs.map(function (def) {
      return {
        label: def.name,
        kind: { ty: "function", def: def },
        edit: { range: range, newText: def.name + "(" }
      };
    });
  }

  function completeKeyword(from) {
    var prefix = from.toLowerCase();
    var matchingWords = KEYWORDS.filter(function (word) {
      return word.toLowerCase().startsWith(prefix);
    });
    if (matchingWords.length === 0) return NO_COMPLETIONS;

    var range = {
      start: curToken.pos[0],
      end: curToken.pos[1]
    };

    return matchingWords.map(function (word) {
      return {
        label: word,
        kind: { ty: "keyword" },
        edit: { range: range, newText: word }
      };
    });
  }

  function completeIdent(from) {
    return completeKeyword(from).concat(completeFunction(from).concat(completeColumn(from)));
  }

  if (curToken.type === _lex.TOKENS.FAILURE) {
    if (curToken.value === _lex.ERRORS.EMPTY_IDENT) {
      return completeColumn("");
    } else if (curToken.value === _lex.ERRORS.UNTERMINATED_IDENT) {
      return completeColumn(text.slice(curToken.pos[0] + 1));
    }
  }

  if (curToken.type === _lex.TOKENS.IDENT) {
    if (Array.isArray(curToken.value)) {
      return completeColumn(curToken.value);
    } else {
      return completeIdent(curToken.value);
    }
  }

  if (curToken.type === _lex.TOKENS.SYM || curToken.type === _lex.TOKENS.OP) {
    return completeIdent(curToken.value);
  }

  return NO_COMPLETIONS;
}


//////////////////
// WEBPACK FOOTER
// ./node_modules/@sigmacomputing/sling/dist/completion.js
// module id = 1321
// module chunks = 1