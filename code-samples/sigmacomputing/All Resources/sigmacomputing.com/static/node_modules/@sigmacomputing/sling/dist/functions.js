"use strict";

exports.__esModule = true;

var _CATEGORY_DESCRIPTION;

// These match the qwill enum labels
var TY_LOGICAL = exports.TY_LOGICAL = "boolean";
var TY_DATE = exports.TY_DATE = "datetime";
var TY_NUMBER = exports.TY_NUMBER = "number";
var TY_TEXT = exports.TY_TEXT = "text";


// meta type not in qwill
var TY_ANY = exports.TY_ANY = "any";

var FUNCTION_CATEGORIES = exports.FUNCTION_CATEGORIES = {
  UNARY: "Unary Operations",
  BINARY: "Binary Operations",
  LOGICAL: "Logical Functions",
  AGG: "Aggregate Functions",
  WINDOW: "Window Functions",
  MATH: "Math Functions",
  TEXT: "Text Functions",
  DATE: "Date Functions",
  TYPE: "Type Functions"
};

// in markdown
var CATEGORY_DESCRIPTIONS = exports.CATEGORY_DESCRIPTIONS = (_CATEGORY_DESCRIPTION = {}, _CATEGORY_DESCRIPTION[FUNCTION_CATEGORIES.UNARY] = "These prefix operations act on a single operand, " + "typically negating a number or logical variable.", _CATEGORY_DESCRIPTION[FUNCTION_CATEGORIES.BINARY] = "These infix functions operating on adjacent " + "usually of the same type. Common examples include the basic arithmetic operators " + "`+`, `-`, `/`, and `*`", _CATEGORY_DESCRIPTION[FUNCTION_CATEGORIES.LOGICAL] = "Logical functions operate on `True`/`False` values.", _CATEGORY_DESCRIPTION[FUNCTION_CATEGORIES.AGG] = "\nAggregate functions are special functions which summarize columns\nfrom *lower levels*. For example, they can be used to\n[`Sum`](#Sum) all of the values of a column, or [`Count`](#Count) all\nof the values for each grouping of a column. As such, aggregates must\nalways refer to columns in a level lower than the result.\n\nIf the column being aggregated is grouped, then the aggregate is computed\nfor each group. For example, if a column `[Revenue]` is grouped by year,\nthen `Sum(`[Revenue]`)` computes the revenue for each year.\n\nThe results of aggregate functions *can* be referenced by lower\nlevels. An example would be to create a `Sum([Amount])` column as\n`Total` and then an `Amount / Total` column as `Percentage`. This\nconverts each `Amount` value into a relative percentage value.\n", _CATEGORY_DESCRIPTION[FUNCTION_CATEGORIES.WINDOW] = "\nWindow functions are special functions where the result is dependent\non the order and grouping of rows. Window functions can only be used\nin conjunction with sorted rows and changing the sorting will likely\nchange the result. For this reason, window functions are a little\nharder to use, but they are also very powerful.\n\nThe \"window\" for a Window function is defined by the grouping at that level.\nFor example, given a table of city populations, if you grouped by `State`\nand then [`Rank`](#Rank)'ed the cities by `Population`, you would have an\nindependent ranking for each `State`. The result of a window function is determined\nonly by the rows within the window. If there is no grouping, the \"window\"\nis the entire table.\n\n### Cumulative Window Functions\n\nCumulative window functions are aggregate functions which apply to a\nportion of the table. Specifically to all of the rows up-to\nand including the current row.\n\n### Moving Window Functions\n\nMoving window functions are aggregate functions which apply to a\nportion of the table. Specifically to a \"window\" bracketing\nthe current row. A common usage is to calculate a \"moving average\".\n\nThe window is specified as a certain number of rows above and below.\nNote however that the window is also constrianed by the grouping, as\nfor all Window functions.\n", _CATEGORY_DESCRIPTION[FUNCTION_CATEGORIES.MATH] = "These functions return well-known mathematical " + "constants or implement a bevy of common arithmetic functions.", _CATEGORY_DESCRIPTION[FUNCTION_CATEGORIES.TEXT] = "Text functions analyze or manipulate string data " + "and are useful sanitizing string input.", _CATEGORY_DESCRIPTION[FUNCTION_CATEGORIES.DATE] = "Date functions are useful for analyzing date input " + "and extracting individual time components, e.g. year or minute, from date objects.", _CATEGORY_DESCRIPTION[FUNCTION_CATEGORIES.TYPE] = "Type functions are used to convert date of one type " + 'into other types, e.g. from the string `"3"` to the number `3`.', _CATEGORY_DESCRIPTION);

var unaryOps = exports.unaryOps = [{
  name: "-",
  desc: "Flips the sign of the number.",
  category: FUNCTION_CATEGORIES.UNARY,
  params: [{ name: "number", type: TY_NUMBER }],
  returnTy: TY_NUMBER
}, {
  name: "Not",
  desc: "Negates a logical value.",
  category: FUNCTION_CATEGORIES.UNARY,
  params: [{ name: "value", type: TY_LOGICAL }],
  returnTy: TY_LOGICAL
}];

var binaryOps = exports.binaryOps = [{
  name: "^",
  desc: "Raises a number to the specified power.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "number", type: TY_NUMBER }, { name: "power", type: TY_NUMBER }],
  returnTy: TY_NUMBER
}, {
  name: "*",
  desc: "Multiples two numbers.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_NUMBER }, { name: "y", type: TY_NUMBER }],
  returnTy: TY_NUMBER
}, {
  name: "/",
  desc: "Divides one number by another.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_NUMBER }, { name: "y", type: TY_NUMBER }],
  returnTy: TY_NUMBER
}, {
  name: "%",
  desc: "Computes the remainder of dividing x by y.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_NUMBER }, { name: "y", type: TY_NUMBER }],
  returnTy: TY_NUMBER
}, {
  name: "+",
  desc: "Adds two numbers.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_NUMBER }, { name: "y", type: TY_NUMBER }],
  returnTy: TY_NUMBER
}, {
  name: "-",
  desc: "Subtracts one number from another.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_NUMBER }, { name: "y", type: TY_NUMBER }],
  returnTy: TY_NUMBER
}, {
  name: "&",
  desc: "Concatenates two strings together.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_TEXT }, { name: "y", type: TY_TEXT }],
  returnTy: TY_TEXT
}, {
  name: "<",
  desc: "Returns whether x is less than y.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_ANY }, { name: "y", type: TY_ANY }],
  returnTy: TY_LOGICAL
}, {
  name: "<=",
  desc: "Returns whether x is less than or equal to y.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_ANY }, { name: "y", type: TY_ANY }],
  returnTy: TY_LOGICAL
}, {
  name: "=",
  desc: "Returns whether x is equal to y.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_ANY }, { name: "y", type: TY_ANY }],
  returnTy: TY_LOGICAL
}, {
  name: "!=",
  desc: "Returns whether x is not equal to y.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_ANY }, { name: "y", type: TY_ANY }],
  returnTy: TY_LOGICAL
}, {
  name: ">=",
  desc: "Returns whether x is greater than or equal to y.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_ANY }, { name: "y", type: TY_ANY }],
  returnTy: TY_LOGICAL
}, {
  name: ">",
  desc: "Returns whether x is greater than y.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_ANY }, { name: "y", type: TY_ANY }],
  returnTy: TY_LOGICAL
}, {
  name: "and",
  desc: "Returns whether two logical values are both `True`.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_LOGICAL }, { name: "y", type: TY_LOGICAL }],
  returnTy: TY_LOGICAL
}, {
  name: "or",
  desc: "Returns whether either of two logical values are `True`.",
  category: FUNCTION_CATEGORIES.BINARY,
  params: [{ name: "x", type: TY_LOGICAL }, { name: "y", type: TY_LOGICAL }],
  returnTy: TY_LOGICAL
}];

var functions = exports.functions = [
// Logical functions
{
  name: "If",
  desc: "Returns the value following the first condition that is met.",
  category: FUNCTION_CATEGORIES.LOGICAL,
  params: [{
    name: "condition",
    type: TY_LOGICAL,
    splat: true,
    description: "Logical condition. If `True`, returns the following value. " + "Condition-value pairs can be chained together."
  }, {
    name: "value",
    type: TY_ANY,
    splat: true,
    description: "The value to be returned if its preceding condition is `True`."
  }, {
    name: "else",
    type: TY_ANY,
    description: "The value to be returned if no conditionals evaluate as `True`."
  }],
  returnTy: "bound",
  examples: [{
    formula: '([size] < 3, "small", [size] < 6, "medium", "large")',
    explanation: 'Assign `"small"` to sizes less than `3`, `"medium"` to sizes ' + 'less than `6`, and `"large"` to larger sizes.'
  }, {
    formula: '([revenue] - [cost] > 0, "profit", "loss")',
    explanation: "Categorize a record as a profit or a loss based on revenue and cost."
  }]
}, {
  name: "Coalesce",
  desc: "Returns the first non-`Null` value from the arguments.",
  category: FUNCTION_CATEGORIES.LOGICAL,
  params: [{
    name: "argument",
    type: TY_ANY,
    splat: true,
    description: "One or more arguments, the first non-`Null` value of which " + "is returned by this function."
  }],
  returnTy: "bound",
  examples: [{
    formula: "(Null, 1/0, 1/1, 1/2)",
    result: "1",
    explanation: "The third value is the first non-`Null` values"
  }],
  extendedDesc: "If all values are `Null`, `Null` is returned."
}, {
  name: "IsNull",
  desc: "Returns True if the value is `Null` and `False` otherwise.",
  category: FUNCTION_CATEGORIES.LOGICAL,
  params: [{
    name: "value",
    type: TY_ANY,
    description: "Value to test for nullity."
  }],
  returnTy: TY_LOGICAL
},

// Aggregates
{
  name: "Avg",
  desc: "Calculate the numerical average of a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to be averaged."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Population 2010] - [Population 2000])",
    explanation: "Calculate the average change in population in a group."
  }],
  relatedFunctions: ["CumulativeAvg", "Median", "MovingAvg", "PercentileCont"]
}, {
  name: "Corr",
  desc: "Calculate the [Pearson correlation coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient) of two columns",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "field_x",
    type: TY_NUMBER,
    description: "The column representing the dependent data."
  }, {
    name: "field_y",
    type: TY_NUMBER,
    description: "The column representing the independent data."
  }],
  returnTy: TY_NUMBER,
  relatedFunctions: ["CumulativeCorr", "MovingCorr"]
}, {
  name: "Count",
  desc: "Count values within a table or column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "field",
    type: TY_ANY,
    optional: true,
    description: "The column to be counted. `Null` values are skipped."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "()",
    explanation: "Counts number of rows in a table."
  }, {
    formula: "([Funding Total Usd])",
    explanation: "Count number of companies with a disclosed funding total."
  }],
  relatedFunctions: ["CountDistinct", "CountIf", "CumulativeCount", "MovingCount"]
}, {
  name: "CountDistinct",
  desc: "Counts the number of unique values within a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "field",
    type: TY_ANY,
    description: "The column to be counted."
  }],
  examples: [{
    formula: "([City])",
    explanation: "Finds the number of unique city names"
  }],
  returnTy: TY_NUMBER,
  extendedDesc: "Like `Count`, `CountDistinct` does not count `Null` values",
  relatedFunctions: ["Count", "CountIf"]
}, {
  name: "CountIf",
  desc: "Count how often all conditions are true in a table.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "condition",
    type: TY_LOGICAL,
    splat: true,
    description: "A condition to be tested."
  }],
  examples: [{
    formula: "([Age] > 65)",
    explanation: "Count rows where `Age` is greater than `65`"
  }],
  extendedDesc: "If multiple conditions are given, they must *all* be `True` in order to be counted",
  returnTy: TY_NUMBER,
  relatedFunctions: ["Count", "CountDistinct"]
}, {
  name: "Max",
  desc: "Find the maximum value for a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "field",
    type: TY_ANY,
    description: "The column to be searched."
  }],
  returnTy: "bound",
  examples: [{
    formula: "([Birthdate])",
    explanation: "Finds the greatest birthdate. That is, the birthdate of the youngest person"
  }],
  relatedFunctions: ["CumulativeMax", "Min", "MovingMax"]
}, {
  name: "Min",
  desc: "Find the minimum value for a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "field",
    type: TY_ANY,
    description: "The column to be searched."
  }],
  examples: [{
    formula: "([Balance])",
    explanation: "Finds the smallest balance. Could be negative."
  }, {
    formula: "([Name])",
    explanation: 'Finds the first name if the the column was sorted. If `Name` was `"Betty"`, `"Charles"` and `"Anne"`, the result would be `"Anne"`'
  }],
  returnTy: "bound",
  relatedFunctions: ["CumulativeMin", "Max", "MovingMin"]
}, {
  name: "Ndv",
  desc: "Counts the number of unique values within a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "field",
    type: TY_ANY,
    description: "The column to be counted."
  }],
  examples: [{
    formula: "([City])",
    explanation: "Finds the number of unique city names"
  }],
  returnTy: TY_NUMBER,
  extendedDesc: "Like `Count`, `Ndv` does not count `Null` values",
  relatedFunctions: ["Count", "CountDistinct"],
  deprecated: true
}, {
  name: "Stddev",
  desc: "Compute the [standard deviation](https://en.wikipedia.org/wiki/Standard_deviation) of a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to be measured."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Lap Time])",
    explanation: "Find the standard deviation of lap times."
  }],
  relatedFunctions: ["CumulativeStddev", "MovingStddev", "Variance"]
}, {
  name: "Sum",
  desc: "Sum the values in a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to be summed."
  }],
  returnTy: TY_NUMBER,
  extendedDesc: "`Null` values are skipped",
  examples: [{
    formula: "([Price])",
    explanation: "Find the total of `Price`."
  }],
  relatedFunctions: ["CumulativeSum", "MovingSum"]
}, {
  name: "Variance",
  desc: "Compute the [statistical variance](https://en.wikipedia.org/wiki/Variance) of a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to be measured."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Temperature])",
    explanation: "Find the variance of temperature samples."
  }],
  relatedFunctions: ["CumulativeVariance", "MovingVariance", "Stddev"]
}, {
  name: "Median",
  desc: "Find the [median](https://en.wikipedia.org/wiki/Median) of a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "column",
    type: TY_NUMBER,
    description: "The column to be searched."
  }],
  returnTy: TY_NUMBER,
  extendedDesc: "If there is an even number of values, `Median` will interpolate between the middle values.",
  examples: [{
    formula: "([Temperature])",
    explanation: "Find the median temperature value. For example, if the `column` values were `3`, `5`, `7` and `20` the result would be `6`."
  }],
  relatedFunctions: ["Avg", "PercentileCont", "PercentileDisc"]
}, {
  name: "PercentileCont",
  desc: "Calculate the continuous [percentile](https://en.wikipedia.org/wiki/Percentile) value for a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "column",
    type: TY_NUMBER,
    description: "The column to be searched."
  }, {
    name: "fraction",
    type: TY_NUMBER,
    description: "Percentile fraction between `0` and `1`."
  }],
  returnTy: TY_NUMBER,
  extendedDesc: "Interpolation is done between adjacent values if needed.",
  examples: [{
    formula: "([Score], 0.7)",
    explanation: "If the `column` values are `2`, `4`, `6`, `8`, and `10`, the result would be `7.6`."
  }],
  relatedFunctions: ["Avg", "Median", "PercentileDisc"]
}, {
  name: "PercentileDisc",
  desc: "Find the discrete [percentile](https://en.wikipedia.org/wiki/Percentile) value for a column.",
  category: FUNCTION_CATEGORIES.AGG,
  params: [{
    name: "column",
    type: TY_NUMBER,
    description: "The column to be searched."
  }, {
    name: "fraction",
    type: TY_NUMBER,
    description: "Percentile fraction between `0` and `1`."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Score], 0.7)",
    explanation: "If the `column` values are `2`, `4`, `6`, `8`, and `10`, the result would be `8`."
  }],
  relatedFunctions: ["Avg", "Median", "PercentileCont"]
},

// Cumulative (running) aggregates
{
  name: "CumulativeAvg",
  desc: "Calculates the numerical average of the column up to and including the current value.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to take averages from."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Population 2010])",
    explanation: "For each value in [Population 2010], calculate the average of that value and everything before it."
  }],
  extendedDesc: "Cumulative functions depend on the order of the given column. If you change the sorting you will change the result",
  relatedFunctions: ["Avg", "MovingAvg"]
}, {
  name: "CumulativeCorr",
  desc: "Calculates the correlation coefficient of the column up to and including the current value.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field1",
    type: TY_NUMBER,
    description: "The first column out of the two to calculate the correlation coefficient from."
  }, {
    name: "field2",
    type: TY_NUMBER,
    description: "The second column out of the two to calculate the correlation coefficient from."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Population 2010], [Population 2000])",
    explanation: "For each pair of values in [Population 2010] and [Population 2000], " + "calculate the correlation coefficient the group of values containing " + "that pair of values and all the preceding values."
  }],
  relatedFunctions: ["Corr", "MovingCorr"]
}, {
  name: "CumulativeCount",
  desc: "Counts the number of non-null values up and including to the current value.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "column",
    type: TY_ANY,
    description: "The column to count."
  }],
  returnTy: TY_NUMBER,
  examples: [],
  relatedFunctions: ["Count", "MovingCount"]
}, {
  name: "CumulativeMin",
  desc: "Calculates the minimum across the values up to and including the current value.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "column",
    type: TY_ANY,
    description: "The column to calculate the minimum from."
  }],
  returnTy: "bound",
  examples: [],
  relatedFunctions: ["CumulativeMax", "Min", "MovingMin"]
}, {
  name: "CumulativeMax",
  desc: "Calculates the maximum across the values up to and including the current value.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field",
    type: TY_ANY,
    description: "The column to calculate the maximum from."
  }],
  returnTy: "bound",
  examples: [],
  relatedFunctions: ["CumulativeMin", "Max", "MovingMax"]
}, {
  name: "CumulativeStddev",
  desc: "Calculates the standard deviation across the values up to and including the current value.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to calculate the standard deviation from."
  }],
  returnTy: TY_NUMBER,
  examples: [],
  relatedFunctions: ["CumulativeVariance", "MovingStddev", "Stddev"]
}, {
  name: "CumulativeSum",
  desc: "Calculates the sum across the values up to and including the current value.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to calculate the sum from."
  }],
  returnTy: TY_NUMBER,
  examples: [],
  relatedFunctions: ["MovingSum", "Sum"]
}, {
  name: "CumulativeVariance",
  desc: "Calculates the variance across the values up to and including the current value.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to calculate the variance from."
  }],
  returnTy: TY_NUMBER,
  examples: [],
  relatedFunctions: ["CumulativeStddev", "MovingVariance", "Variance"]
},

// Moving aggregates
{
  name: "MovingAvg",
  desc: "Calculates the numerical average in a moving window.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "column",
    type: TY_NUMBER,
    description: "The column to average."
  }, {
    name: "above",
    type: TY_NUMBER,
    description: "The number of rows *above* the current to include."
  }, {
    name: "below",
    type: TY_NUMBER,
    optional: true,
    description: "The number of rows *below* the current to include. Defaults to `0`"
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Population 2010], 4, 0)",
    explanation: "For each value in [Population 2010] and the 4 values above it, calculate the average."
  }],
  relatedFunctions: ["Avg", "CumulativeAvg"]
}, {
  name: "MovingCorr",
  desc: "Calculates the correlation coefficient in a moving window.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field1",
    type: TY_NUMBER,
    description: "The column representing the dependent data."
  }, {
    name: "field2",
    type: TY_NUMBER,
    description: "The column representing the independent data."
  }, {
    name: "above",
    type: TY_NUMBER,
    description: "The number of rows *above* the current to include."
  }, {
    name: "below",
    type: TY_NUMBER,
    optional: true,
    description: "The number of rows *below* the current to include. Defaults to `0`"
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Population 2010], [Population 2000], 5, 5)",
    explanation: "Calculate the correlation coefficient between the populations for each set of 11 adjacent values."
  }],
  relatedFunctions: ["Corr", "CumulativeCorr"]
}, {
  name: "MovingCount",
  desc: "Count values in a moving window.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "column",
    type: TY_ANY,
    description: "The column to count. `Null` values are skipped."
  }, {
    name: "above",
    type: TY_NUMBER,
    description: "The number of rows *above* the current to include."
  }, {
    name: "below",
    type: TY_NUMBER,
    optional: true,
    description: "The number of rows *below* the current to include. Defaults to `0`"
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Population 2010], 5, 5)",
    explanation: "Calculate the correlation coefficient between the populations for each set of 11 adjacent values."
  }],
  relatedFunctions: ["CumulativeCount", "Count"]
}, {
  name: "MovingMin",
  desc: "Find the minimum value within a moving window.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field",
    type: TY_ANY,
    description: "The column to be searched."
  }, {
    name: "above",
    type: TY_NUMBER,
    description: "The number of rows *above* the current to include."
  }, {
    name: "below",
    type: TY_NUMBER,
    optional: true,
    description: "The number of rows *below* the current to include. Defaults to `0`"
  }],
  returnTy: "bound",
  examples: [{
    formula: "([Population 2010], 5, 5)",
    explanation: "Calculate the minimum population for each set of 11 adjacent values."
  }],
  relatedFunctions: ["CumulativeMin", "Min", "MovingMax"]
}, {
  name: "MovingMax",
  desc: "Find the maximum value within a moving window.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field",
    type: TY_ANY,
    description: "The column to be searched."
  }, {
    name: "above",
    type: TY_NUMBER,
    description: "The number of rows *above* the current to include."
  }, {
    name: "below",
    type: TY_NUMBER,
    optional: true,
    description: "The number of rows *below* the current to include. Defaults to `0`"
  }],
  returnTy: "bound",
  examples: [{
    formula: "([Population 2010], 5, 5)",
    explanation: "Calculate the maximum population for each set of 11 adjacent values."
  }],
  relatedFunctions: ["CumulativeMax", "Max", "MovingMin"]
}, {
  name: "MovingStddev",
  desc: "Calculate the [standard deviation](https://en.wikipedia.org/wiki/Standard_deviation) withing a moving window.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to be measured."
  }, {
    name: "above",
    type: TY_NUMBER,
    description: "The number of rows *above* the current to include."
  }, {
    name: "below",
    type: TY_NUMBER,
    optional: true,
    description: "The number of rows *below* the current to include. Defaults to `0`"
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Population 2010], 5, 5)",
    explanation: "Calculate the standard deviation for each set of 11 adjacent values."
  }],
  relatedFunctions: ["CumulativeStddev", "Stddev"]
}, {
  name: "MovingSum",
  desc: "Sum the values in a moving window.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to be summed."
  }, {
    name: "above",
    type: TY_NUMBER,
    description: "The number of rows *above* the current to include."
  }, {
    name: "below",
    type: TY_NUMBER,
    optional: true,
    description: "The number of rows *below* the current to include. Defaults to `0`"
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Population 2010], 10)",
    explanation: "Calculate the total for each row and the 10 above it."
  }],
  relatedFunctions: ["CumulativeSum", "Sum"]
}, {
  name: "MovingVariance",
  desc: "Calculates the [statistical variance](https://en.wikipedia.org/wiki/Variance) in a moving window.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "The column to be measured."
  }, {
    name: "above",
    type: TY_NUMBER,
    description: "The number of rows *above* the current to include."
  }, {
    name: "below",
    type: TY_NUMBER,
    optional: true,
    description: "The number of rows *below* the current to include. Defaults to `0`"
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "([Population 2010], 5, 5)",
    explanation: "Calculate the variance for each `Population 2010` value and 5 above and below."
  }]
},

// Window functions
{
  name: "RowNumber",
  desc: "Number the rows in the table using the input column. Begins with `1`",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "column",
    type: TY_ANY,
    description: "The column used to order the table."
  }, {
    name: "direction",
    type: TY_TEXT,
    optional: true,
    description: "The direction to sort the input column."
  }],
  returnTy: TY_NUMBER,
  extendedDesc: "Each rows is numbered according to the input column's ordering.",
  relatedFunctions: ["Rank", "RankDense"]
}, {
  name: "Rank",
  desc: "Rank the rows in the table using the input column. Begins with `1`",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "column",
    type: TY_ANY,
    description: "The column used to order the table."
  }, {
    name: "direction",
    type: TY_TEXT,
    optional: true,
    description: "The direction to sort the input column."
  }],
  returnTy: TY_NUMBER,
  extendedDesc: "Rows which sort identically are ranked identically. For example: if the input has" + '`"Anne"`, `"Jane"`, `"Jane"` and `"Pari"`, they would be ranked `1`, `2`, `2` and `4`.',
  relatedFunctions: ["RowNumber", "RankDense"]
}, {
  name: "RankDense",
  desc: "Rank the rows in the table using the input column. Begins with `1`",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "column",
    type: TY_ANY,
    description: "The column used to order the table."
  }, {
    name: "direction",
    type: TY_TEXT,
    optional: true,
    description: "The direction to sort the input column."
  }],
  returnTy: TY_NUMBER,
  extendedDesc: "Rows which sort identically are ranked identically. For example: if the input has" + '`"Anne"`, `"Jane"`, `"Jane"` and `"Pari"`, they would be ranked `1`, `2`, `2` and `3`.',
  relatedFunctions: ["RowNumber", "Rank"]
}, {
  name: "RankPercentile",
  desc: "Rank the rows in the table by percentile using the input column. Begins with `1`",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "column",
    type: TY_ANY,
    description: "The column used to order the table."
  }, {
    name: "direction",
    type: TY_TEXT,
    optional: true,
    description: "The direction to sort the input column."
  }],
  returnTy: TY_NUMBER,
  extendedDesc: "The [percentile](https://en.wikipedia.org/wiki/Percentile) is a number between `0` and `1`. " + "The last row is always `1` and the first is `0` (unless there is only 1 row).",
  relatedFunctions: ["Rank", "PercentileCont", "CumeDist"]
}, {
  name: "CumeDist",
  desc: "Compute the cumulative distribution of the input column.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "column",
    type: TY_ANY,
    description: "The column used to order the table."
  }, {
    name: "direction",
    type: TY_TEXT,
    optional: true,
    description: "The direction to sort the input column."
  }],
  returnTy: TY_NUMBER,
  extendedDesc: "The cumulative distribution is a number between `0` and `1`. The last row is always `1`.",
  relatedFunctions: ["RankPercentile"]
}, {
  name: "Ntile",
  desc: "Assign the rows of a column to a given number of ranks",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "ranks",
    type: TY_NUMBER,
    description: "Number of ranks. Must be an integer greater than `0`."
  }, {
    name: "column",
    type: TY_ANY,
    description: "The column used to order the table."
  }, {
    name: "direction",
    type: TY_TEXT,
    optional: true,
    description: "The direction to sort the input column."
  }],
  examples: [{
    formula: "(3)",
    explanation: "Each row is ranked either `1`, `2` or `3`."
  }],
  extendedDesc: "An equal number of rows will be given each `Ntile` rank. The `Ntile` ranks are assigned in order.",
  returnTy: TY_NUMBER
}, {
  name: "Lag",
  desc: "Shift a column downward.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "value",
    type: TY_ANY,
    description: "Column to be shifted."
  }, {
    name: "offset",
    type: TY_NUMBER,
    optional: true,
    description: "Distance, in rows, to shift. Must be an integer greater than `0`. Defaults to `1` if omitted."
  }, {
    name: "default",
    type: TY_ANY,
    optional: true,
    description: "Default value for the first `offset` rows. `Null` if omitted."
  }],
  returnTy: "bound",
  examples: [{
    formula: "([Quarter], 2)",
    explanation: 'If `Quarter` has `"Q1"`, `"Q2"`, `"Q3"` and `"Q4"`, the `Lag` of `2` would be `Null`, `Null`, `"Q1"` and `"Q2"`'
  }],
  relatedFunctions: ["Lag"]
}, {
  name: "Lead",
  desc: "Shift a column upward.",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "value",
    type: TY_ANY,
    description: "Column to be shifted."
  }, {
    name: "offset",
    type: TY_NUMBER,
    optional: true,
    description: "Distance, in rows, to shift. Must be an integer greater than `0`. Defaults to `1` if omitted."
  }, {
    name: "default",
    type: TY_ANY,
    optional: true,
    description: "Default value for the last `offset` rows. `Null` if omitted."
  }],
  returnTy: "bound",
  examples: [{
    formula: "([Quarter], 1)",
    explanation: 'If `Quarter` has `"Q1"`, `"Q2"`, `"Q3"` and `"Q4"`, the `Lead` of `1` would be `"Q2"`, `"Q3"`, `"Q4"` and `Null`'
  }],
  relatedFunctions: ["Lag"]
}, {
  name: "First",
  desc: "Repeat the first value of the given column for every row in a column",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "value",
    type: TY_ANY,
    description: "Column to pick from."
  }],
  returnTy: "bound",
  examples: [{
    formula: "([Quarter])",
    explanation: 'If `Quarter` has `"Q1"`, `"Q2"`, `"Q3"` and `"Q4"`, the result would be `"Q1"`, `"Q1"`, `"Q1"` and `"Q1"`.'
  }],
  relatedFunctions: ["Last", "Nth"]
}, {
  name: "Last",
  desc: "Repeat the last value of the given column for every row in a column",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "value",
    type: TY_ANY,
    description: "Column to pick from."
  }],
  returnTy: "bound",
  examples: [{
    formula: "([Quarter])",
    explanation: 'If `Quarter` has `"Q1"`, `"Q2"`, `"Q3"` and `"Q4"`, the result would be `"Q4"`, `"Q4"`, `"Q4"` and `"Q4"`.'
  }],
  relatedFunctions: ["First", "Nth"]
}, {
  name: "Nth",
  desc: "Repeat the *nth* value of the the given column for every row in a column",
  category: FUNCTION_CATEGORIES.WINDOW,
  params: [{
    name: "value",
    type: TY_ANY,
    description: "Column to pick from."
  }, {
    name: "nth",
    type: TY_NUMBER,
    description: "Offset from top of column. Must be an integer greater than `0`."
  }],
  returnTy: "bound",
  examples: [{
    formula: "([Quarter], 2)",
    explanation: 'If `Quarter` has `"Q1"`, `"Q2"`, `"Q3"` and `"Q4"`, the result would be `"Q2"`, `"Q2"`, `"Q2"` and `"Q2"`.'
  }],
  relatedFunctions: ["First", "Last"]
},

// Math functions
{
  name: "Abs",
  desc: "Returns the absolute value of a number.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "value",
    type: TY_NUMBER,
    description: "The number to convert into an absolute value."
  }],
  returnTy: TY_NUMBER
}, {
  name: "Ceiling",
  desc: "Returns smallest integer not less than input.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "Value to be rounded up."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "(3.2)",
    result: "4"
  }, {
    formula: "(-3.2)",
    result: "-3"
  }],
  relatedFunctions: ["Floor"]
}, {
  name: "Div",
  desc: "Returns the integer component of a division operation.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "dividend",
    type: TY_NUMBER,
    description: "The number to be divided."
  }, {
    name: "divisor",
    type: TY_NUMBER,
    description: "The number to divide by."
  }],
  returnTy: TY_NUMBER
}, {
  name: "Exp",
  desc: "Returns `e` (`2.7183`...) raised to the given power.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "value",
    type: TY_NUMBER,
    description: "The exponent to which to raise e."
  }],
  returnTy: TY_NUMBER
}, {
  name: "Floor",
  desc: "Returns largest integer not greater than the input.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "field",
    type: TY_NUMBER,
    description: "Value to be rounded down."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "(3.2)",
    result: "3"
  }, {
    formula: "(-3.2)",
    result: "-4"
  }],
  relatedFunctions: ["Ceiling"]
}, {
  name: "Greatest",
  desc: "Returns the largest value amongst the inputs.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "x",
    type: [TY_DATE, TY_NUMBER, TY_TEXT],
    splat: true,
    description: "The expression to be evaluated."
  }],
  returnTy: "bound"
}, {
  name: "Least",
  desc: "Returns the smallest value amongst the inputs.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "x",
    type: [TY_DATE, TY_NUMBER, TY_TEXT],
    splat: true,
    description: "The expression to be evaluated."
  }],
  returnTy: "bound"
}, {
  name: "Ln",
  desc: "Compute the natural logarithm of a number.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "value",
    type: TY_NUMBER,
    description: "The number for which to calculate the base e logarithm."
  }],
  returnTy: TY_NUMBER
}, {
  name: "Log",
  desc: "Compute the logarithm of a number, defaulting to base 10.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "value",
    type: TY_NUMBER,
    description: "The number for which to calculate the logarithm."
  }, {
    name: "base",
    type: TY_NUMBER,
    optional: true,
    description: "The optional base for the logarithm. Defaults to base 10."
  }],
  returnTy: TY_NUMBER
}, {
  name: "Pi",
  desc: "Returns the mathematical constant π = 3.14159...",
  category: FUNCTION_CATEGORIES.MATH,
  params: [],
  returnTy: TY_NUMBER
}, {
  name: "Round",
  desc: "Round a number to the specified number of digits.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "number",
    type: TY_NUMBER,
    description: "Number to be rounded."
  }, {
    name: "digits",
    type: TY_NUMBER,
    optional: true,
    description: "Number of decimal places to which to round."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: "(Pi(), 2)",
    result: "3.14"
  }, {
    formula: "(3.1, 2)",
    result: "3.1",
    explanation: "Rounding is different than formatting: The result may have fewer digits than specified"
  }, {
    formula: "(1234, -2)",
    result: "1200"
  }],
  extendedDesc: "A negative `digits` value will return an integer with than many least-significant digits zeroed."
}, {
  name: "Sign",
  desc: "Returns the sign of a number: `-1` if negative, `1` if positive, `0` if zero.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "number",
    type: TY_NUMBER,
    description: "The number whose sign will be evaluated."
  }],
  returnTy: TY_NUMBER
}, {
  name: "Sqrt",
  desc: "Compute the positive square root of a positive number.",
  category: FUNCTION_CATEGORIES.MATH,
  params: [{
    name: "value",
    type: TY_NUMBER,
    description: "The positive number whose root will be calculated."
  }],
  returnTy: TY_NUMBER
},

// Text functions
{
  name: "Concat",
  desc: "Combine strings together.",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    splat: true,
    description: "One or more strings to be combined in sequence."
  }],
  returnTy: TY_TEXT,
  examples: [{
    formula: '("queen", "bee")',
    result: '"queenbee"'
  }, {
    formula: '("queen", " ", "bee")',
    result: '"queen bee"'
  }],
  extendedDesc: "No extra space is added between values. All arguments to `Concat` must be strings."
}, {
  name: "SplitPart",
  desc: "Splits the string with the given delimiter and returns the nth part.",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The source string to be split."
  }, {
    name: "delimiter",
    type: TY_TEXT,
    description: "The string to split with."
  }, {
    name: "position",
    type: TY_NUMBER,
    description: "The index of the part to return."
  }],
  returnTy: TY_TEXT,
  examples: [{
    formula: '("quick brown fox", " ", 1)',
    result: '"quick"'
  }, {
    formula: '("quick brown fox", " ", -1)',
    result: '"fox"',
    explanation: "A negative `position` selects from the end"
  }]
}, {
  name: "Find",
  desc: "Returns the index at which a substring is first found within a given string.",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The source string to be searched through."
  }, {
    name: "substring",
    type: TY_TEXT,
    description: "The substring to be found."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: '("milk+cookies", "cook")',
    result: "6"
  }, {
    formula: '("milk+cookies", "chocolate milk")',
    result: "0",
    explanation: "If the `substring` is not found, the result is `0`"
  }, {
    formula: '("Abe Lincoln", "lincoln")',
    result: "0",
    explanation: "`Find` is case-sensitive"
  }],
  relatedFunctions: ["Left", "Mid", "Right"]
}, {
  name: "Left",
  desc: "Returns a substring beginning at the start of a given string.",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The string from which a left substring will be returned."
  }, {
    name: "number",
    type: TY_NUMBER,
    description: "The desired length of the returned substring."
  }],
  returnTy: TY_TEXT,
  examples: [{
    formula: '("Dec. 12, 1950", 3)',
    result: '"Dec"'
  }, {
    formula: '("St. Louis", 20)',
    result: '"St. Louis"',
    explanation: "If `number` is greater than the `Len` of `string`, the result is the original string."
  }, {
    formula: 'Left("Abe Lincoln", Find("Abe Lincoln", " ") - 1)',
    result: '"Abe"',
    explanation: "`Left` can be used in conjunction with `Find`"
  }],
  relatedFunctions: ["Find", "Mid", "Right"]
}, {
  name: "Len",
  desc: "Returns the number of characters in a string.",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The string to be measured."
  }],
  examples: [{
    formula: '("")',
    result: "0"
  }, {
    formula: '("東京大学")',
    result: "4"
  }],
  returnTy: TY_NUMBER
}, {
  name: "Lower",
  desc: "Converts a given string to lowercase.",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The string to convert to lowercase."
  }],
  returnTy: TY_TEXT,
  examples: [{
    formula: '("San Francisco, California")',
    result: '"san francisco, california"'
  }],
  relatedFunctions: ["Upper"]
}, {
  name: "LTrim",
  desc: "Removes leading spaces from a given string",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The string to be trimmed."
  }],
  returnTy: TY_TEXT,
  examples: [{
    formula: '("  John Doe ")',
    result: '"John Doe "'
  }],
  relatedFunctions: ["RTrim", "Trim"]
}, {
  name: "Mid",
  desc: "Returns a substring defined by offset and length",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The string to extract a substring from."
  }, {
    name: "start",
    type: TY_NUMBER,
    description: "The index from the start of the given string from which " + "to begin extracting, treating the first character as having index 1"
  }, {
    name: "length",
    type: TY_NUMBER,
    optional: true,
    description: "The length of the segment to extract. Absent this, or if " + "the provided length is greater than that remaining in the source " + "string, the returned substring will run to the end of the source string."
  }],
  returnTy: TY_TEXT,
  relatedFunctions: ["Find", "Left", "Right"]
}, {
  name: "Replace",
  desc: "Searches a string for a subtring and replaces it.",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "String to be searched and modified."
  }, {
    name: "substring",
    type: TY_TEXT,
    description: "String to be found and replaced."
  }, {
    name: "replacement",
    type: TY_TEXT,
    description: "String to replace the sought substring."
  }],
  returnTy: TY_TEXT
}, {
  name: "Right",
  desc: "Returns a substring terminating at the end of a given string.",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The string from which a right substring will be returned"
  }, {
    name: "number",
    type: TY_NUMBER,
    description: "The desired length of the returned substring."
  }],
  returnTy: TY_TEXT,
  relatedFunctions: ["Find", "Left", "Mid"]
}, {
  name: "RTrim",
  desc: "Removes trailing spaces from a given string",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The string to be trimmed."
  }],
  returnTy: TY_TEXT,
  examples: [{
    formula: '("  John Doe ")',
    result: '"  John Doe"'
  }],
  relatedFunctions: ["LTrim", "Trim"]
}, {
  name: "Trim",
  desc: "Removes leading and trailing spaces from a given string",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The string to be trimmed."
  }],
  returnTy: TY_TEXT,
  examples: [{
    formula: '("  John Doe ")',
    result: '"John Doe"'
  }],
  relatedFunctions: ["LTrim", "RTrim"]
}, {
  name: "Upper",
  desc: "Converts a given string to uppercase.",
  category: FUNCTION_CATEGORIES.TEXT,
  params: [{
    name: "string",
    type: TY_TEXT,
    description: "The string to convert to uppercase."
  }],
  returnTy: TY_TEXT,
  examples: [{
    formula: '("Warning")',
    result: '"WARNING"'
  }],
  relatedFunctions: ["Lower"]
},

// Date functions
{
  name: "DatePart",
  desc: "Extract the specified date part, e.g. 'month', from the given date.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "precision",
    type: TY_TEXT,
    description: "Date part to be extracted, chosen from year, month, " + "week, day, hour, minute, second, and millisecond."
  }, {
    name: "date",
    type: TY_DATE,
    description: "Date from which date part is to be extracted."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: '("year", Date("2007-08-14"))',
    explanation: "The year from this date, 2007."
  }, {
    formula: '("week", Date("2007-01-10 10:00:00"))',
    explanation: "The [ISO week number](https://en.wikipedia.org/wiki/ISO_week_date) of this date, 2."
  }]
}, {
  name: "DateTrunc",
  desc: "Truncate the date to the specified date part, e.g. 'month'.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "precision",
    type: TY_TEXT,
    description: "Smallest date part to preserve, chosen from year, month, " + "week, day, hour, month, and second."
  }, {
    name: "date",
    type: TY_DATE,
    description: "Date to be truncated."
  }],
  returnTy: TY_DATE,
  examples: [{
    formula: '("hour", Date("1980-05-22 8:45:30"))',
    result: 'Date("1980-05-22 8:00:00")',
    explanation: 'Discard the "minute" and "second" components of the date'
  }, {
    formula: '("day", Date("1980-05-22 8:45:30"))',
    result: 'Date("1980-05-22 12:00:00")',
    explanation: "Discard the time components of the date"
  }]
}, {
  name: "DateDiff",
  desc: "Calculates the time difference between two dates.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "unit",
    type: TY_TEXT,
    description: "Unit to use for the difference, chosen from year, month, " + "week, day, hour, minute, and second."
  }, {
    name: "start",
    type: TY_DATE,
    description: "The starting date."
  }, {
    name: "end",
    type: TY_DATE,
    description: "The ending date."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: '("year", Date("1961-05-25"), Date("1969-07-20"))',
    result: "8",
    explanation: "The time, in years, from the `start` date to the `end` date: "
  }, {
    formula: '("hour", Date("1969-07-16 13:32:00"), Date("1969-07-20 20:17:40"))',
    result: "103",
    explanation: "The time, in hours, from the `start` date to the `end` date"
  }],
  extendedDesc: "The result is rounded to a whole number. If `end` is before `start` the result is negative."
}, {
  name: "DateAdd",
  desc: "Adds the quantity of time to a date.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "unit",
    type: TY_TEXT,
    description: "Unit of the `amount`. Chosen from year, month, " + "week, day, hour, minute, and second."
  }, {
    name: "amount",
    type: TY_NUMBER,
    description: "The quantity of time to add."
  }, {
    name: "date",
    type: TY_DATE,
    description: "A date field."
  }],
  returnTy: TY_DATE,
  examples: [{
    formula: '("minute", 60, Date("1999-12-31 23:00:00"))',
    result: 'Date("2000-01-01 00:00:00")',
    explanation: "Add 60 minutes to the `date`"
  }],
  extendedDesc: "The quantity to add is rounded to the nearest whole number. If `end` is before `start` the result is before `date` by the `amount`."
}, {
  name: "DateFromUnix",
  desc: "Convert seconds from unix epoch to a date.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "seconds",
    type: TY_NUMBER,
    description: "Seconds since epoch"
  }],
  returnTy: TY_DATE,
  extendedDesc: "Convert a [Unix-style timestamp](https://en.wikipedia.org/wiki/Unix_time) (seconds since January 1, 1970) to a Date.",
  examples: [{
    formula: "(0)",
    result: 'Date("1970-01-01T00:00:00Z")'
  }, {
    formula: "(1503724894)",
    result: 'Date("2017-08-26T05:21:34Z")'
  }],
  relatedFunctions: ["Date"]
}, {
  name: "Day",
  desc: "Returns the day of the month of the given date as a number.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "date",
    type: TY_DATE,
    description: "The date from which to extract the day component."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: '(Date("2007-08-14"))',
    result: "14"
  }],
  relatedFunctions: ["DatePart"]
}, {
  name: "Hour",
  desc: "Returns the hour component of the given date as a number.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "date",
    type: TY_DATE,
    description: "The date from which to extract the hour component."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: '(Date("2007-08-14 07:11:00"))',
    result: "7"
  }],
  relatedFunctions: ["DatePart"]
}, {
  name: "Minute",
  desc: "Returns the minute component of the given date as a number.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "date",
    type: TY_DATE,
    description: "The date from which to extract the minute component."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: '(Date("2007-08-14 07:11:00"))',
    result: "11"
  }],
  relatedFunctions: ["DatePart"]
}, {
  name: "Month",
  desc: "Returns the month component of the given date as a number.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "date",
    type: TY_DATE,
    description: "The date from which to extract the month component."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: '(Date("2007-08-14"))',
    result: "8"
  }],
  relatedFunctions: ["DatePart"]
}, {
  name: "Now",
  desc: "Returns the current date and time",
  category: FUNCTION_CATEGORIES.DATE,
  params: [],
  returnTy: TY_DATE,
  relatedFunctions: ["Today"]
}, {
  name: "Today",
  desc: "Returns the current date",
  category: FUNCTION_CATEGORIES.DATE,
  params: [],
  returnTy: TY_DATE,
  relatedFunctions: ["Now"]
}, {
  name: "Second",
  desc: "Returns the second component of the given date as a number.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "date",
    type: TY_DATE,
    description: "The date from which to extract the second component."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: '(Date("2007-08-14 07:11:05"))',
    result: "5"
  }],
  relatedFunctions: ["DatePart"]
}, {
  name: "Weekday",
  desc: "Returns the day of the week as Sunday (1) to Saturday (7)",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "date",
    type: TY_DATE,
    description: "The date from which to extract the year component."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: '(Date("2017-12-01"))',
    result: "6"
  }],
  relatedFunctions: ["DatePart"]
}, {
  name: "Year",
  desc: "Returns the year component of the given date as a number.",
  category: FUNCTION_CATEGORIES.DATE,
  params: [{
    name: "date",
    type: TY_DATE,
    description: "The date from which to extract the year component."
  }],
  returnTy: TY_NUMBER,
  examples: [{
    formula: '(Date("2007-08-14"))',
    result: "2007"
  }],
  relatedFunctions: ["DatePart"]
},

// Type functions
{
  name: "Date",
  desc: "Convert the value into a date and time.",
  category: FUNCTION_CATEGORIES.TYPE,
  params: [{
    name: "value",
    type: [TY_DATE, TY_NUMBER, TY_TEXT],
    description: "Value to be converted into a date and time."
  }],
  extendedDesc: "The given *Text* value can be a date *or* a date and time. If given a *Number* `Date` behaves like `DateFromUnix`.",
  returnTy: TY_DATE,
  relatedFunctions: ["DateFromUnix"]
}, {
  name: "Datetime",
  desc: "Convert the value into a date and time.",
  category: FUNCTION_CATEGORIES.TYPE,
  params: [{
    name: "value",
    type: [TY_DATE, TY_TEXT],
    description: "Value to be converted into a date and time."
  }],
  returnTy: TY_DATE,
  extendedDesc: "Deprecated in favor of `Date`",
  relatedFunctions: ["Date"],
  deprecated: true
}, {
  name: "Logical",
  desc: "Convert the value into True or False.",
  category: FUNCTION_CATEGORIES.TYPE,
  params: [{
    name: "value",
    type: [TY_LOGICAL, TY_NUMBER, TY_TEXT],
    description: "Value to be converted into a boolean."
  }],
  returnTy: TY_LOGICAL
}, {
  name: "Number",
  desc: "Convert the value into a number.",
  category: FUNCTION_CATEGORIES.TYPE,
  params: [{
    name: "value",
    type: [TY_NUMBER, TY_TEXT],
    description: "Value to be converted into a number."
  }],
  returnTy: TY_NUMBER
}, {
  name: "Text",
  desc: "Convert the value into a string.",
  category: FUNCTION_CATEGORIES.TYPE,
  params: [{
    name: "value",
    type: TY_ANY,
    description: "Value to be converted into a string."
  }],
  returnTy: TY_TEXT
}];


//////////////////
// WEBPACK FOOTER
// ./node_modules/@sigmacomputing/sling/dist/functions.js
// module id = 262
// module chunks = 1