"use strict";
var validator_1 = require('./validator');
var validate_trigger_1 = require('./validate-trigger');
var property_info_1 = require('./property-info');
var validation_error_1 = require('./validation-error');
/**
 * Orchestrates validation.
 * Manages a set of bindings, renderers and objects.
 * Exposes the current list of validation errors for binding purposes.
 */
var ValidationController = (function () {
    function ValidationController(validator) {
        this.validator = validator;
        // Registered bindings (via the validate binding behavior)
        this.bindings = new Map();
        // Renderers that have been added to the controller instance.
        this.renderers = [];
        /**
         * Errors that have been rendered by the controller.
         */
        this.errors = [];
        /**
         *  Whether the controller is currently validating.
         */
        this.validating = false;
        // Elements related to errors that have been rendered.
        this.elements = new Map();
        // Objects that have been added to the controller instance (entity-style validation).
        this.objects = new Map();
        /**
         * The trigger that will invoke automatic validation of a property used in a binding.
         */
        this.validateTrigger = validate_trigger_1.validateTrigger.blur;
        // Promise that resolves when validation has completed.
        this.finishValidating = Promise.resolve();
    }
    /**
     * Adds an object to the set of objects that should be validated when validate is called.
     * @param object The object.
     * @param rules Optional. The rules. If rules aren't supplied the Validator implementation will lookup the rules.
     */
    ValidationController.prototype.addObject = function (object, rules) {
        this.objects.set(object, rules);
    };
    /**
     * Removes an object from the set of objects that should be validated when validate is called.
     * @param object The object.
     */
    ValidationController.prototype.removeObject = function (object) {
        this.objects.delete(object);
        this.processErrorDelta('reset', this.errors.filter(function (error) { return error.object === object; }), []);
    };
    /**
     * Adds and renders a ValidationError.
     */
    ValidationController.prototype.addError = function (message, object, propertyName) {
        var error = new validation_error_1.ValidationError({}, message, object, propertyName);
        this.processErrorDelta('validate', [], [error]);
        return error;
    };
    /**
     * Removes and unrenders a ValidationError.
     */
    ValidationController.prototype.removeError = function (error) {
        if (this.errors.indexOf(error) !== -1) {
            this.processErrorDelta('reset', [error], []);
        }
    };
    /**
     * Adds a renderer.
     * @param renderer The renderer.
     */
    ValidationController.prototype.addRenderer = function (renderer) {
        var _this = this;
        this.renderers.push(renderer);
        renderer.render({
            kind: 'validate',
            render: this.errors.map(function (error) { return ({ error: error, elements: _this.elements.get(error) }); }),
            unrender: []
        });
    };
    /**
     * Removes a renderer.
     * @param renderer The renderer.
     */
    ValidationController.prototype.removeRenderer = function (renderer) {
        var _this = this;
        this.renderers.splice(this.renderers.indexOf(renderer), 1);
        renderer.render({
            kind: 'reset',
            render: [],
            unrender: this.errors.map(function (error) { return ({ error: error, elements: _this.elements.get(error) }); })
        });
    };
    /**
     * Registers a binding with the controller.
     * @param binding The binding instance.
     * @param target The DOM element.
     * @param rules (optional) rules associated with the binding. Validator implementation specific.
     */
    ValidationController.prototype.registerBinding = function (binding, target, rules) {
        this.bindings.set(binding, { target: target, rules: rules });
    };
    /**
     * Unregisters a binding with the controller.
     * @param binding The binding instance.
     */
    ValidationController.prototype.unregisterBinding = function (binding) {
        this.resetBinding(binding);
        this.bindings.delete(binding);
    };
    /**
     * Interprets the instruction and returns a predicate that will identify
     * relevant errors in the list of rendered errors.
     */
    ValidationController.prototype.getInstructionPredicate = function (instruction) {
        if (instruction) {
            var object_1 = instruction.object, propertyName_1 = instruction.propertyName, rules_1 = instruction.rules;
            var predicate_1;
            if (instruction.propertyName) {
                predicate_1 = function (x) { return x.object === object_1 && x.propertyName === propertyName_1; };
            }
            else {
                predicate_1 = function (x) { return x.object === object_1; };
            }
            // todo: move to Validator interface:
            if (rules_1 && rules_1.indexOf) {
                return function (x) { return predicate_1(x) && rules_1.indexOf(x.rule) !== -1; };
            }
            return predicate_1;
        }
        else {
            return function () { return true; };
        }
    };
    /**
     * Validates and renders errors.
     * @param instruction Optional. Instructions on what to validate. If undefined, all objects and bindings will be validated.
     */
    ValidationController.prototype.validate = function (instruction) {
        var _this = this;
        // Get a function that will process the validation instruction.
        var execute;
        if (instruction) {
            var object_2 = instruction.object, propertyName_2 = instruction.propertyName, rules_2 = instruction.rules;
            // if rules were not specified, check the object map.
            rules_2 = rules_2 || this.objects.get(object_2);
            // property specified?
            if (instruction.propertyName === undefined) {
                // validate the specified object.
                execute = function () { return _this.validator.validateObject(object_2, rules_2); };
            }
            else {
                // validate the specified property.
                execute = function () { return _this.validator.validateProperty(object_2, propertyName_2, rules_2); };
            }
        }
        else {
            // validate all objects and bindings.
            execute = function () {
                var promises = [];
                for (var _i = 0, _a = Array.from(_this.objects); _i < _a.length; _i++) {
                    var _b = _a[_i], object = _b[0], rules = _b[1];
                    promises.push(_this.validator.validateObject(object, rules));
                }
                for (var _c = 0, _d = Array.from(_this.bindings); _c < _d.length; _c++) {
                    var _e = _d[_c], binding = _e[0], rules = _e[1].rules;
                    var _f = property_info_1.getPropertyInfo(binding.sourceExpression, binding.source), object = _f.object, propertyName = _f.propertyName;
                    if (_this.objects.has(object)) {
                        continue;
                    }
                    promises.push(_this.validator.validateProperty(object, propertyName, rules));
                }
                return Promise.all(promises).then(function (errorSets) { return errorSets.reduce(function (a, b) { return a.concat(b); }, []); });
            };
        }
        // Wait for any existing validation to finish, execute the instruction, render the errors.
        this.validating = true;
        var result = this.finishValidating
            .then(execute)
            .then(function (newErrors) {
            var predicate = _this.getInstructionPredicate(instruction);
            var oldErrors = _this.errors.filter(predicate);
            _this.processErrorDelta('validate', oldErrors, newErrors);
            if (result === _this.finishValidating) {
                _this.validating = false;
            }
            return newErrors;
        })
            .catch(function (error) {
            // recover, to enable subsequent calls to validate()
            _this.validating = false;
            _this.finishValidating = Promise.resolve();
            return Promise.reject(error);
        });
        this.finishValidating = result;
        return result;
    };
    /**
     * Resets any rendered errors (unrenders).
     * @param instruction Optional. Instructions on what to reset. If unspecified all rendered errors will be unrendered.
     */
    ValidationController.prototype.reset = function (instruction) {
        var predicate = this.getInstructionPredicate(instruction);
        var oldErrors = this.errors.filter(predicate);
        this.processErrorDelta('reset', oldErrors, []);
    };
    /**
     * Gets the elements associated with an object and propertyName (if any).
     */
    ValidationController.prototype.getAssociatedElements = function (_a) {
        var object = _a.object, propertyName = _a.propertyName;
        var elements = [];
        for (var _i = 0, _b = Array.from(this.bindings); _i < _b.length; _i++) {
            var _c = _b[_i], binding = _c[0], target = _c[1].target;
            var _d = property_info_1.getPropertyInfo(binding.sourceExpression, binding.source), o = _d.object, p = _d.propertyName;
            if (o === object && p === propertyName) {
                elements.push(target);
            }
        }
        return elements;
    };
    ValidationController.prototype.processErrorDelta = function (kind, oldErrors, newErrors) {
        // prepare the instruction.
        var instruction = {
            kind: kind,
            render: [],
            unrender: []
        };
        // create a shallow copy of newErrors so we can mutate it without causing side-effects.
        newErrors = newErrors.slice(0);
        // create unrender instructions from the old errors.
        var _loop_1 = function(oldError) {
            // get the elements associated with the old error.
            var elements = this_1.elements.get(oldError);
            // remove the old error from the element map.
            this_1.elements.delete(oldError);
            // create the unrender instruction.
            instruction.unrender.push({ error: oldError, elements: elements });
            // determine if there's a corresponding new error for the old error we are unrendering.
            var newErrorIndex = newErrors.findIndex(function (x) { return x.rule === oldError.rule && x.object === oldError.object && x.propertyName === oldError.propertyName; });
            if (newErrorIndex === -1) {
                // no corresponding new error... simple remove.
                this_1.errors.splice(this_1.errors.indexOf(oldError), 1);
            }
            else {
                // there is a corresponding new error...        
                var newError = newErrors.splice(newErrorIndex, 1)[0];
                // get the elements that are associated with the new error.
                var elements_1 = this_1.getAssociatedElements(newError);
                this_1.elements.set(newError, elements_1);
                // create a render instruction for the new error.
                instruction.render.push({ error: newError, elements: elements_1 });
                // do an in-place replacement of the old error with the new error.
                // this ensures any repeats bound to this.errors will not thrash.
                this_1.errors.splice(this_1.errors.indexOf(oldError), 1, newError);
            }
        };
        var this_1 = this;
        for (var _i = 0, oldErrors_1 = oldErrors; _i < oldErrors_1.length; _i++) {
            var oldError = oldErrors_1[_i];
            _loop_1(oldError);
        }
        // create render instructions from the remaining new errors.
        for (var _a = 0, newErrors_1 = newErrors; _a < newErrors_1.length; _a++) {
            var error = newErrors_1[_a];
            var elements = this.getAssociatedElements(error);
            instruction.render.push({ error: error, elements: elements });
            this.elements.set(error, elements);
            this.errors.push(error);
        }
        // render.
        for (var _b = 0, _c = this.renderers; _b < _c.length; _b++) {
            var renderer = _c[_b];
            renderer.render(instruction);
        }
    };
    /**
    * Validates the property associated with a binding.
    */
    ValidationController.prototype.validateBinding = function (binding) {
        if (!binding.isBound) {
            return;
        }
        var _a = property_info_1.getPropertyInfo(binding.sourceExpression, binding.source), object = _a.object, propertyName = _a.propertyName;
        var registeredBinding = this.bindings.get(binding);
        var rules = registeredBinding ? registeredBinding.rules : undefined;
        this.validate({ object: object, propertyName: propertyName, rules: rules });
    };
    /**
    * Resets the errors for a property associated with a binding.
    */
    ValidationController.prototype.resetBinding = function (binding) {
        var _a = property_info_1.getPropertyInfo(binding.sourceExpression, binding.source), object = _a.object, propertyName = _a.propertyName;
        this.reset({ object: object, propertyName: propertyName });
    };
    ValidationController.inject = [validator_1.Validator];
    return ValidationController;
}());
exports.ValidationController = ValidationController;



//////////////////
// WEBPACK FOOTER
// ./~/aurelia-validation/dist/commonjs/validation-controller.js
// module id = 75
// module chunks = 1