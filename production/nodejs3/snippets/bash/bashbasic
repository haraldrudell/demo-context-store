#! /bin/bash
# bashbasic
# Elementary bash knowledge
# Â© 2013 Harald Rudell <harald.rudell@therudells.com> (http://haraldrudell.com) All rights reserved.

# Bash reference: http://www.gnu.org/software/bash/manual/bashref.html
# # Comments 3.1.3: http://www.gnu.org/software/bash/manual/bashref.html#Comments
# #! shebang 3.8: http://www.gnu.org/software/bash/manual/bashref.html#Shell-Scripts
# LINENO 5.2: http://www.gnu.org/software/bash/manual/bashref.html#Bash-Variables
# Exit status 3.7.5: http://www.gnu.org/software/bash/manual/bashref.html#Exit-Status
# $?
# $(...) command substitution 3.5.4: http://www.gnu.org/software/bash/manual/bashref.html#Command-Substitution
# set -eu 4.3.1: http://www.gnu.org/software/bash/manual/bashref.html#The-Set-Builtin
# &&, || Command lists 3.2.3: http://www.gnu.org/software/bash/manual/bashref.html#Lists
# if ...; then ...; else ...; fi 3.2.4.2: http://www.gnu.org/software/bash/manual/bashref.html#Conditional-Constructs
# [ ... ]

echo; echo; echo "=== $(basename $0) $(date --rfc-3339=s)"
LINENO= # avoid termination for sh: sh does not define LINENO

echo "- bash is described at http://www.gnu.org/software/bash/manual/bashref.html"
echo "- #! /bin/bash on the first line tells bash how to execute the script"
echo "- The comment symbol # means comment until end of line"
echo "- LINENO contains the current script line, basename $0 contains script filename"
# LINENO: "8" basename $0: "bashbasic"
echo "- LINENO: \"$LINENO\" basename \$0: \"$(basename $0)\""

echo; echo "- Exit status is a number between 0 and 255. zero is success, non-zero is failure"
echo "- The variable \$? contains the status code for the last executed command"
# 15: $?: "0"
echo "$LINENO: \$?: \"$?\""
echo "- Command not found status is 127. An error is printed to stderr."
# ./snippets/bash/bashbasic: line 18: unknowncommand: command not found
# 18: $?: "127"
echo "$LINENO: $(unknowncommand)\$?: \"$?\""
echo "- The true and false commands uses exit codes."
# 20: true: $?: "0"
true; echo "$LINENO: true: \$?: \"$?\""
# 21: false: $?: "1"
false; echo "$LINENO: false: \$?: \"$?\""

echo; echo '- Command results are captured using the $(...) construct'
echo "- bash constructs are not effective inside, eg. \$(true && true) only executes true once"
echo "- A command has two effects: output captured by pipe or assignment and status code"
# 21: "$(echo result)": result
echo "$LINENO: \"\$(echo result)\": $(echo result)"

set -eu
echo; echo "- set -eu causes undefined shell variables and pipeline errors to exit the script with non-zero exit status"
echo "- -e does not exit shell for while until if or when followed by && || constructs"
echo "- An invocation of false, for example, will exit the shell"
echo "- Only the exits status of the final command in a pipe is examined"
# 27: "echo | grep -c x" echoes 0 and exits because grep has status code 1
echo "$LINENO: \"echo | grep -c x\" echoes 0 and exits because grep has status code 1"
echo "- Appending cat prevents grep from terminating the script"
# 31: "echo | grep -c x | cat": | grep -c x | cat $?: "0"
CMD="echo | grep -c x | cat"; echo "$LINENO: \"$CMD\": $($CMD) \$?: \"$?\""
echo "- Using and undefined variable terminates the script with staus code 1"
echo "- An error is printed like: ./snippets/bash/bashbasic: line 33: UNDEFINED: unbound variable"
#echo $UNDEFINED

echo; echo "- && and || can be used to test for exit status"
echo "- Note that bash simply skips but keeps executing with unexpected results:"
for CMD in "true || true && echo x" "true || false && echo x" "false && true || echo x" "false && false || echo x"; do
if [ "$(echo $CMD | bash)" != "" ]; then RESULT=executes; else RESULT="does not execute"; fi
# 51: "true || true && echo x": executes
# 51: "true || false && echo x": executes
# 51: "false && true || echo x": executes
# 51: "false && false || echo x": executes
echo "$LINENO: \"$CMD\": $RESULT"
done
if false; then
for A1 in true false; do
for A2 in "&&" "||"; do
for A3 in true false; do
for A4 in "&&" "||"; do
CMD="$A1 $A2 $A3 $A4 echo x"
if [ "$(echo $CMD | bash)" != "" ]; then RESULT=executes; else RESULT="does not execute"; fi
echo "$LINENO: \"$CMD\": $RESULT"
done; done; done; done
fi

echo; echo "- if provides a multi-line construct when testing exit status"
CMD="if false; then X=falseistrue; else X=falseisfalse; fi"
if false; then X=falseistrue; else X=falseisfalse; fi
# 67: "if false; then X=falseistrue; else X=falseisfalse; fi": X: falseisfalse
echo "$LINENO: \"$CMD\": X: $X"
CMD="if true; then X=trueistrue; else X=trueisfalse; fi"
if true; then X=trueistrue; else X=trueisfalse; fi
# 70: "if true; then X=trueistrue; else X=trueisfalse; fi": X: trueistrue
echo "$LINENO: \"$CMD\": X: $X"

echo; echo "- [ single bracket is the test command from the bourne shell"
echo "- It converts expressions into exit status 0 for true and 1 for false"
echo "- default is string length or -n"
echo "- unary file operators: -abcdefghkprstuwxGLNOS"
echo "- binary file operators: -ef -nt -ot"
echo "- -o shell option, -v variable, -z string is empty"
echo "- string operators: == = != < >"
echo "- integer operators: -eq -ne -lt -le -gt =ge"
# 80: "[ 1 ] && echo true || echo false": true
CMD="[ 1 ] && echo true || echo false"; echo "$LINENO: \"$CMD\": $(echo $CMD | bash)"
# 87: "[ "" ] && echo true || echo false": false
CMD="[ \"\" ] && echo true || echo false"; echo "$LINENO: \"$CMD\": $(echo $CMD | bash)"
# 89: "[ 1 -eq 1 ] && echo "89: 1 is equal to 1" || echo "89: 1 is not equal to 1"": 89: 1 is equal to 1
CMD="[ 1 -eq 1 ] && echo \"$LINENO: 1 is equal to 1\" || echo \"$LINENO: 1 is not equal to 1\""; echo "$LINENO: \"$CMD\": $(echo $CMD | bash)"

echo; echo "- Using wc for conditional execution"
# 100: "[ $(echo | wc -l) -gt 0 ] && echo executed || echo nope": executed
CMD="[ \$(echo | wc -l) -gt 0 ] && echo executed || echo nope"; echo "$LINENO: \"$CMD\": $(echo $CMD | bash)"
# 101: "[ $(echo -n | wc -l) -gt 0 ] && echo executed || echo nope": nope
CMD="[ \$(echo -n | wc -l) -gt 0 ] && echo executed || echo nope"; echo "$LINENO: \"$CMD\": $(echo $CMD | bash)"

echo; echo "$LINENO: end of $(basename $0)"
