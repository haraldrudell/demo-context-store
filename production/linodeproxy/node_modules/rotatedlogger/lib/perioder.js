// perioder.js
// Invoke a function on a certain schedule
// Â© 2013 Harald Rudell <harald.rudell@therudells.com> (http://haraldrudell.com) MIT License

var anytimer = require('./anytimer')
var linearcalendar = require('./linearcalendar')
// http://nodejs.org/api/util.html
var util = require('util')
// http://nodejs.org/api/events.html
var events = require('events')

exports.TimeEmitter = TimeEmitter

var time1s = 1e3
var time1min = 60 * time1s
var time1h = 60 * time1min
var time1day = 24 * time1h
/*
key: string schedule name
value: object
.interval optional timevalue for fixed interval
.atUnit timeval for unit of at

based on utc
*/
var periods = {
	'second': { // relative to time of construction
		interval: time1s,
	},
	'minute': { // by minute of day
		interval: time1min,
		atUnit: time1s,
	},
	'hour': { // by hour of day utc
		interval: time1h,
		atUnit: time1min,
	},
	'day': {
		interval: time1day,
		atUnit: time1h,
	},
	'month': {
		atUnit: time1day,
		atBaseOne: true
	},
	'year': { // at unit is month
		atBaseOne: true
	},
}
for (var periodName in periods) periods[periodName].schedule = periodName // add self-named schedule property

/*
Emit 'time' events on a schedule
opts: object
.schedule: optional string, default: 'month'
.at optional number default 0: offset within the period, unit depends on the selected schedule
- day and month at-units are 1-based, ie. day 1 begins the month
.every optional number, default 1: how many periods between each event

Note that JavaScript timers do not fire accurately, assume at least 1 s inaccuracy

events
'time' number: 1..
*/
function TimeEmitter(opts, stream) {
	var self = this
	events.EventEmitter.call(this)
	this.cancel = cancel
	this.getState = getState
	var nextFireTimeval // valid if nextFireIsTimeout is true
	var nextFireIsTimeout
	var anyTimer
	var fires = 0
	var lastRigTimer
	var firstRigTimer

	parseOpts()
	rigTimer()

	function cancel() {
		if (anyTimer) {
			var t = anyTimer
			anyTimer = null
			t.clear()
		}
	}
	function getState() {
		var result = {
			first: firstRigTimer,
			last: lastRigTimer,
			count: fires,
			timeout: nextFireIsTimeout,
			timeval: nextFireTimeval,
			timer: !!anyTimer,
		}
		for (var p in opts) result[p] = opts[p]
		return result
	}
	function fire() {
		if (nextFireIsTimeout) rigTimer()
		self.emit('time', ++fires)
	}

	/*
	Schedule the next setTimeout or setInterval
	premise: setInterval has not been invoked
	*/
	function rigTimer() {
		var now = lastRigTimer = Date.now()
		if (!firstRigTimer) firstRigTimer = lastRigTimer
		var lastFireTime = nextFireTimeval || now
		var timerPeriod
		var isInterval

		switch (opts.schedule) { // isInterval true: timerPeriod, otherwise nextFireTimeval
		case 'second': // fixed period: every opts.every seconds since launch
			isInterval = true
			timerPeriod = opts.every * opts.interval
			break
		case 'minute': // first period onto epoch-based schedule, then every opts.every minutes
		case 'hour': // first period onto epoch-based schedule, then opts.every hours
		case 'day': // first period onto epoch-based schedule, then then opts.every days
			timerPeriod = opts.every * opts.interval // the time between two invocations
			/*
			first invocation: nextFireIsTimeout undefined -> isInterval false
			second invocation: nextFireIsTimeout true -> isInterval true
			*/
			if (!(isInterval = !!nextFireIsTimeout)) { // it's the first period
				var inPeriod = lastFireTime % timerPeriod // time elapsed in current epoch-based period
				var atTime = opts.at * opts.atUnit % timerPeriod // at time within period
				var timeLeft = atTime - inPeriod // time left to the next at time in this period
				if (timeLeft <= 0) timeLeft += timerPeriod // it's passed, go to the next period
				nextFireTimeval = lastFireTime + timeLeft
			}
			break
		case 'month': // periods of varying length
			useLinearCalendar(linearcalendar.encodeMonths(opts.every), null, opts.at * opts.atUnit)
			break
		case 'year': // always setTimeout
			useLinearCalendar(linearcalendar.encodeYears(opts.every), linearcalendar.encodeMonths(opts.at))
			break
		}

		// rig the timer
		if ((nextFireIsTimeout = !isInterval) && (timerPeriod = nextFireTimeval - now) < 0) timerPeriod = 0
		anyTimer = new anytimer.AnyTimer(fire, timerPeriod, isInterval)

		/*
		ymPeriod: opts.every encoded using linear calendar
		exactly one of ymAt or atTimeval is null
		ymAt: opts.at month encoded using linear calendar
		atTimeval: opts.at day * opts.atUnit
		*/
		function useLinearCalendar(ymPeriod, ymAt, atTimeval) {

			// calculate the at time for the current period (0) and the next period (1)
			var ymNow = linearcalendar.encodeDate(new Date(lastFireTime))
			var ymPeriodStart = ymNow - ymNow % ymPeriod
			var periodStarts = []
			var periodAts = []
			var periodStart
			for (var i = 0; i < 3; i++) {
				periodStarts.push(periodStart = linearcalendar.getTimeval(ymPeriodStart))
				if (i < 2) {
					periodAts.push(ymAt != null ?
						linearcalendar.getTimeval(ymPeriodStart + ymAt) :
						periodStart + atTimeval)
					ymPeriodStart += ymPeriod
				}
			}
			periodAts.forEach(ensureInPeriod)

			nextFireTimeval = lastFireTime < periodAts[0] ? periodAts[0] : periodAts[1]

			function ensureInPeriod(value, index) {
				if (value > periodStarts[index + 1]) periodAts[index] = periodStarts[index + 1]
			}
		}
	}

	/*
	Interpret options object
	opts is set to: object
	.schedule: string: schedule name from periods
	.interval
	.atUnit
	.atBaseOne
	.at: number >= 0
	.every number > 0
	*/
	function parseOpts() {
		if (!opts) opts = {}
		var result = {}
		var period = periods[opts.schedule || 'month'] || periods.month // value from periods, default month

		for (var p in period) result[p] = period[p]
		result.at = opts.at > 0 ? +opts.at : 0 // number >= 0
		if (result.atBaseOne && --result.at < 0) result.at = 0 // number >= 0
		result.every = opts.every > 0 ? +opts.every : 1 // number >= 0
		opts = result
	}
}
util.inherits(TimeEmitter, events.EventEmitter)
