// rotatedstream.js
// Tee output to a log that is rotated
// Â© 2013 Harald Rudell <harald.rudell@therudells.com> (http://haraldrudell.com) MIT License

var perioder = require('./perioder')
var gettype = require('./gettype')
var gettmpfolder = require('./gettmpfolder')
// http://nodejs.org/api/path.html
var path = require('path')
// http://nodejs.org/docs/latest/api/fs.html
var fs = require('fs')
// http://nodejs.org/api/stream.html
var streamModule = require('stream')
// http://nodejs.org/api/util.html
var util = require('util')

exports.RotatedStream = RotatedStream

var time2s = 2e3

var rotateAttemptWait = time2s
var maxRetry = 10
var defaults = {
	flags: { // options for fs.createWriteStream
		flags: 'a',
		encoding: 'utf-8',
		mode: 0660, // rw- rw- ---
	},
	logFile: 'applog', // default log file basename
	logSubfolder: 'log', // subfolder searched for in user's home folder, null to use path of logFile
	logFileExt: '.log',
	logSize: 1024 * 1024, // number max size of log file
	rotating: {
		schedule: 'month',
		at: 0,
		every: 1,
	},
}

/*
Write to a rotated file
opts: optional object
.flags: optional object: options for fs.createWriteStream
.logFile: optional string default 'applog': log file name
.logSubfolder: optional string, default 'log': subfolder searched for in user's home folder, use '' to disable
.logFileExt: optional string default '.log',
.logSize: optional number, default 1Mi, unit characters: size when log file rotated, 0 for none
.rotating: optional object, default monthly: scheduling for perioder

events
'error' err: a rotate will restart the rotated stream even after error
'close'
'drain'

- does not throw exceptions
- rotate() restarts the stream, even from error state
*/
function RotatedStream(opts) {
	var self = this
	streamModule.Stream.call(this)
	this.writable
	this.write = write
	this.end = end
	this.destroy = destroy
	this.rotate = rotate
	var stream
	var maxBytesWritten
	var periodTimer
	var didWrite
	var buffer
	var pendingStream = 0
	var isFinal
	var rotating

	parseOpts()
	openStream(true)

	function openStream(emitErrors) { // return value: err or undefined
		var err
		try {
			stream = fs.createWriteStream(opts.absoluteFilename, opts.flags)
				.on('error', emitFinal)
			if (opts.logSize) {
				maxBytesWritten = opts.logSize
				stream.once('open', checkSize)
			}
			if (!periodTimer) periodTimer = new perioder.TimeEmitter(opts.rotating, process.stdout)
				.on('time', rotate)
			isFinal = false
		} catch (e) {console.log(e.stack)
			err = e
			if (emitErrors) process.nextTick(getEmitErrorFn(e))
		}
		self.writable = !err

		return err
	}

	/*
	Write string or buffer
	str: string or buffer
	cb(err): optional function
	*/
	function write() {
		var args = Array.prototype.slice.call(arguments)
		var cb = typeof args[args.length - 1] === 'function' ? args.pop() : null

		var didCb
		var err
		if (self.writable) {
			didWrite = true
			if (buffer) buffer.push(str)
			else if (stream && stream.writable) {
				didCb = true
				pendingStream++
				stream.write.apply(stream, args.concat(writeComplete))
				if (stream && stream.bytesWritten > maxBytesWritten) rotate()
			} else {
				self.writable = false
				err = new Error('Stream not writable')
			}
		} else err = new Error('Stream unavailable')
		if (!didCb) writeComplete(err)

		function writeComplete(e) {
			pendingStream--
			if (e) emitFinal(e)
			else if (!e && !pendingStream) self.emit('drain')
			if (cb) cb(e)
		}
	}

	/*
	Close the stream when all writes are complete
	data: optional item: data to write
	cb(err): optional function
	return value: none
	*/
	function end() {
		var args = Array.prototype.slice.call(arguments)
		var cb = typeof args[args.length - 1] === 'function' ? args.pop() : null
		if (stream) stream.end.apply(stream, args.concat(endComplete))
		else endComplete()

		function endComplete(e) {
			emitFinal(e)
			shutdown()
			if (cb) cb(e)
		}
	}

	/*
	Release resources held by the write stream
	cb(err): optional function
	return value: none
	*/
	function destroy(cb) {
		if (stream) stream.destroy(destroyComplete)
		else destroyComplete()

		function destroyComplete(e) {
			emitFinal(e)
			shutdown()
			if (cb) cb(e)
		}
	}

	// rotate the log, cb(err): optional function
	function rotate(cb) {
		var retryCount
		var newName
		if (typeof cb !== 'function') cb = null

		if (self.writable && didWrite && !rotating) { // we wrote something to the log, and are not in process of rotating
			rotating = true
			retryCount = 0
			newName = getRotatedFilename()
			fs.stat(newName, doesNewNameExist) // see if the new filename already exist
		} else {
			var err
			if (!stream && !rotating) err = openStream()
			endRotate(err)
		}

		function doesNewNameExist(err, stat) {
			if (err instanceof Error && err.code === 'ENOENT') { // we can use newName!
				buffer = [] // start logging to memory instead of the stream
				end('Log rotated to: ' + path.basename(newName) + '\n', renameLog)
			} else {
				if (!err) { // newFile already exists
					if (++retryCount < maxRetry) setTimeout(retryRotate, rotateAttemptWait)
					else exitRotate(new Error('Renamed logfile exists'))
				} else exitRotate(err) // some other error
			}
		}

		function retryRotate() {
			//** stream.write('retry')
			if (self.writable) {
				newName = getRotatedFilename()
				fs.stat(newName, doesNewNameExist) // see if the new filename already exist
			} else exitRotate()
		}

		function renameLog(err) { // we are in buffer mode, closed  stream
			if (!err) fs.rename(opts.absoluteFilename, newName, createWriteStream)
			else exitRotate(err)
		}

		function createWriteStream(err) {
			if (!err &&
				!(err = openStream())) stream.write('Continued from: ' + newName + '\n')
			exitRotate(err)
		}

		function exitRotate(err) {
			if (!err)
				while (stream && buffer.length && self.writable)
					stream.write(buffer.shift())
			buffer = null
			rotating = false
			endRotate(err)
		}

		function endRotate(err) {
			if (!err) {
				if (cb) cb()
			} else {
				emitFinal(err)
				if (cb) cb(err)
			}
		}
	}

	function emitFinal(err) {
		self.writable = false
		if (stream) {
			stream.removeListener('error', emitFinal)
			.on('error', reemitError)
		}
		stream = null
		if (!err) {
			if (!isFinal) self.emit('close')
		} else self.emit('error', err)
		isFinal = true
		return err
	}

	function reemitError(e) {
		self.emit('error', e)
	}

	function shutdown() {
		if (periodTimer) {
			var p = periodTimer
			periodTimer = null
			p.cancel()
			p.removeListener('time', rotate)
		}
	}

	function parseOpts() {
		if (!opts) opts = {}
		var result = {}

		var resArgs = []
		if (opts.logSubfolder !== '') {
			var logFolder = path.resolve(gettmpfolder.getHomeFolder(), opts.logSubfolder || defaults.logSubfolder)
			if (gettype.getType(logFolder) === 1) resArgs.push(logFolder)
		}
		resArgs.push(opts.logFile ? String(opts.logFile) : defaults.logFile) // non-empty string
		result.absoluteFilename = path.resolve.apply(path, resArgs)
		if (!path.extname(result.absoluteFilename)) result.absoluteFilename += opts.logFileExt || defaults.logFileExt

		result.flags = typeof opts.flags === 'object' ? opts.flags : defaults.flags

		result.rotating = typeof opts.rotating === 'object' ? opts.rotating : defaults.rotating

		result.logSize = opts.logSize >= 0 ? +opts.logSize : defaults.logSize // number >= 0

		opts = result
	}

	function checkSize(fd) {
		fs.fstat(fd, parseStat)
	}

	function parseStat(err, stat) {
		if (!err) maxBytesWritten -= stat.size
		else emitError(err)
	}

	function getRotatedFilename() {
		var extLength = path.extname(opts.absoluteFilename).length // a.log -> 4 '.log'
		var marker = (new Date).toISOString() // 2013-01-07T10:00:00.005Z

		return [ // file_20130107_100000.ext
			opts.absoluteFilename.slice(0, -extLength), '_',
			marker.substring(0, 4), marker.substring(5, 7), marker.substring(8, 10), '_',
			marker.substring(11, 13), marker.substring(14, 16), marker.substring(17, 19),
			opts.absoluteFilename.slice(-extLength),
			].join('')
	}

	function getEmitErrorFn(e) {
		return emitError

		function emitError() {
			emitFinal(e)
		}
	}
}
util.inherits(RotatedStream, streamModule.Stream)
