{
  "name": "apprunner",
  "description": "Manage application errors and plugin modules by Harald Rudell",
  "author": {
    "name": "Harald Rudell",
    "email": "harald@allgoodapps.com",
    "url": "http://www.haraldrudell.com"
  },
  "keywords": [
    "require",
    "plugins",
    "api",
    "npm",
    "errors",
    "email",
    "management",
    "lifecycle",
    "app"
  ],
  "version": "0.2.11",
  "contributors": [
    {
      "name": "Harald Rudell",
      "email": "harald@allgoodapps.com",
      "url": "http://www.haraldrudell.com"
    }
  ],
  "devDependencies": {
    "grunt-contrib-watch": ">= 0.1.4",
    "grunts": ">= 0.0.2",
    "grunt": ">= 0.4.0rc7",
    "mochawrapper": ">= 0.0.34"
  },
  "dependencies": {
    "haraldutil": ">= 0.1.18"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/haraldrudell/apprunner"
  },
  "main": "./lib/apprunner",
  "scripts": {
    "test": "mocha --ui exports --reporter spec",
    "monitor": "mocha --ui exports --reporter min --watch",
    "debugtest": "mocha --debug-brk --ui exports --reporter spec",
    "coverage": "mochacoverage",
    "changelog": "git log --format=\"%ad %s\" --date=short >ChangeLog; ls -l ChangeLog"
  },
  "readme": "# App Runner\n\nApp Runner manages app lifecycle\n\n## Benefits\n\n* Flexible module loading provide choice of implementation with no code change\n* Api lifecycle allows module spin-up/shutdown and settings from file data.\n* Easier troubleshooting with emailed anomaly reports\n* Orderly shutdown on exception and signal avoids data loss\n\n## Features\n\n1. Self-contained email forwarding and anomaly detection/reporting\n2. require replacement\n3. api module support with api names, error emiters, request timers, across-api function, settings mix-in and ready watchers\n4. Separation between web server implementation and app code\n5. Configurable handlers for SIGINT SIGURS2, uncaught exception\n\n# Function Reference\n\n## initApp(defaults)\nInitialize apprunner\n```js\nrequire('apprunner').initApp(require('haraldops').init({\n\tappName: 'Node God',\n\tapi: {\n\t\tapiMap: {\n\t\t\tnodegodweb: {\n\t\t\t\tonLoad: true,\n\t\t\t\tsessionSecret: 'veryGreat',\n\t\t\t\tPORT: 1111,\n\t\t\t}\n\t\t}\n\t}\n}))\n```\n* defaults: options, typically loaded by haraldops\n\n\t* .init.noInfoLog: boolean: no logging by appInit\n\t* .anomaly: object for anomalysettings of false for disable\n\n## getAppData(appInfo)\nRetrieve key app data\n```js\nconsole.log(require('apprunner').getAppData())\n```\n```\n{\n\tappName: 'Cloud Clearing',\n\tappId: 'cloudclearing',\n\tlaunchFolder: '/home/foxyboy/Desktop/c505/node/cloudclearing',\n\tsendMail: [Function: send],\n\tlogger: [Function],\n\tregisterHandler: [Function: registerHandler],\n\tviews: { dbview: { db: [Object] } },\n\tdefaultsFile: '/home/foxyboy/apps/cloudclearing.json'\n}\n```\n* appInfo: optional object PORT:numer, URL: string\nForwarded on signal to [Node God](https://github.com/haraldrudell/nodegod)\n\n## getRequire(require, exports, opts)\n\nProvides a require with a flexible search for modules\n```\nrequire = require('apprunner').getRequire(require)\nrequire('myaliasedmodule')\n```\n\nRegisters an api with apprunner, providing emitter, rqs object and initApi wrapper\n```\nrequire = require('apprunner').getRequire(require, exports, {\n\tapi: 'FB Friends', initApi: initApi, endApi: endApi,\n\trqScope: true, timeoutMs: time10s, ready: false})\n```\n* options\n\t* .api: optional string: unique api name eg. 'Server Helper'\n\t* .emScope if emitter, this emitter will be used. id property will be updated\n\t* .emScope if string: scope for emitter\n\t* .initApi: optional function: the internal initApi implementation\n\t* .rqScope: optional string or boolen, string slogan for request timer, true if using api name\n\t* .cb(err): optional function: rqs error callback\n\t* .timeoutMs: number ms: default rqs timeout if not 3 seconds\n\t* .ready: positive number: timeout for ready in ms\n\t* .ready false: this api does not emit ready\n\t* .ready defaults: ready with timeout 3 s\n\t* .saveApi: optional function\n\t* .endApi: optional function\n\t* .apiState: optional function\n\n1. An emitter will be created if emScope or apiName is non-zero string at require.emitter\n2. A request timer will be provided if rqScope is true or non-zero string at require.rqs\n3. The api will be managed if there is a non-zero api name. emitter and initApi are required. api name at require.emitter.id\n\n## apisReady(cb)\n\nSurveys all apis with singleton ready to see if they have concluded initializing.\n\n## anomaly(...)\n\nReport any argument as an anomaly, to the log and possibly via email\n```js\nrequire('apprunner').anomaly(err, {location: 'kitchen', user: 'fail'}, err2)\n```\n\n## enableAnomalyMail(flag)\ncontrol emailing of anomaly reports.\n```js\nrequire('apprunner').enableAnomalyMail('1/1/2013')\n```\n* flag either a date string or boolean flag, default: false\n\nAnomaly reports are not sent until the day after the date provided.\n\n## addErrorListener(emitter)\n\nAdds an error listener to the EventEmitter.\n\nSafe: can be invoked with any value, or repeatedly invoked.\n\n## removeErrorListener(emitter)\n\nRemoves an error listener to the EventEmitter.\n\nSafe: can be invoked with any value, or repeatedly invoked.\n\n## shutdown(exitCode)\n\nShuts the application down. All apis that have exposed an saveApi or endApi gets these functions invoked prior to process.exit\n\nApp Runner handles process exceptions and SIGINT (ie. ctrl-Break.)\n* Exit code 0 is SIGINT\n* Exit code 2 is unhandled exception\n\n## addUriHandler(fn)\n\nProvides a function for a Web server instance that registers incoming uri and handlers\n```js\nvar apprunner = require('apprunner')\nvar express = require('express')\n\nvar app = apprunner.addErrorListener(express())\napprunner.addUriHandler(app.get.bind(app))\n```\n* fn(uri, uriHandler): function, uri: string, uriHandler: function\n\n## getRqs(errorCallback, scopeName, defaultTimeoutMs)\n\nGet a timer factory\n```js\nvar rqs = require('apprunner').getRqs(timeoutFn, 'UserStore Timers', 1000)\n\nvar timer = rqs.addRq('Getting Token')\nuserStore.getUser(fbId, saveOauthToken)\n\nfunction saveOauthToken(err, user) {\n\ttimer.clear()\n\t...\n}\n\nfunction timeoutFn(err) {\n\tconsole.log('an anomaly was reported for a timed out request')\n\t// maybe take alternative action\n\tif (err.isTimer) {\n\t\tif (err.param === 'Getting Token') ...\n\t}\n}\n```\n* errorCallback(err): function: invoked with err for timeouts and inconsitencies\n* scopeName: optional string or object: scope name for this factory eg. 'sync Db'\n* defaultTimeoutMs: optional number: default timeout in ms, min 100,  default 3 s\n\n1. rqs.addRq(parameter, time)\n2. rqs.clearRq(parameter) : same as .clear\n3. rqs.getState()\n4. rqs.shutdown()\n\n# Apis\n\nAn api must be loaded using these two things:\n\n1. Being loaded using require from getRequire\n2. Provide its initApi function and api name to getRequire\n\n## What's the Difference Between an Api and a Module?\n\n1. An singleton api or api instances returned by initApi can be required to emit ready\n2. An api's initApi is provided options that is json-configured options overriden by invocation options\n3. An api can have onLoad: true\n4. An api has a sigleton emitter at require.emitter\n5. An api has a module name like all modules but also an api name at require.emitter.id\n6. An api can export the special endApi, saveApi and apiState functions\n7. An api can get a timer factory at require.rqs\n\n<h2>What code should be an Api?</h2>\n<p>What source files should be designed as an api?</p>\n<ol>\n\t<li>Modules that are shared across multiple apps or apis without being an npm package.</li>\n\t<li>modules with specific needs:<ol>\n\t\t<li>Instance matching</li>\n\t\t<li>Managed lifecycle due to timers, open ports to or tcp connections</li>\n\t\t<li>Singleton ready to delay app start</li>\n\t\t<li>Configuration information like urls or passwords</li>\n\t\t<li>Diagnostic error emitting</li>\n\t\t<li>Provide ops information</li>\n\t\t<li>Start using onLoad</li>\n\t</ol>\n</ol>\n\n## Loading an Api\nSingleton\n```js\nrequire = require('apprunner').getRequire(require)\nrequire('serverhelp').listen()\nrequire('mongo').once('ready', mongoReady)\n```\nInstance\n```js\nrequire = require('apprunner').getRequire(require)\nvar fb = require('fb')\nfb.initApi({user: userId}).once('ready', fbReady)\n```\n\n## Writing an Api\nSingleton\n```js\nrequire = require('apprunner').getRequire(require, exports, {\n\tapi: 'MongoD', initApi: initApi, endApi: endApi,\n\trqScope: true, ready: false})\nfunction someExport(...) ...\n```\nInstance\n```\nrequire = require('apprunner').getRequire(require, exports, {\n\tapi: 'User Store', initApi: initApi,\n\t})\nfunction initApi(opts) {\n\t...\n\tvar readyState\n\tdoSome(someCb)\n\tfunction someCb(err, data) {\n\t\treadyState = err || true\n\t\tvar eArgs = ['ready']\n\t\tif (err) eArgs.push(err)\n\t\te.emit.apply(e, eArgs)\n\t}\n\tvar e = new events.EventEmitter\n\te.isReady = isReady\n\treturn e\n\tfunction isReady() {\n\t\treturn readyState\n}\n}\n```\n## Api settings\nApi settings are provided in the defaults object for appInit()\n```js\n{\n\t\t\"api\": {\n\t\t\"path\": [\n\t\t\t{\n\t\t\t\t\"folder\": \"lib\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"file\": \"applego\"\n\t\t\t}\n\t\t],\n\t\t\"apiMap\": {\n\t\t\t\"expressapi\": {\n\t\t\t\t\"onLoad\": true,\n\t\t\t\t\"sessionSecret\": \"secrets\",\n\t\t\t\t\"port\": 3003\n\t\t\t},\n}\n```\n* path: optional array of locations\n* apiMap: optional object with api settings\n\t* each entry can have onLoad, folder/subPath/file along with other settings\n1. A location can have folder/subPath: a string relative to the app's launch folder and a dot-separated name spacing in the loaded module\n2. A location can have  file/subpath where file is a module name and subpath is a dot-separated name spacing in the loaded module\n\n# Notes\n\n(c) [Harald Rudell](http://www.haraldrudell.com) wrote this for node in September, 2012\n\nNo warranty expressed or implied. Use at your own risk.\n\nPlease suggest better ways, new features, and possible difficulties on [github](https://github.com/haraldrudell/apprunner)",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/haraldrudell/apprunner/issues"
  },
  "_id": "apprunner@0.2.11",
  "_from": "apprunner@>= 0.2.3"
}
