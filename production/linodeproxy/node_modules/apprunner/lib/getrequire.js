// getrequire.js
// api services: require, registration, emitter, request timer factory and initApi options filter
// Â© 2012 Harald Rudell <harald.rudell@therudells.com> (http://haraldrudell.com) MIT License

/*
Provide require function instances capable of loading apis
Provide timer factory and anomaly emitter
Register api with saveApi, endApi, apiState
*/
var initapiwrapper = require('./initapiwrapper')
var apirequire = require('./apirequire')
var apilist = require('./apilist')
var rqsm = require('./rqs')
var apperror = require('./apperror')
// http://nodejs.org/api/events.html
var events = require('events')
// http://nodejs.org/api/path.html
var path = require('path')

;[
getRequire, init, getApiData, testIntercept, mixIn,
].forEach(function (f) {exports[f.name] = f})

var state = {
	apiConfigs: {}, // key: api module name, value: config object
	exportsMap: {}, // all modules loaded by apiRequire: key module name, value: exports object
	apiPath: [{folder: 'lib'}], // array of object: .file, .subPath
	testMap: null,
	deployFolder: '',
}

/*
Provide replacement require for load of api, emitter and request timer
theRequire: function: original require function
theExports: optional module exports object: used for mapping and intercepting the initApi export
opts: object
.api: optional string: unique api name eg. 'Server Helper'
.emScope if emitter, this emitter will be used. id property will be updated
.emScope if string: scope for emitter
.initApi: optional function: the internal initApi implementation
.rqScope: optional string or boolen, string slogan for request timer, true if using api name
.cb(err): optional function: rqs error callback
.timeoutMs: number ms: default rqs timeout if not 3 seconds
.ready: positive number: singleton ready timeout, unit: ms
- otherwise boolean default false: singleton ready with 3 s timeout
.instanceReady: positive number: instance ready timeout in ms
- otherwise boolean default true: instance ready with 3 s timeout
.saveApi: optional function
.endApi: optional function
.apiState: optional function

An emitter will be created if emScope or apiName is non-zero string
A request timer will be provided if rqScope is true or non-zero string
The api will be managed if there is a non-zero api name. emitter and initApi are required
*/
function getRequire(theRequire, theExports, opts) {
	var didWrap // did wrap initApi
	requireState = {}
	if (!opts) opts = {}

	// obtain replacement require
	if (typeof theRequire != 'function') throw Error(arguments.callee.name + ' invoked with require argument not function, type: ' + typeof theRequire)
	var result = apirequire.getApiRequire(state, theRequire)
	result.dirname = __dirname // absolute path can distinguish between multiple instances

	// find possible api name
	var apiName = typeof opts.api === 'string' && opts.api

	// get emitter
	if (opts.emScope instanceof events.EventEmitter && apiName) {
		result.emitter = opts.emScope
		result.emitter.id = apiName
	} else {
		var emitterId = typeof opts.emScope === 'string' && opts.emScope || apiName
		if (emitterId) {
			result.emitter = new events.EventEmitter
			result.emitter.id = emitterId
		}
	}
	apperror.addErrorListener(result.emitter)

	// wrap initApi
	if (opts.initApi) {
		if  (typeof opts.initApi != 'function') throw Error(arguments.callee.name + ' invoked with opts.initApi not function')
		if (!theExports) throw Error(arguments.callee.name + ' invoked with exports null')
		if  (!apiName) throw Error(arguments.callee.name + ' invoked with opts.initApi but no api name')
		theExports[opts.initApi.name] = initapiwrapper.getWrapper(opts.initApi, state, requireState, opts)
		didWrap = true
		if (typeof opts.apiState == 'function') theExports.apiState = opts.apiState
	}

	// if api, add it to apiList and monitor ready
	if (apiName) { // to get here, there must be an emitter
		if (!didWrap) throw new Error('InitApi missing for api: ' + apiName)
		var api = apilist.addApi(result.emitter, opts, theExports)
		if (typeof api === 'string') throw new Error(api)
		else requireState.apiObject = api
	}

	// get possible rqs
	var rqScope = opts.rqScope === true ? apiName : typeof opts.rqScope === 'string' && opts.rqScope
	if (rqScope) {
		var errorCallback = typeof opts.cb == 'function' ? opts.cb : function () {}
		var timeoutMs = opts.timeoutMs != null ? opts.timeoutMs : undefined
		// getRqs may throw
		result.rqs = rqsm.getRqs(errorCallback, rqScope, timeoutMs)
	}

	return result
}

function getApiData() {
	var result = {
		onloads: [], // api names with onLoad attribute
		apiMap: Object.keys(state.apiConfigs).length,
		apiPath: state.apiPath.length,
	}
	for (var apiName in state.apiConfigs)
		if (state.apiConfigs[apiName].onLoad)
			result.onloads.push(apiName)
	return result
}

/*
opts: object
appData: appData object to use
apiOpts: optional object, typically default.api

testOpts: otional object
*/
function init(opts) {
	if (!opts || !opts.appData) throw new Error(path.basename(__filename)+ ':' + arguments.callee.name + ': bad opts argument')

	var apiOpts = opts.apiOpts || {}
	state.apiConfigs = apiOpts.apiMap || {}
	if (Array.isArray(apiOpts.path)) state.apiPath = apiOpts.path

	state.deployFolder = opts.appData.launchFolder
}

function testIntercept(testOpts) {
	if (testOpts) {
		if (testOpts.testMap !== undefined) state.testMap = testOpts.testMap
		if (testOpts.exportsMap !== undefined) state.exportsMap = testOpts.exportsMap || {}
		if (testOpts.apperror !== undefined) apperror.testIntercept(testOpts.apperror)
		if (testOpts.useTestConfig != null) init(require('./testconfig').getTestConfig(testOpts.useTestConfig))
	}
}


/*
opts: object
key: string or exports object
return value: object
*/
function mixIn(opts, key) {
	var config
	if (typeof key !== 'string') key = getModuleName(key)
	if (typeof key === 'string' && (config = state.apiConfigs[key])) opts = haraldutil.merge(config, opts)
	else if (!opts) opts = {}

	return opts
}

function getModuleName(exportsObject) {
	var result
	for (var moduleName in state.exportsMap) {
		if (exportsObject === state.exportsMap[moduleName]) {
			result = moduleName
			break
		}
	}
	return result
}
