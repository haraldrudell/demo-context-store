// rqs.js
// provide timeout notification for callback functions
// Â© 2012 Harald Rudell <harald.rudell@therudells.com> (http://haraldrudell.com) MIT License

/*
Provide timers and a timer factory
timeouts are reported as anomalies and to a callback function
events for timed out timers are reported as anomalies, too

error properties:
isTimer: true: is an error related to timers
isTimeout: boolean if this is a timeout error
*/

var apperror = require('./apperror')
// https://github.com/haraldrudell/haraldutil
var haraldutil = require('haraldutil')
// http://nodejs.org/api/events.html
var events = require('events')

var emitter = new events.EventEmitter
emitter.id = 'Request Timer'
apperror.addErrorListener(emitter)

var time3seconds = 3e3
var time100ms = 100

var minTimer = time100ms
var defTimer = time3seconds

exports.getRqs = getRqs
exports.testGetEmitter = testGetEmitter

/*
Factory for timers
errorCallback(err): optional function: invoked with err for timeouts and inconsistencies
scopeName: optional string or object: scope name for this factory eg. 'sync Db'
defaultTimeoutMs: optional number, unit ms, defaults 3s: timer duration

Timeouts are emitted as 'error' and produce anomaly
*/
function getRqs(errorCallback, scopeName, timeoutMs) {
	var serial = 0
	var requests = {}
	var factory = {
		from: haraldutil.getLocation({offset: 1, folder: false}), // 'function: exec file: mongo.js:173:28'
	}
	factory.scope = typeof scopeName === 'string' ? scopeName : // string
			scopeName == null ? factory.from :
				haraldutil.inspect(scopeName),
	timeoutMs = isNaN(timeoutMs) || timeoutMs < minTimer ? defTimer : +timeoutMs
	if (!(typeof errorCallback === 'function')) errorCallback = null

	return {
		addRq: addRq,
		isDone: isDone,
		getState: getState,
		shutdown: shutdown,
	}

	/*
	Get a timer
	parameter: optional string or object: affecting parameter for this request, eg. url for a Web request
	time: optional number: timeout in ms for this request, min 100ms, default is the factory default, typically 3 s

	return value: a printable and identifiable string
	*/
	function addRq(parameter, time) {
		var id = String(serial++)
		var request = requests[id] = {
			created: Date.now(),
			from: haraldutil.getLocation({offset: 1, folder: false}),
			invocation: new Error(arguments.callee.name),
			timeout: isNaN(time) || time < 100 ? timeoutMs : +time,
			param: typeof parameter === 'string' ? parameter :
				parameter == null ? factory.from :
					haraldutil.inspect(parameter),
		}
		request.timer = setTimeout(timeout, request.timeout)

		return {
			id: id,
			created: request.created,
			param: request.param,
			from: request.from,
			toString: toString,
			clear: clear,
			isTimeout: isTimeout,
		}

		function timeout() { // mark this request as timed out
			request.timer = null
			makeError('Timeout for: ' + toString(), {isTimeout: true})
		}

		function isTimeout() {
			return !request.timer
		}

		/*
		mark a request as complete

		return value:
		- false: sucess: the rq was cleared before it timed out
		- number: this slogan timed out, number is ms elapsed since creation (errorCallback has already been invoked)
		*/
		function clear() {
			var result = false

			if (request.timer) { // ok: within the timeout period
				var t = request.timer
				request.timer = null
				clearTimeout(t)
				delete requests[id]
			} else { // it had already timed out
				result = Date.now() - request.created
				makeError(['After', result / 1e3, 's,',
					'the timed out request completed:', toString()].join(' '))
			}

			return result
		}

		function toString() {
			var result = ['Request',
				'created:', Date(request.created),
				'from:', request.from,
				'parameter:', '\'' + request.param + '\'']
			if (request.timeout) result.push('timeout:', request.timeout / 1e3,'s')

			return result.join(' ')
		}

		function makeError(s, extraProps) {
			var result = new Error([String(s),
				'factory:', factory.scope,
				'from:', factory.from].join(' '))
			result.isTimer = true
			result.rqs = {
				param: request.param, // string request name
				timeout: request.timeout, // number timeout in ms
				invocation: request.invocation, // stack trace for addRq invocation
				scope: factory.scope, // string factory name
				factoryFrom: factory.from, // string where getRqs was invoked from
				created: request.created, // timeval
			}
			if (extraProps) for (var p in extraProps) result[p] = extraProps[p]

			emitter.emit('error', result)
			if (errorCallback) errorCallback(result)

			return result
		}
	}

	function isDone() { // true if all requests completed
		return !Object.keys(requests).length
	}

	function shutdown() { // clear all timers
		var timer

		for (var id in requests)
			if (timer = requests[id].timer) {
				requests[id].timer = null
				clearTimeout(timer)
			}
	}

	function getState(testGetEmitter) {
		var result = {}
		for (var id in requests) result[id] = haraldutil.shallowClone(requests[id])
		return result
	}
}

function testGetEmitter() {
	return emitter
}
