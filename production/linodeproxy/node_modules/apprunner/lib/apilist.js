// apilist.js
// api services: list of apis, api ready monitoring, saveApi and endApi invocation
// Â© 2012 Harald Rudell <harald.rudell@therudells.com> (http://haraldrudell.com) MIT License

/*
Manage a list if apis registered under an api slogan
The exports object maps a registered api to its api module name and json configuration
*/
var apierror = require('./apierror')
var apitouch = require('./apitouch')
var rqsm = require('./rqs')
// http://nodejs.org/api/events.html
var events = require('events')
// https://github.com/haraldrudell/haraldutil
var haraldutil = require('haraldutil')

;[
addApi, apisReady, invokeEndApi, isEndApiFn, getState, testReset, getApiStates, getInitApiName, updatePrototype
].forEach(function (f) {exports[f.name] = f})

var time3s = 3e3
var defaultSingletonReady = time3s
var defaultInstanceReady = time3s

/*
key: api slogan eg. 'ExpressApi'
value: object
.api: api slogan
.emitter: api error emitter
.initApiName: string: function name for initApi function
.instanceReady
.isReady
.saveApi: optional function: lifecycle functions
.endApi: optional function: lifecycle functions
*/
var apiMap = {}
var apiReadyWait = []
var isEndApi
// rqsm emits timeouts as Request Timer
var rqs = rqsm.getRqs(function () {}, 'Api Ready', time3s)

/*
Add an api to the loaded apis
emitter: EventEmitter
emitter.id: string api name
emitter.noReady: boolean default false: this api does not emit ready
opts: object
.saveApi: optional function
.endApi: optional function
.apiState: optional function
.ready: positive number: singleton ready timeout, unit: ms
- otherwise boolean default false: singleton ready with 3 s timeout
.instanceReady: positive number: instance ready timeout in ms
- otherwise boolean default true: instance ready with 3 s timeout

return value: api object on success, printable string on troubles
 */
function addApi(emitter, opts, theExports) {
	if (!opts) opts = {}
	var result

	if (isEndApi) result = arguments.callee.name + ' invoked after endApi'
	else if (!(emitter instanceof events.EventEmitter)) result = 'Bad emitter'
	else if (typeof emitter.id != 'string' || !emitter.id) result = 'Emitter id property (api name) not string or blank'
	else if (typeof opts.initApi.name !== 'string') result = 'initApi name not string'
	else {
		if (apiMap[emitter.id]) result = 'Duplicate api: ' + emitter.id
		else {
			result = apiMap[emitter.id] = {api: emitter.id, emitter: emitter, initApiName: opts.initApi.name, theExports: theExports, updatePrototype: opts.updatePrototype}

			/*
			singleton ready: positive number or false
			number: accepted if positive, otherwise 3 s
			otherwise: boolean default false: if true: singleton ready 3 s otherwise no singleton ready
			*/
			var singletonReady = typeof opts.ready === 'number' ?
				!isNaN(opts.ready) && opts.ready > 0 ? +opts.ready : defaultSingletonReady :
				opts.ready ? defaultSingletonReady : false

			if (singletonReady) {
				emitter.once('ready', onReady)
				var timer = rqs.addRq(result.api, singletonReady)
			} else result.isReady = true

			result.instanceReady = typeof opts.instanceReady === 'number' ?
				(!isNaN(opts.instanceReady) && opts.instanceReady > 0 ? +opts.instanceReady : defaultInstanceReady) :
				opts.instanceReady !== false ? defaultInstanceReady : false

			if (opts && findFn('saveApi') && findFn('endApi') && findFn('apiState')) ;
		}
	}

	return result

	function findFn(fName) {
		if (opts[fName])
			if (typeof opts[fName] == 'function')
				result[fName] = opts[fName]
			else result = fName + ' must be function'
		return typeof result != 'string'
	}

	function onReady(err) {
		timer.clear()
		var args = Array.prototype.slice.call(arguments)
		var api = getApi(this, args)
		var err

		if (api) {
			if (!api.isReady) {
				api.isReady = err || true
				if (!(err instanceof Error)) { // we have an new api becoming ready
					if (apiReadyWait.length) checkApisReady()
				} else err = new Error('onReady with error for api: ' + api.api)
			} else  err = new Error('Multiple onReady for api: ' + api.api)
		}
		if (err) apierror.emitError(err, {args: args, emitter: this})
	}
}

function updatePrototype(theExport) {
	for (var apiName in apiMap) {
		var apiData = apiMap[apiName]
		if (apiData.theExports === theExport) {
			var fn = apiData.updatePrototype
			if (typeof fn === 'function') fn()
			break
		}
	}
}

function apisReady(cb) {
	if (!apiReadyWait.length && checkApisReady()) cb()
	else apiReadyWait.push(cb)
}

function checkApisReady() {
	var isReady = true
	for (var api in apiMap) {
		if (!apiMap[api].isReady) {
			isReady = false
			break
		}
	}
	if (isReady && apiReadyWait.length) {
		var cbs = apiReadyWait
		apiReadyWait = []
		cbs.forEach(invoke)
	}
	return isReady
}

function invoke(cb) {
	cb()
}

function getApi(emitter, args) {
	var err
	var api
	if (emitter instanceof events.EventEmitter) {
		var id = emitter.id
		if (id && typeof id === 'string') {
			api = apiMap[id]
			if (!api) err = new Error('onReady for unknown api')
		} else err = new Error('onReady for unknown api')
	} else err = new Error('onReady for non-emitter')
	if (err) apierror.emitError(err, {emitter: emitter, args: args})

	return api
}

function invokeEndApi(cb) {
	if (isEndApi != null) {
		var err = new Error('endapi invoked repeatedly')
		apierror.emitError(err)
		cb(err)
	} else {
		isEndApi = false
		apitouch.touchApis('saveApi', saveApiDone)
	}

	function saveApiDone(err) {
		isEndApi = true
		if (!err) apitouch.touchApis('endApi', cb)
		else cb(err)
	}
}

function isEndApiFn() {
	return isEndApi
}

function getState() {
	var result = {}
	for (var apiName in apiMap)
		result[apiName] = haraldutil.shallowClone(apiMap[apiName])
	return result
}

function testReset(rqs0) {
	var result = rqs
	for (var apiName in apiMap) {
		var api = apiMap[apiName]
		if (!api.isready) api.emitter.removeAllListeners('ready')
		if (rqs.shutdown) rqs.shutdown()
	}
	apiMap = {}
	isEndApi = undefined
	if (rqs0) rqs = rqs0
	return rqs
}

function getApiStates() {
	var result = {}

	for (var apiName in apiMap) {
		var apiObject = apiMap[apiName]
		if (apiObject.apiState) result[apiName] = apiObject.apiState()
	}

	return result
}

function getInitApiName(apiExports) {
	var result

	for (var apiName in apiMap) {
		var apiObject = apiMap[apiName]
		if (apiObject.theExports === apiExports) {
			result = apiObject.initApiName
			break
		}
	}

	return result
}
