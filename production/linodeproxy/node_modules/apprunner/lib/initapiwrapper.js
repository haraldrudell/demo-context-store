// initapiwrapper.js
// Insert json configuration options into initApi invocation options
// Â© 2013 Harald Rudell <harald.rudell@therudells.com> (http://haraldrudell.com) MIT License

var rqsm = require('./rqs')
// https://github.com/haraldrudell/haraldutil
var haraldutil = require('haraldutil')

var time3s = 3e3
var defaultInstanceReady = time3s

var rqs // initApi request timers for all modules with instance ready

exports.getWrapper = getWrapper

/*
Provide a wrapper that injects json configuration into the first argument
initApi(opts, ...): function: possibly contructor
state:
requireState:
*/
function getWrapper(initApi, state, requireState, opts) {
	var moduleJsonOpts // cached json config for this module
	var apiConfigName

	/*
	make "new initApiWrapper" create an initApi object with no trace of initApiWrapper
	- the prototype of initApiWrapper must be identical to initApi.prototype, otherwise instanceof will not work
	- the new expression only executes initApiWrapper function automatically
	*/
	var a = initApi.prototype.__proto__
	if (opts) opts.updatePrototype = updatePrototype
	updatePrototype()
		//initApi.prototype
		//Object.create(initApi.prototype.__proto__,
		//	{constructor: {value: initApi, enumerable: false, writable: true, configurable: true}})

	return initApiWrapper

	function updatePrototype() {
		initApiWrapper.prototype = initApi.prototype
	}

	/*
	Prepare an instance of initApi
	argument list is variable, but first argument gets json properties mixed in
	- can be invoked as x = new initApi(...) or x = initApi(...)

	1. initApiWrapper is the function exported as initApi in the module's export object
	2. exportsMap contains all known export objects
	3. We can therefore get the module name by looking in exportsMap for initApiWrapper
	4. The module name is used to find json options

	- the code invoking the api must use apiRequire
	- the api must provide initApi to getRequire
	*/
	function initApiWrapper(opts) { // merge in options from json file
		var args = Array.prototype.slice.call(arguments)
		args[0] = opts = mixin(opts)
		var instance = initApi.apply(this, args)
		var isNewOperator = this && this.constructor === initApiWrapper
		if (isNewOperator) instance = this

		var instanceReadyTimer
		var instanceReady = getReadyValue(opts.instanceReady) ||
			getReadyValue(requireState.apiObject.instanceReady)

		if (instanceReady) {
			if (instance && typeof instance.once === 'function') {
				if (!rqs) rqs = rqsm.getRqs(function () {}, 'Instance Ready Timer')
				instanceReadyTimer = rqs.addRq(requireState.apiObject.api, instanceReady)
				instance.once('ready', onReady)
			} else {
				var err = new Error('instance.once not function')
				err[arguments.callee.name] = {
					apiConfigName: apiConfigName,
					opts: opts,
				}
			}
		}

		if (!isNewOperator) return instance

		function onReady() {
			instanceReadyTimer.clear()
		}

		/*
		Get instance ready value in ms in accordance with a setting
		v:
		- positive number: ms value
		- true: use 3 s

		return value: positive number or false
		*/
		function getReadyValue(v) {
			var result = !isNaN(v) && v > 0 && +v // positive number or false
			if (!result && v) result = defaultInstanceReady // positive number
			return result
		}
	}

	function mixin(opts) {
		if (!moduleJsonOpts) { // json data for this module not yet identified
			/*
			A module can be loaded under different names
			eg. './module' and '././module'
			find a name that loaded this module and has a json configuration

			*/
			var initApiWrapperWasFound
			var theExports = requireState.apiObject.theExports
			for (var aModuleName in state.exportsMap) {
				var anExports = state.exportsMap[aModuleName]
				if (anExports === theExports) {
					initApiWrapperWasFound = true
					if (state.apiConfigs[aModuleName]) {
						moduleJsonOpts = state.apiConfigs[aModuleName]
						apiConfigName = aModuleName
						break
					}
				}
			}
			if (!initApiWrapperWasFound) throw new Error('Api not loaded with apprunner: ' + requireState.apiObject.api)
			if (!moduleJsonOpts) moduleJsonOpts = {}
		}
		return haraldutil.merge(moduleJsonOpts, opts)
	}
}
