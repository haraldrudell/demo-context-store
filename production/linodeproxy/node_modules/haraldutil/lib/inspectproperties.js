// inspectproperties.js
// Make object property names, values and prototypes printable
// Â© 2012 Harald Rudell <harald.rudell@therudells.com> MIT License

var inspectwalker = require('./inspectwalker')

exports.printProperties = printProperties

/*
Convert object property names, values and prototypes to a printable string
p: object: options for the value printed
.v the value holding properties
.f: object: Formatter for output
.getPrintableValue(v): function: for recursive printing of values
.g: object: global properties
- objects: value array for detecting cyclic references
- levelCount: number: limiting property levels
- opts: object: provided options for printing - described in inspect.js
*/
function printProperties(p) {
	var mayAbbreviate = p.g.opts.maxProperties > 0 || p.f.printPropertiesMaybe

	p.f.start()
	if (p.g.opts.maxLevels === null || p.levelCount <= p.g.opts.maxLevels) inspectwalker.walkProperties(printPropertyList, p.v, p.g.opts.nonEnum)
	else p.f.printAbbreviate() // at max depth
	p.f.printLeadout()

	function printPropertyList(object, propertyNames, prototypeName) {
		var isAbbreviating

		if (prototypeName != null) p.f.printPrototype(prototypeName)
		propertyNames.forEach(printProperty)

		function printProperty(propertyName, index, names) {
			var result
			var appendEntries

			if (mayAbbreviate) { // deal with array-style properties
				if (index == propertyName) { // this is an array-style property
					if (p.f.printPropertiesMaybe) result = [] // primitive string: avoid printing the string also as an arrray

					// abbreviate array-style properties
					else if (isAbbreviating == null) { // we are not abbreviating yet
						if (index === p.g.opts.maxProperties && // this is where we should abbreviate
							names[index + 1] == index + 1 && // there is a next property
							names[index + 2] == index + 2) { // there is a next-next property
							isAbbreviating = true // we are now abbreviating array properties
							result = ['...']
						}
					} else { // if there is yet another array-style property, keep abbreviating
						if (names[index + 1] == index + 1) result = []
						else isAbbreviating = false // this is the last array-style, start printing again
					}
				}
			}

			if (!result) { // modifiers, property name, value
				result = []

				// property name: suppressed for arrays linear index 0..
				if (!p.f.printBrackets || index != propertyName) {
					if (p.g.opts.nonEnum) { // check for detailed property data
						var propertyDescriptor = Object.getOwnPropertyDescriptor(object, propertyName)
						if (propertyDescriptor) { // some properties do not provide a descriptor
							if (propertyDescriptor.enumerable === false) result.push('(nonE)')
							if (propertyDescriptor.get) result.push('(get)')
						}
					}
					result.push(propertyName, ': ')
				}

				// value: getters may throw exception
				var value
				var exception
				try {
					value = object[propertyName]
				} catch (e) { // getter exception: do not output a value
					exception = true
					result.push('[getter Exception:', e instanceof Error ? e.toString() : 'Exception:' + String(e), ']')
				}
				if (!exception) {
					if (object instanceof Error &&
						propertyName === 'stack' &&
						typeof value === 'string') {
						appendEntries = value.split('\n')
						if (appendEntries.length) result.push(appendEntries.shift())
					} else {
						var recursive = p.g.objects.indexOf(value)
						if (!~recursive) result.push(p.getPrintableValue(value))
						else result.push('recursive-object#', recursive + 1)
					}
				}
			}

			// output result to formatter
			if (result.length) p.f.printEntry.apply(p.f, result)
			if (appendEntries) appendEntries.forEach(printLine)

			function printLine(line) {
				p.f.printEntry(line)
			}
		}
	}
}
