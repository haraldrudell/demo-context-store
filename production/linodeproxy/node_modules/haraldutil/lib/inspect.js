// inspect.js
// Convert any value to a unique, printable string
// Â© 2011 Harald Rudell <harald.rudell@therudells.com> MIT License

var inspectproperties = require('./inspectproperties')
var escapechar = require('./escapechar')
var inspectformatter = require('./inspectformatter')
var errorutil = require('./errorutil')

;[
inspect, inspectAll, inspectDeep
].forEach(function (f) {exports[f.name] = f})

/*
in 15.5.4.14 is exemplified how arrays should be printed
- no spaces around '[' and ']'
- separating elements: ', ' comma and space
- double quotes used for strings: '"'
*/

var allObj = {
	maxString: 0,
	maxProperties: 0,
	maxLevels: null,
	nonEnum: true,
}
function inspectAll(v) {
	return inspect(v, allObj)
}

// unlimited strings, 10 array properties, unlimited levels, non-enumerable properties
var deepObj = {
	maxString: 0,
	maxProperties: 10,
	maxLevels: null,
	nonEnum: true,
}
function inspectDeep(v) {
	return inspect(v, deepObj)
}

var functionMatcher = /^function ([^\(]*)(\([^\)]*\)) {/
/*
Get a unique string representation of the value v
optsArg: optional object
.maxString: optional number, default 40: max string characters to print, 0: no truncation
.maxProperties: optional number, default 10: max array-type properties to print, 0 for all. Only arrays of 4 or more elements are abbreviated.
.maxLevels: optional number or null: max levels of objects and arrays to print 0.., default 2, null: all
.nonEnum: optional boolean, default false: print prototypes and non-enumerable object properties
.noArrayLength: optional boolean, default false: do not print array length
.singleLine optional boolean, default false: print on a single line
.dateISO optional boolean, default false: print dates as ISO strings
.errorPretty optional boolean, default false: print errors using eToString

return value: printable string
printable characters are 32..126. Escaping uses JavaScript character escapes
*/
function inspect(v, opts) {
	parseOpts()
	var levelCount = 0 // limiting property levels printed
	var g = { // global properties for this invocation
		objects: [], // for detecting cyclic references
		opts: opts,
	}

	return getPrintableValue(v)

	function getPrintableValue(v) { // invoked recursively for object properties
		var result
		var t = typeof v // string type name

		if (t === 'undefined') result = t
		else if (t === 'boolean') result = String(!!v)
		else if (t === 'number') result = v.toString()
		else if (t === 'string') {
			result = ['\'']
			for (var index in v) {
				if (g.opts.maxString && index >= g.opts.maxString) {
					result.push('...')
					break
				}
				result.push(escapechar.escapedChar(v.charAt(index)))
			}
			result.push('\'')
			result = result.join('')
		} else if (v === null) result = String(v)
		else { // the value may have properties
			var noProperties
			result = []
			g.objects.push(v) // save this value to the list of previously seen objects
			var p = { // p is data for this level
				v: v, // the original value
				f: new inspectformatter.Formatter(result, opts.singleLine, ++levelCount),
				g: g, // global properties
				getPrintableValue: getPrintableValue,
				levelCount: levelCount,
			}
			if (t === 'function') {
				p.f.printBracesMaybe = true // print braces only if there are properties
				/*
				'function f(a, b)' if we can parse
				'function (a, b)' if we can parse
				'function f:2' or
				'function:2'
				*/
				result.push(t)
				if (v.name) result.push(' ', v.name)
				// match[1]: function name, match[2]: argument list '(a,b)'
				var match = functionMatcher.exec(v.toString())
				if (match && match[1] === v.name) {
					if (!v.name) result.push(' ')
					result.push(match[2])
				} else result.push(':', v.length)
			} else if (p.f.printBrackets = Array.isArray(v)) { // Array
				if (!g.opts.noArrayLength) result.push(v.length) // array dimension
			} else { // object

				// primtive objects and Date
				// valueOf() may throw, eg. process.env
				// TypeError: Property 'valueOf' of object #<error> is not a function
				var tt
				var innerValue
				try {
					innerValue = v.valueOf()
					tt = typeof innerValue
				} catch (e) { // exception: assume this is not a primitive object
					innerValue = v
					tt = t
				}
				if (t !== tt) { // primitive object or Date
					p.f.printBracesMaybe = true
					p.f.printPropertiesMaybe = tt === 'string' // strings also appears as an array of characters: do not print

					var isDate = v instanceof Date
					if (isDate && g.opts.dateISO) result.push(v.toISOString())
					else result.push(isDate ? 'Date' : 'Object',
						'(', getPrintableValue(innerValue), ')') // 'Object(5)' or 'Date(5)'

				} else if (v instanceof RegExp) { // handle RegExp
					p.f.printBracesMaybe = true
					result.push(v.toString())

				} else if (g.opts.errorPretty && v instanceof Error) { // Error
					result.push(errorutil.eToString(v, false) || 'Error')
					noProperties = true

				} else { //regular object: object:Constructor
					if (v.constructor && v.constructor.name && v.constructor.name !== 'Object') {
						result.push('object:', v.constructor.name)
					}
				}
			}
			if (!noProperties) inspectproperties.printProperties(p)
			levelCount--
			result = result.join('')
		}

		return result
	}

	function parseOpts() {
		var optsArg = opts || {}
		opts = {}
		ensureNumber('maxString', 80)
		ensureNumber('maxProperties', 10)
		ensureNumber('maxLevels', 2, true)
		ensureBoolean('nonEnum', false)
		ensureBoolean('noArrayLength', false)
		ensureBoolean('singleLine', false)
		ensureBoolean('dateISO', false)
		ensureBoolean('errorPretty', false)

		/*
		Define an optsArg property based on opts, number 0 or greater
		property: string property name
		aDefault: number: default value
		canHaveNull: optional boolean default false: null is an allowed value
		*/
		function ensureNumber(property, aDefault, canHaveNull) {
			var value = optsArg[property]
			if (!canHaveNull || value !== null) {
				if (value >= 0) value = +value // all legal values: convert to number
				else value = aDefault
			}
			opts[property] = value
		}

		/*
		Define an optsArg property based on opts, boolean value
		property: string property name
		aDefault: boolean: default value
		*/
		function ensureBoolean(property, aDefault) {
			opts[property] = optsArg[property] !== undefined ?
				!!optsArg[property] :
				aDefault
		}
	}
}
