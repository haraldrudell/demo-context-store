var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/// <reference path="../../typings/tsd.d.ts" />
var angular2_1 = require('angular2/angular2');
var render_1 = require('angular2/src/core/render/render');
exports.DomRenderer = render_1.DomRenderer;
exports.DomRenderer_ = render_1.DomRenderer_;
exports.DOCUMENT = render_1.DOCUMENT;
var animation_builder_1 = require('angular2/src/animate/animation_builder');
var event_manager_1 = require('angular2/src/core/render/dom/events/event_manager');
var shared_styles_host_1 = require('angular2/src/core/render/dom/shared_styles_host');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
function resolveInternalDomView(viewRef) {
    return viewRef;
}
function resolveInternalDomFragment(fragmentRef) {
    return fragmentRef.nodes;
}
var ServerDomRenderer_ = (function (_super) {
    __extends(ServerDomRenderer_, _super);
    function ServerDomRenderer_(_eventManager, _domSharedStylesHost, _animate, document) {
        _super.call(this, _eventManager, _domSharedStylesHost, _animate, document);
        this._eventManager = _eventManager;
        this._domSharedStylesHost = _domSharedStylesHost;
        this._animate = _animate;
    }
    ServerDomRenderer_.prototype.setElementProperty = function (location, propertyName, propertyValue) {
        if (propertyName === 'value' || (propertyName === 'checked' && propertyValue !== false)) {
            var view = resolveInternalDomView(location.renderView);
            var element = view.boundElements[location.boundElementIndex];
            if (dom_adapter_1.DOM.nodeName(element) === 'input') {
                dom_adapter_1.DOM.setAttribute(element, propertyName, propertyValue);
                return;
            }
        }
        else if (propertyName === 'src') {
            var view = resolveInternalDomView(location.renderView);
            var element = view.boundElements[location.boundElementIndex];
            dom_adapter_1.DOM.setAttribute(element, propertyName, propertyValue);
            return;
        }
        return _super.prototype.setElementProperty.call(this, location, propertyName, propertyValue);
    };
    ServerDomRenderer_.prototype.invokeElementMethod = function (location, methodName, args) {
        if (methodName === 'focus') {
            var view = resolveInternalDomView(location.renderView);
            var element = view.boundElements[location.boundElementIndex];
            if (dom_adapter_1.DOM.nodeName(element) === 'input') {
                dom_adapter_1.DOM.invoke(element, 'autofocus', null);
                return;
            }
        }
        return _super.prototype.invokeElementMethod.call(this, location, methodName, args);
    };
    ServerDomRenderer_ = __decorate([
        angular2_1.Injectable(),
        __param(3, angular2_1.Inject(render_1.DOCUMENT)), 
        __metadata('design:paramtypes', [event_manager_1.EventManager, shared_styles_host_1.DomSharedStylesHost, animation_builder_1.AnimationBuilder, Object])
    ], ServerDomRenderer_);
    return ServerDomRenderer_;
})(render_1.DomRenderer_);
exports.ServerDomRenderer_ = ServerDomRenderer_;
exports.SERVER_DOM_RENDERER_PROVIDERS = [
    angular2_1.provide(render_1.DomRenderer, { useClass: ServerDomRenderer_ }),
    angular2_1.provide(render_1.Renderer, { useClass: render_1.DomRenderer })
];
//# sourceMappingURL=server_dom_renderer.js.map