/// <reference path="../../typings/tsd.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
require('../server_patch');
var angular2_1 = require('angular2/angular2');
var http_1 = require('angular2/http');
var async_1 = require('angular2/src/core/facade/async');
var lang_1 = require('angular2/src/core/facade/lang');
var Rx = require('@reactivex/rxjs/dist/cjs/Rx');
var Observable = Rx.Observable;
// CJS
var XMLHttpRequest = require('xhr2');
exports.BASE_URL = lang_1.CONST_EXPR(new angular2_1.OpaqueToken('baseUrl'));
exports.PRIME_CACHE = lang_1.CONST_EXPR(new angular2_1.OpaqueToken('primeCache'));
var NodeConnection = (function () {
    function NodeConnection(req, browserXHR, baseResponseOptions) {
        var _this = this;
        this.request = req;
        this.response = new Observable(function (responseObserver) {
            var _xhr = browserXHR.build();
            _xhr.open(http_1.RequestMethods[req.method].toUpperCase(), req.url);
            // load event handler
            var onLoad = function () {
                // responseText is the old-school way of retrieving response (supported by IE8 & 9)
                // response/responseType properties were introduced in XHR Level2 spec (supported by
                // IE10)
                var response = ('response' in _xhr) ? _xhr.response : _xhr.responseText;
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status = _xhr.status === 1223 ? 204 : _xhr.status;
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status === 0) {
                    status = response ? 200 : 0;
                }
                var responseOptions = new http_1.ResponseOptions({ body: response, status: status });
                if (lang_1.isPresent(baseResponseOptions)) {
                    responseOptions = baseResponseOptions.merge(responseOptions);
                }
                responseObserver.next(new http_1.Response(responseOptions));
                // TODO(gdi2290): defer complete if array buffer until done
                responseObserver.complete();
            };
            // error event handler
            var onError = function (err) {
                var responseOptions = new http_1.ResponseOptions({ body: err, type: http_1.ResponseTypes.Error });
                if (lang_1.isPresent(baseResponseOptions)) {
                    responseOptions = baseResponseOptions.merge(responseOptions);
                }
                responseObserver.error(new http_1.Response(responseOptions));
            };
            if (lang_1.isPresent(req.headers)) {
                req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });
            }
            _xhr.addEventListener('load', onLoad);
            _xhr.addEventListener('error', onError);
            _xhr.send(_this.request.text());
            return function () {
                _xhr.removeEventListener('load', onLoad);
                _xhr.removeEventListener('error', onError);
                _xhr.abort();
            };
        });
    }
    return NodeConnection;
})();
var NodeXhr = (function () {
    function NodeXhr(baseUrl) {
        if (lang_1.isBlank(baseUrl)) {
            throw new Error('No base url set. Please provide a BASE_URL bindings.');
        }
        this._baseUrl = baseUrl;
    }
    NodeXhr.prototype.build = function () {
        var xhr = new XMLHttpRequest();
        xhr.nodejsSet({ baseUrl: this._baseUrl });
        return xhr;
    };
    NodeXhr = __decorate([
        angular2_1.Injectable(),
        __param(0, angular2_1.Optional()),
        __param(0, angular2_1.Inject(exports.BASE_URL)), 
        __metadata('design:paramtypes', [String])
    ], NodeXhr);
    return NodeXhr;
})();
exports.NodeXhr = NodeXhr;
var NodeBackend = (function () {
    function NodeBackend(_browserXHR, _baseResponseOptions) {
        this._browserXHR = _browserXHR;
        this._baseResponseOptions = _baseResponseOptions;
    }
    NodeBackend.prototype.createConnection = function (request) {
        return new NodeConnection(request, this._browserXHR, this._baseResponseOptions);
    };
    NodeBackend = __decorate([
        angular2_1.Injectable(), 
        __metadata('design:paramtypes', [http_1.BrowserXhr, http_1.ResponseOptions])
    ], NodeBackend);
    return NodeBackend;
})();
exports.NodeBackend = NodeBackend;
var NgPreloadCacheHttp = (function (_super) {
    __extends(NgPreloadCacheHttp, _super);
    function NgPreloadCacheHttp(_backend, _defaultOptions, prime) {
        _super.call(this, _backend, _defaultOptions);
        this._backend = _backend;
        this._defaultOptions = _defaultOptions;
        this.prime = prime;
        this._async = 0;
        this._callId = 0;
        var _rootNode = { children: [], res: null };
        this._rootNode = _rootNode;
        this._activeNode = _rootNode;
    }
    NgPreloadCacheHttp.prototype.preload = function (factory) {
        var _this = this;
        // TODO: fix this after the next release with RxNext
        var obs = new angular2_1.EventEmitter();
        var currentNode = null;
        if (lang_1.isPresent(this._activeNode)) {
            currentNode = { children: [], res: null };
            this._activeNode.children.push(currentNode);
        }
        // We need this to ensure all ajax calls are done before rendering the app
        this._async += 1;
        var request = factory();
        async_1.ObservableWrapper
            .subscribe(request, function (value) {
            var res = Object.assign({}, value, {
                headers: value.headers.values()
            });
            if (lang_1.isPresent(currentNode)) {
                currentNode.res = res;
            }
            async_1.ObservableWrapper.callNext(obs, value);
        }, function (e) {
            // TODO: update Angular 2 Http
            setTimeout(function () {
                _this._async -= 1;
                async_1.ObservableWrapper.callThrow(obs, e);
            });
        }, function () {
            // TODO: update Angular 2 Http
            setTimeout(function () {
                _this._activeNode = currentNode;
                _this._async -= 1;
                async_1.ObservableWrapper.callReturn(obs);
                _this._activeNode = null;
            });
        });
        return obs;
    };
    NgPreloadCacheHttp.prototype.request = function (url, options) {
        var _this = this;
        return lang_1.isBlank(this.prime) ? _super.prototype.request.call(this, url, options) : this.preload(function () { return _super.prototype.request.call(_this, url, options); });
    };
    NgPreloadCacheHttp.prototype.get = function (url, options) {
        var _this = this;
        return lang_1.isBlank(this.prime) ? _super.prototype.get.call(this, url, options) : this.preload(function () { return _super.prototype.get.call(_this, url, options); });
    };
    NgPreloadCacheHttp.prototype.post = function (url, body, options) {
        var _this = this;
        return lang_1.isBlank(this.prime) ? _super.prototype.post.call(this, url, body, options) : this.preload(function () { return _super.prototype.post.call(_this, url, body, options); });
    };
    NgPreloadCacheHttp.prototype.put = function (url, body, options) {
        var _this = this;
        return lang_1.isBlank(this.prime) ? _super.prototype.put.call(this, url, body, options) : this.preload(function () { return _super.prototype.put.call(_this, url, body, options); });
    };
    NgPreloadCacheHttp.prototype.delete = function (url, options) {
        var _this = this;
        return lang_1.isBlank(this.prime) ? _super.prototype.delete.call(this, url, options) : this.preload(function () { return _super.prototype.delete.call(_this, url, options); });
    };
    NgPreloadCacheHttp.prototype.patch = function (url, body, options) {
        var _this = this;
        return lang_1.isBlank(this.prime) ? _super.prototype.patch.call(this, url, body, options) : this.preload(function () { return _super.prototype.patch.call(_this, url, body, options); });
    };
    NgPreloadCacheHttp.prototype.head = function (url, options) {
        var _this = this;
        return lang_1.isBlank(this.prime) ? _super.prototype.head.call(this, url, options) : this.preload(function () { return _super.prototype.head.call(_this, url, options); });
    };
    NgPreloadCacheHttp = __decorate([
        angular2_1.Injectable(),
        __param(2, angular2_1.Optional()),
        __param(2, angular2_1.Inject(exports.PRIME_CACHE)), 
        __metadata('design:paramtypes', [http_1.ConnectionBackend, http_1.RequestOptions, Boolean])
    ], NgPreloadCacheHttp);
    return NgPreloadCacheHttp;
})(http_1.Http);
exports.NgPreloadCacheHttp = NgPreloadCacheHttp;
exports.HTTP_PROVIDERS = [
    angular2_1.provide(exports.BASE_URL, { useValue: '' }),
    angular2_1.provide(exports.PRIME_CACHE, { useValue: false }),
    angular2_1.provide(http_1.RequestOptions, { useClass: http_1.BaseRequestOptions }),
    angular2_1.provide(http_1.ResponseOptions, { useClass: http_1.BaseResponseOptions }),
    angular2_1.provide(http_1.BrowserXhr, { useClass: NodeXhr }),
    angular2_1.provide(http_1.ConnectionBackend, { useClass: NodeBackend }),
    angular2_1.provide(http_1.Http, { useClass: NgPreloadCacheHttp })
];
//# sourceMappingURL=server_http.js.map