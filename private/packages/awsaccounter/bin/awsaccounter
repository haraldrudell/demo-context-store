#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var stream = _interopDefault(require('stream'));
var childProcess = _interopDefault(require('child_process'));
var util = _interopDefault(require('util'));
var fs = _interopDefault(require('fs'));
var constants = _interopDefault(require('constants'));
var assert = _interopDefault(require('assert'));
var path = _interopDefault(require('path'));
var os = _interopDefault(require('os'));
var AWS = _interopDefault(require('aws-sdk'));

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
var _toInteger = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

// true  -> String#at
// false -> String#codePointAt
var _stringAt = function (TO_STRING) {
  return function (that, pos) {
    var s = String(_defined(that));
    var i = _toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var _library = true;

var _global = createCommonjsModule(function (module) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
var _core_1 = _core.version;

var _aFunction = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function (fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

var _isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function (it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

var document$1 = _global.document;
// typeof document.createElement is 'object' in old IE
var is = _isObject(document$1) && _isObject(document$1.createElement);
var _domCreate = function (it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function (it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;

var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
	f: f
};

var _propertyDesc = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? _ctx(out, _global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
var _export = $export;

var _redefine = _hide;

var hasOwnProperty = {}.hasOwnProperty;
var _has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var _iterators = {};

var toString = {}.toString;

var _cof = function (it) {
  return toString.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings

// eslint-disable-next-line no-prototype-builtins
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

// to indexed object, toObject with fallback for non-array-like ES3 strings


var _toIobject = function (it) {
  return _iobject(_defined(it));
};

// 7.1.15 ToLength

var min = Math.min;
var _toLength = function (it) {
  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;
var _toAbsoluteIndex = function (index, length) {
  index = _toInteger(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes



var _arrayIncludes = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this);
    var length = _toLength(O.length);
    var index = _toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var SHARED = '__core-js_shared__';
var store = _global[SHARED] || (_global[SHARED] = {});
var _shared = function (key) {
  return store[key] || (store[key] = {});
};

var id = 0;
var px = Math.random();
var _uid = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var shared = _shared('keys');

var _sharedKey = function (key) {
  return shared[key] || (shared[key] = _uid(key));
};

var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO = _sharedKey('IE_PROTO');

var _objectKeysInternal = function (object, names) {
  var O = _toIobject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (_has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

// 19.1.2.14 / 15.2.3.14 Object.keys(O)



var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  _anObject(O);
  var keys = _objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
  return O;
};

var document$2 = _global.document;
var _html = document$2 && document$2.documentElement;

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



var IE_PROTO$1 = _sharedKey('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE$1 = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');
  var i = _enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
  return createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE$1] = _anObject(O);
    result = new Empty();
    Empty[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = createDict();
  return Properties === undefined ? result : _objectDps(result, Properties);
};

var _wks = createCommonjsModule(function (module) {
var store = _shared('wks');

var Symbol = _global.Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
};

$exports.store = store;
});

var def = _objectDp.f;

var TAG = _wks('toStringTag');

var _setToStringTag = function (it, tag, stat) {
  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function () { return this; });

var _iterCreate = function (Constructor, NAME, next) {
  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
  _setToStringTag(Constructor, NAME + ' Iterator');
};

// 7.1.13 ToObject(argument)

var _toObject = function (it) {
  return Object(_defined(it));
};

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


var IE_PROTO$2 = _sharedKey('IE_PROTO');
var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = _toObject(O);
  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

var ITERATOR = _wks('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  _iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      _setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!_library && !_has(IteratorPrototype, ITERATOR)) _hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    _hide(proto, ITERATOR, $default);
  }
  // Plug for library
  _iterators[NAME] = $default;
  _iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) _redefine(proto, key, methods[key]);
    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

var $at = _stringAt(true);

// 21.1.3.27 String.prototype[@@iterator]()
_iterDefine(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

var _iterStep = function (done, value) {
  return { value: value, done: !!done };
};

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
  this._t = _toIobject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return _iterStep(1);
  }
  if (kind == 'keys') return _iterStep(0, index);
  if (kind == 'values') return _iterStep(0, O[index]);
  return _iterStep(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
_iterators.Arguments = _iterators.Array;

var TO_STRING_TAG = _wks('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = _global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
  _iterators[NAME] = _iterators.Array;
}

// getting tag from 19.1.3.6 Object.prototype.toString()

var TAG$1 = _wks('toStringTag');
// ES3 wrong here
var ARG = _cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

var _classof = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
    // builtinTag case
    : ARG ? _cof(O)
    // ES3 arguments fallback
    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

var _anInstance = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

// call something on iterator step with safe closing on error

var _iterCall = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) _anObject(ret.call(iterator));
    throw e;
  }
};

// check on default Array iterator

var ITERATOR$1 = _wks('iterator');
var ArrayProto = Array.prototype;

var _isArrayIter = function (it) {
  return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
};

var ITERATOR$2 = _wks('iterator');

var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$2]
    || it['@@iterator']
    || _iterators[_classof(it)];
};

var _forOf = createCommonjsModule(function (module) {
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
  var f = _ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = _iterCall(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;
});

// 7.3.20 SpeciesConstructor(O, defaultConstructor)


var SPECIES = _wks('species');
var _speciesConstructor = function (O, D) {
  var C = _anObject(O).constructor;
  var S;
  return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);
};

// fast apply, http://jsperf.lnkit.com/fast-apply/5
var _invoke = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

var process$1 = _global.process;
var setTask = _global.setImmediate;
var clearTask = _global.clearImmediate;
var MessageChannel = _global.MessageChannel;
var Dispatch = _global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (_cof(process$1) == 'process') {
    defer = function (id) {
      process$1.nextTick(_ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(_ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = _ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
    defer = function (id) {
      _global.postMessage(id + '', '*');
    };
    _global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
    defer = function (id) {
      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
        _html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(_ctx(run, id, 1), 0);
    };
  }
}
var _task = {
  set: setTask,
  clear: clearTask
};

var macrotask = _task.set;
var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
var process$2 = _global.process;
var Promise$1 = _global.Promise;
var isNode = _cof(process$2) == 'process';

var _microtask = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process$2.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process$2.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise$1 && Promise$1.resolve) {
    var promise = Promise$1.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(_global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

// 25.4.1.5 NewPromiseCapability(C)


function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = _aFunction(resolve);
  this.reject = _aFunction(reject);
}

var f$1 = function (C) {
  return new PromiseCapability(C);
};

var _newPromiseCapability = {
	f: f$1
};

var _perform = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

var _promiseResolve = function (C, x) {
  _anObject(C);
  if (_isObject(x) && x.constructor === C) return x;
  var promiseCapability = _newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var _redefineAll = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else _hide(target, key, src[key]);
  } return target;
};

var SPECIES$1 = _wks('species');

var _setSpecies = function (KEY) {
  var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];
  if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
    configurable: true,
    get: function () { return this; }
  });
};

var ITERATOR$3 = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$3]();
  riter['return'] = function () { SAFE_CLOSING = true; };
} catch (e) { /* empty */ }

var _iterDetect = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR$3]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR$3] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

var task = _task.set;
var microtask = _microtask();



var PROMISE = 'Promise';
var TypeError$1 = _global.TypeError;
var process$3 = _global.process;
var $Promise = _global[PROMISE];
var isNode$1 = _classof(process$3) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability$1 = newGenericPromiseCapability = _newPromiseCapability.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError$1('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(_global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = _perform(function () {
        if (isNode$1) {
          process$3.emit('unhandledRejection', value, promise);
        } else if (handler = _global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = _global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(_global, function () {
    var handler;
    if (isNode$1) {
      process$3.emit('rejectionHandled', promise);
    } else if (handler = _global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    _anInstance(this, $Promise, PROMISE, '_h');
    _aFunction(executor);
    Internal.call(this);
    try {
      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = _redefineAll($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability$1(_speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode$1 ? process$3.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = _ctx($resolve, promise, 1);
    this.reject = _ctx($reject, promise, 1);
  };
  _newPromiseCapability.f = newPromiseCapability$1 = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Promise: $Promise });
_setToStringTag($Promise, PROMISE);
_setSpecies(PROMISE);
Wrapper = _core[PROMISE];

// statics
_export(_export.S + _export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability$1(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
_export(_export.S + _export.F * (_library || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);
  }
});
_export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability$1(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = _perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      _forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability$1(C);
    var reject = capability.reject;
    var result = _perform(function () {
      _forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

_export(_export.P + _export.R, 'Promise', { 'finally': function (onFinally) {
  var C = _speciesConstructor(this, _core.Promise || _global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return _promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return _promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

// https://github.com/tc39/proposal-promise-try




_export(_export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = _newPromiseCapability.f(this);
  var result = _perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

var promise = _core.Promise;

var promise$2 = createCommonjsModule(function (module) {
module.exports = { "default": promise, __esModule: true };
});

var _Promise = unwrapExports(promise$2);

var asyncToGenerator = createCommonjsModule(function (module, exports) {

exports.__esModule = true;



var _promise2 = _interopRequireDefault(promise$2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};
});

var _asyncToGenerator = unwrapExports(asyncToGenerator);

// most Object methods by ES6 should accept primitives



var _objectSap = function (KEY, exec) {
  var fn = (_core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
};

// 19.1.2.14 Object.keys(O)



_objectSap('keys', function () {
  return function keys(it) {
    return _objectKeys(_toObject(it));
  };
});

var keys = _core.Object.keys;

var keys$2 = createCommonjsModule(function (module) {
module.exports = { "default": keys, __esModule: true };
});

var _Object$keys = unwrapExports(keys$2);

var f$2 = Object.getOwnPropertySymbols;

var _objectGops = {
	f: f$2
};

var f$3 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$3
};

// 19.1.2.1 Object.assign(target, source, ...)





var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
var _objectAssign = !$assign || _fails(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = _toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = _objectGops.f;
  var isEnum = _objectPie.f;
  while (aLen > index) {
    var S = _iobject(arguments[index++]);
    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

// 19.1.3.1 Object.assign(target, source)


_export(_export.S + _export.F, 'Object', { assign: _objectAssign });

var assign = _core.Object.assign;

var assign$2 = createCommonjsModule(function (module) {
module.exports = { "default": assign, __esModule: true };
});

var _Object$assign = unwrapExports(assign$2);

var _extends = createCommonjsModule(function (module, exports) {

exports.__esModule = true;



var _assign2 = _interopRequireDefault(assign$2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
});

var _extends$1 = unwrapExports(_extends);

const { Stream } = stream;

class Capturer {

  constructor(o) {
    this.text = '';
    this.onClose = this.onClose.bind(this);

    this.dataListener = text => this.saveText(text).catch(this._reject);

    const { input, pipe } = o || false;
    if (!(input instanceof Stream)) throw new Error(`Capturer: input not stream: ${typeof input}`);
    this.promise = new _Promise((resolve, reject) => (this._resolve = resolve) + (this._reject = reject));
    input.on('data', this.dataListener).once('close', this.onClose).setEncoding('utf8');
    if (pipe) {
      if (!(pipe instanceof Stream)) throw new Error(`Capturer: pipe not stream: ${typeof pipe}`);
      input.pipe(pipe);
    }
  }

  onClose() {
    this._resolve(this.text);
  }

  saveText(text) {
    var _this = this;

    return _asyncToGenerator(function* () {
      _this.text += text;
    })();
  }
}

const { spawn } = childProcess;

class SpawnShim {

  constructor(o) {
    const { name, args, options, debug, killTimeout } = o || false;
    this.m = String(name || 'SpawnShim');
    if (typeof args === 'string') {
      args && (this.cmd = args);
    } else if (Array.isArray(args)) {
      args[0] && (this.cmd = args[0]);
      this.args = args.slice(1);
    } else args && (this.args = args);
    options && (this.options = options);
    this.killTimeout = killTimeout >= 0 ? +killTimeout : SpawnShim.killTimeout;
    debug && (this.debug = true) && this.constructor === SpawnShim && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`);
  }

  spawn() {
    // options: cwd env argv0 stdio detached uid gid shell windowsVerbatimArguments windowsHide
    const { debug, cmd, args, options } = this;
    let cp;
    const setExit = () => (this.isExit = true) && debug && console.log(`${this.m} isExit`);
    const cpListener = () => setExit() + cp.removeListener('exit', cpListener).removeListener('error', cpListener);
    try {
      this.cp = cp = spawn(cmd, args, options).once('exit', cpListener).once('error', cpListener);
    } catch (e) {
      setExit();
      throw e;
    }
    this.promise = new _Promise((resolve, reject) => {
      let e;
      cp.once('close', (status, signal) => resolve({ e, status, signal })).on('error', ee => !e && (e = ee)); // subsequent errors are ignored
    });
    return cp;
  }

  abortProcess() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const { cp, isExit, debug, killTimeout } = _this;
      const { killed } = cp || false;
      debug && console.log(`${_this.m} abortProcess: cp: ${!!cp} isExit: ${isExit} killed: ${killed}`);
      if (!cp || isExit) return;

      yield new _Promise(function (resolve, reject) {
        cp.once('exit', listener).once('error', listener);
        if (!killed) {
          debug && console.log(`${_this.m} cp.kill…`);
          cp.kill();
        }
        let timer = killTimeout && setTimeout(doSigKill, killTimeout);

        function listener() {
          cp.removeListener('exit', listener).removeListener('error', listener);
          timer && clearTimeout(timer);
          resolve();
        }
        function doSigKill() {
          try {
            timer = null;
            debug && console.log(`${this.m} abortProcess: SIGKILL…`);
            cp.kill('SIGKILL'); // kill -9
          } catch (e) {
            reject(e);
          }
        }
      });
      debug && console.log(`${_this.m} abortProcess: exit complete: isExit: ${_this.isExit}`);
    })();
  }
}
SpawnShim.killTimeout = 3e3;

class SpawnPipe extends SpawnShim {

  constructor(o) {
    super(o);
    const { capture, stderrFails } = o || false;
    capture && (this.capture = true);
    stderrFails && (this.stderrFails = true);
    const options = this.options = _extends$1({}, this.options);
    for (let p of SpawnPipe.pipeOptions) if (options.hasOwnProperty(p)) {
      options[p] && (this[p] = true);
      delete options[p];
    }
    const { silent } = this;
    const { stdio: stdio0 } = options;
    const defOut = silent ? 'pipe' : 'inherit';
    const stdio = options.stdio = Array.isArray(stdio0) ? stdio0 : typeof stdio0 === 'string' ? new Array(3).fill(stdio0) : ['ignore', defOut, defOut];
    if (capture) {
      stdio[1] = stdio[2] = 'pipe';
      if (stdio[0] === undefined) stdio[0] = 'ignore';
    } else if (stderrFails) {
      stdio[2] = 'pipe';
      if (stdio[0] === undefined) stdio[0] = 'ignore';
      if (stdio[1] === undefined) stdio[1] = 'ignore';
    }
  }

  startCapture() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const { capture, stderrFails } = _this;
      return capture ? _this.doCapture() : stderrFails ? _this.doStderrFails() : {};
    })();
  }

  doCapture() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const { cp, silent, stderrFails } = _this2;
      const capturers = ['stdout', 'stderr'].map(function (stream$$1) {
        return new Capturer({ input: cp[stream$$1], pipe: !silent && process[stream$$1] });
      });
      const [stdout, stderr] = yield _Promise.all(capturers.map(function (c) {
        return c.promise;
      }));
      const isStderr = stderrFails && !!stderr;
      return { stdout, stderr, isStderr };
    })();
  }

  doStderrFails() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      const { cp: { stderr: stream$$1 } } = _this3;
      const stderr = yield new _Promise(function (resolve, reject) {
        return stream$$1.once('data', function (text) {
          return text && resolve(text);
        }).once('close', function () {
          return resolve();
        }).setEncoding('utf8');
      });
      const isStderr = !!stderr;
      return { stderr, isStderr };
    })();
  }
}
SpawnPipe.pipeOptions = _Object$keys({ maxBuffer: 1, silent: 1 });
SpawnPipe.maxBuffer = 200 * 1024;

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
This source code is licensed under the ISC-style license found in the LICENSE file in the root directory of this source tree.
*/
class Timer {
  constructor(o) {
    const { onTimeout, timeout, debug } = o || false;
    this.m = 'Timer';
    _Object$assign(this, { onTimeout, timeout, debug });
    debug && console.log(`${this.m} constructor:`, this);
  }

  start() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const { timeout, onTimeout, debug } = _this;
      const wasCancelled = yield new _Promise(function (resolve, reject) {
        return (_this.timeoutID = setTimeout(resolve, timeout)) + (_this._resolve = resolve);
      });
      if (!wasCancelled) {
        debug && console.log(`${_this.m} timed out`);
        _this.timeoutID = null;
        return onTimeout();
      }
    })();
  }

  cancel() {
    const { timeoutID, _resolve, debug } = this;
    debug && console.log(`${this.m}.cancel: needs cancel: ${!!timeoutID}`);
    if (timeoutID) {
      this.timeoutID = null;
      clearTimeout(timeoutID);
      _resolve(true);
    }
  }
}

class SpawnAsync extends SpawnPipe {

  static spawnAsync(o) {
    return _asyncToGenerator(function* () {
      return new SpawnAsync(o).startSpawn();
    })();
  }

  constructor(o) {
    super(_extends$1({ name: 'SpawnAsync' }, o));
    this.onTimeout = this.onTimeout.bind(this);
    const { cpReceiver, echo, nonZeroOk } = o || false;
    echo && (this.echo = true);
    nonZeroOk && (this.nonZeroOk = true);
    cpReceiver && _Object$assign(this, { cpReceiver });
    const { options, debug } = this;
    const { timeout } = options;
    this.timeout = timeout >= 0 ? +timeout : 0;
    for (let p of SpawnAsync.optionsProperties) delete options[p];
    debug && this.constructor === SpawnAsync && console.log(`${this.m} constructor:`, this);
  }

  startSpawn() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const { timeout, onTimeout, debug } = _this;
      const ps = [_this.launchProcess()];
      timeout > 0 && ps.push((_this.timer = new Timer({ timeout, onTimeout, debug })).start());
      const [result] = yield _Promise.all(ps);
      return result;
    })();
  }

  launchProcess() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const { echo, cpReceiver, debug } = _this2;

      // launch the child process
      echo && console.log(_this2.cmdString());
      const cp = _this2.spawn();
      cpReceiver && (cpReceiver.cp = cp);

      // await child process exit
      const [{ e, status, signal }, { stdout, stderr, isStderr }] = yield _Promise.all([_this2.promise, _this2.startCapture()]);

      // handle timeout
      const { isTimeout, timer, timeout, nonZeroOk } = _this2;
      debug && console.log(`${_this2.m} process exit:`, { e, status, signal, stdout: stdout && stdout.length, stderr: stderr && stderr.length, isStderr, isTimeout, ss: stdout });
      if (isTimeout) {
        throw _this2.setErrorProps(new Error(`Process timeout: ${(timeout / 1e3).toFixed(1)} s: ${_this2.cmdString()}`));
      } else timer && timer.cancel();

      // handle error from child process
      if (e) throw _this2.setErrorProps(e);
      if (status && !nonZeroOk || signal) throw _this2.getError({ status, signal });
      if (isStderr) throw _this2.setErrorProps(new Error(`Output on standard error: ${_this2.cmdString()}: '${stderr}'`), { stderr: _this2.trimEnd(stderr) });

      return stdout === undefined ? status : { stdout, stderr };
    })();
  }

  onTimeout() {
    const { debug } = this;
    debug && console.log(`${this.m}.onTimeout`);
    this.isTimeout = true;
    return this.abortProcess();
  }

  trimEnd(s) {
    if (typeof s === 'string' && s.endsWith('\n')) return s.slice(0, -1);
    return s;
  }

  getError({ status, signal }) {
    let msg = `status code: ${status}`;
    if (signal) msg += ` signal: ${signal}`;
    msg += ` '${this.cmdString()}'`;
    const e = new Error(msg);
    _Object$assign(e, { status });
    if (signal) _Object$assign(e, { signal });
    return this.setErrorProps(e);
  }

  setErrorProps(e, o) {
    const { cmd, args } = this;
    return _Object$assign(e, { cmd, args }, o);
  }

  cmdString() {
    const { cmd, args } = this;
    return `${cmd || ''} ${Array.isArray(args) ? args.join('\x20') : ''}`;
  }
}
SpawnAsync.optionsProperties = _Object$keys({ timeout: 1 });

let spawnCapture = (() => {
  var _ref = _asyncToGenerator(function* (o) {
    const spawnAsync = new SpawnAsync(_extends$1({
      stderrFails: true
    }, o, {
      capture: true,
      options: _extends$1({
        timeout: 3e3,
        silent: true
      }, Object(o).options) }));
    const result = yield spawnAsync.startSpawn();
    const { stdout, stderr } = result;
    result.stdout = spawnAsync.trimEnd(stdout);
    result.stderr = spawnAsync.trimEnd(stderr);
    return result;
  });

  return function spawnCapture(_x) {
    return _ref.apply(this, arguments);
  };
})();

// simple mutable assign
function assign$3 () {
  const args = [].slice.call(arguments).filter(i => i);
  const dest = args.shift();
  args.forEach(src => {
    Object.keys(src).forEach(key => {
      dest[key] = src[key];
    });
  });

  return dest
}

var assign_1 = assign$3;

var fromCallback = function (fn) {
  return Object.defineProperty(function () {
    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments);
    else {
      return new Promise((resolve, reject) => {
        arguments[arguments.length] = (err, res) => {
          if (err) return reject(err)
          resolve(res);
        };
        arguments.length++;
        fn.apply(this, arguments);
      })
    }
  }, 'name', { value: fn.name })
};

var fromPromise = function (fn) {
  return Object.defineProperty(function () {
    const cb = arguments[arguments.length - 1];
    if (typeof cb !== 'function') return fn.apply(this, arguments)
    else fn.apply(this, arguments).then(r => cb(null, r), cb);
  }, 'name', { value: fn.name })
};

var universalify = {
	fromCallback: fromCallback,
	fromPromise: fromPromise
};

var fs_1 = clone(fs);

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: obj.__proto__ };
  else
    var copy = Object.create(null);

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });

  return copy
}

var origCwd = process.cwd;
var cwd = null;

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd
};
try {
  process.cwd();
} catch (er) {}

var chdir = process.chdir;
process.chdir = function(d) {
  cwd = null;
  chdir.call(process, d);
};

var polyfills = patch;

function patch (fs$$1) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs$$1);
  }

  // lutimes implementation, or no-op
  if (!fs$$1.lutimes) {
    patchLutimes(fs$$1);
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs$$1.chown = chownFix(fs$$1.chown);
  fs$$1.fchown = chownFix(fs$$1.fchown);
  fs$$1.lchown = chownFix(fs$$1.lchown);

  fs$$1.chmod = chmodFix(fs$$1.chmod);
  fs$$1.fchmod = chmodFix(fs$$1.fchmod);
  fs$$1.lchmod = chmodFix(fs$$1.lchmod);

  fs$$1.chownSync = chownFixSync(fs$$1.chownSync);
  fs$$1.fchownSync = chownFixSync(fs$$1.fchownSync);
  fs$$1.lchownSync = chownFixSync(fs$$1.lchownSync);

  fs$$1.chmodSync = chmodFixSync(fs$$1.chmodSync);
  fs$$1.fchmodSync = chmodFixSync(fs$$1.fchmodSync);
  fs$$1.lchmodSync = chmodFixSync(fs$$1.lchmodSync);

  fs$$1.stat = statFix(fs$$1.stat);
  fs$$1.fstat = statFix(fs$$1.fstat);
  fs$$1.lstat = statFix(fs$$1.lstat);

  fs$$1.statSync = statFixSync(fs$$1.statSync);
  fs$$1.fstatSync = statFixSync(fs$$1.fstatSync);
  fs$$1.lstatSync = statFixSync(fs$$1.lstatSync);

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs$$1.lchmod) {
    fs$$1.lchmod = function (path$$1, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs$$1.lchmodSync = function () {};
  }
  if (!fs$$1.lchown) {
    fs$$1.lchown = function (path$$1, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs$$1.lchownSync = function () {};
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs$$1.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now();
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs$$1.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er);
            });
          }, backoff);
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er);
      });
    }})(fs$$1.rename);
  }

  // if read() returns EAGAIN, then just try it again.
  fs$$1.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {
    var callback;
    if (callback_ && typeof callback_ === 'function') {
      var eagCounter = 0;
      callback = function (er, _, __) {
        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++;
          return fs$read.call(fs$$1, fd, buffer, offset, length, position, callback)
        }
        callback_.apply(this, arguments);
      };
    }
    return fs$read.call(fs$$1, fd, buffer, offset, length, position, callback)
  }})(fs$$1.read);

  fs$$1.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0;
    while (true) {
      try {
        return fs$readSync.call(fs$$1, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++;
          continue
        }
        throw er
      }
    }
  }})(fs$$1.readSync);
}

function patchLchmod (fs$$1) {
  fs$$1.lchmod = function (path$$1, mode, callback) {
    fs$$1.open( path$$1
           , constants.O_WRONLY | constants.O_SYMLINK
           , mode
           , function (err, fd) {
      if (err) {
        if (callback) callback(err);
        return
      }
      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      fs$$1.fchmod(fd, mode, function (err) {
        fs$$1.close(fd, function(err2) {
          if (callback) callback(err || err2);
        });
      });
    });
  };

  fs$$1.lchmodSync = function (path$$1, mode) {
    var fd = fs$$1.openSync(path$$1, constants.O_WRONLY | constants.O_SYMLINK, mode);

    // prefer to return the chmod error, if one occurs,
    // but still try to close, and report closing errors if they occur.
    var threw = true;
    var ret;
    try {
      ret = fs$$1.fchmodSync(fd, mode);
      threw = false;
    } finally {
      if (threw) {
        try {
          fs$$1.closeSync(fd);
        } catch (er) {}
      } else {
        fs$$1.closeSync(fd);
      }
    }
    return ret
  };
}

function patchLutimes (fs$$1) {
  if (constants.hasOwnProperty("O_SYMLINK")) {
    fs$$1.lutimes = function (path$$1, at, mt, cb) {
      fs$$1.open(path$$1, constants.O_SYMLINK, function (er, fd) {
        if (er) {
          if (cb) cb(er);
          return
        }
        fs$$1.futimes(fd, at, mt, function (er) {
          fs$$1.close(fd, function (er2) {
            if (cb) cb(er || er2);
          });
        });
      });
    };

    fs$$1.lutimesSync = function (path$$1, at, mt) {
      var fd = fs$$1.openSync(path$$1, constants.O_SYMLINK);
      var ret;
      var threw = true;
      try {
        ret = fs$$1.futimesSync(fd, at, mt);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs$$1.closeSync(fd);
          } catch (er) {}
        } else {
          fs$$1.closeSync(fd);
        }
      }
      return ret
    };

  } else {
    fs$$1.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb); };
    fs$$1.lutimesSync = function () {};
  }
}

function chmodFix (orig) {
  if (!orig) return orig
  return function (target, mode, cb) {
    return orig.call(fs_1, target, mode, function (er) {
      if (chownErOk(er)) er = null;
      if (cb) cb.apply(this, arguments);
    })
  }
}

function chmodFixSync (orig) {
  if (!orig) return orig
  return function (target, mode) {
    try {
      return orig.call(fs_1, target, mode)
    } catch (er) {
      if (!chownErOk(er)) throw er
    }
  }
}


function chownFix (orig) {
  if (!orig) return orig
  return function (target, uid, gid, cb) {
    return orig.call(fs_1, target, uid, gid, function (er) {
      if (chownErOk(er)) er = null;
      if (cb) cb.apply(this, arguments);
    })
  }
}

function chownFixSync (orig) {
  if (!orig) return orig
  return function (target, uid, gid) {
    try {
      return orig.call(fs_1, target, uid, gid)
    } catch (er) {
      if (!chownErOk(er)) throw er
    }
  }
}


function statFix (orig) {
  if (!orig) return orig
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target, cb) {
    return orig.call(fs_1, target, function (er, stats) {
      if (!stats) return cb.apply(this, arguments)
      if (stats.uid < 0) stats.uid += 0x100000000;
      if (stats.gid < 0) stats.gid += 0x100000000;
      if (cb) cb.apply(this, arguments);
    })
  }
}

function statFixSync (orig) {
  if (!orig) return orig
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target) {
    var stats = orig.call(fs_1, target);
    if (stats.uid < 0) stats.uid += 0x100000000;
    if (stats.gid < 0) stats.gid += 0x100000000;
    return stats;
  }
}

// ENOSYS means that the fs doesn't support the op. Just ignore
// that, because it doesn't matter.
//
// if there's no getuid, or if getuid() is something other
// than 0, and the error is EINVAL or EPERM, then just ignore
// it.
//
// This specific case is a silent failure in cp, install, tar,
// and most other unix tools that manage permissions.
//
// When running as root, or if other types of errors are
// encountered, then it's strict.
function chownErOk (er) {
  if (!er)
    return true

  if (er.code === "ENOSYS")
    return true

  var nonroot = !process.getuid || process.getuid() !== 0;
  if (nonroot) {
    if (er.code === "EINVAL" || er.code === "EPERM")
      return true
  }

  return false
}

var Stream$1 = stream.Stream;

var legacyStreams = legacy;

function legacy (fs$$1) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path$$1, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path$$1, options);

    Stream$1.call(this);

    var self = this;

    this.path = path$$1;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs$$1.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    });
  }

  function WriteStream (path$$1, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path$$1, options);

    Stream$1.call(this);

    this.path = path$$1;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs$$1.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

var gracefulFs = createCommonjsModule(function (module) {
var queue = [];



function noop () {}

var debug = noop;
if (util.debuglog)
  debug = util.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
  };

if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
  process.on('exit', function() {
    debug(queue);
    assert.equal(queue.length, 0);
  });
}

module.exports = patch(fs_1);
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
  module.exports = patch(fs);
}

// Always patch fs.close/closeSync, because we want to
// retry() whenever a close happens *anywhere* in the program.
// This is essential when multiple graceful-fs instances are
// in play at the same time.
module.exports.close =
fs.close = (function (fs$close) { return function (fd, cb) {
  return fs$close.call(fs, fd, function (err) {
    if (!err)
      retry();

    if (typeof cb === 'function')
      cb.apply(this, arguments);
  })
}})(fs.close);

module.exports.closeSync =
fs.closeSync = (function (fs$closeSync) { return function (fd) {
  // Note that graceful-fs also retries when fs.closeSync() fails.
  // Looks like a bug to me, although it's probably a harmless one.
  var rval = fs$closeSync.apply(fs, arguments);
  retry();
  return rval
}})(fs.closeSync);

function patch (fs$$1) {
  // Everything that references the open() function needs to be in here
  polyfills(fs$$1);
  fs$$1.gracefulify = patch;
  fs$$1.FileReadStream = ReadStream;  // Legacy name.
  fs$$1.FileWriteStream = WriteStream;  // Legacy name.
  fs$$1.createReadStream = createReadStream;
  fs$$1.createWriteStream = createWriteStream;
  var fs$readFile = fs$$1.readFile;
  fs$$1.readFile = readFile;
  function readFile (path$$1, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$readFile(path$$1, options, cb)

    function go$readFile (path$$1, options, cb) {
      return fs$readFile(path$$1, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path$$1, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$writeFile = fs$$1.writeFile;
  fs$$1.writeFile = writeFile;
  function writeFile (path$$1, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$writeFile(path$$1, data, options, cb)

    function go$writeFile (path$$1, data, options, cb) {
      return fs$writeFile(path$$1, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path$$1, data, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$appendFile = fs$$1.appendFile;
  if (fs$appendFile)
    fs$$1.appendFile = appendFile;
  function appendFile (path$$1, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$appendFile(path$$1, data, options, cb)

    function go$appendFile (path$$1, data, options, cb) {
      return fs$appendFile(path$$1, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path$$1, data, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$readdir = fs$$1.readdir;
  fs$$1.readdir = readdir;
  function readdir (path$$1, options, cb) {
    var args = [path$$1];
    if (typeof options !== 'function') {
      args.push(options);
    } else {
      cb = options;
    }
    args.push(go$readdir$cb);

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files && files.sort)
        files.sort();

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([go$readdir, [args]]);
      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments);
        retry();
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs$$1, args)
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacyStreams(fs$$1);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }

  var fs$ReadStream = fs$$1.ReadStream;
  ReadStream.prototype = Object.create(fs$ReadStream.prototype);
  ReadStream.prototype.open = ReadStream$open;

  var fs$WriteStream = fs$$1.WriteStream;
  WriteStream.prototype = Object.create(fs$WriteStream.prototype);
  WriteStream.prototype.open = WriteStream$open;

  fs$$1.ReadStream = ReadStream;
  fs$$1.WriteStream = WriteStream;

  function ReadStream (path$$1, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  }

  function WriteStream (path$$1, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  }

  function createReadStream (path$$1, options) {
    return new ReadStream(path$$1, options)
  }

  function createWriteStream (path$$1, options) {
    return new WriteStream(path$$1, options)
  }

  var fs$open = fs$$1.open;
  fs$$1.open = open;
  function open (path$$1, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null;

    return go$open(path$$1, flags, mode, cb)

    function go$open (path$$1, flags, mode, cb) {
      return fs$open(path$$1, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path$$1, flags, mode, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  return fs$$1
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1]);
  queue.push(elem);
}

function retry () {
  var elem = queue.shift();
  if (elem) {
    debug('RETRY', elem[0].name, elem[1]);
    elem[0].apply(null, elem[1]);
  }
}
});
var gracefulFs_1 = gracefulFs.close;
var gracefulFs_2 = gracefulFs.closeSync;

var fs_1$2 = createCommonjsModule(function (module, exports) {
// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = universalify.fromCallback;


const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchown',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'readFile',
  'readdir',
  'readlink',
  'realpath',
  'rename',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.copyFile was added in Node.js v8.5.0
  // fs.mkdtemp was added in Node.js v5.10.0
  // fs.lchown is not available on at least some Linux
  return typeof gracefulFs[key] === 'function'
});

// Export all keys:
Object.keys(gracefulFs).forEach(key => {
  exports[key] = gracefulFs[key];
});

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(gracefulFs[method]);
});

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return gracefulFs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return gracefulFs.exists(filename, resolve)
  })
};

// fs.read() & fs.write need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return gracefulFs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    gracefulFs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer });
    });
  })
};

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// so we need to handle both cases
exports.write = function (fd, buffer, a, b, c, callback) {
  if (typeof arguments[arguments.length - 1] === 'function') {
    return gracefulFs.write(fd, buffer, a, b, c, callback)
  }

  // Check for old, depricated fs.write(fd, string[, position[, encoding]], callback)
  if (typeof buffer === 'string') {
    return new Promise((resolve, reject) => {
      gracefulFs.write(fd, buffer, a, b, (err, bytesWritten, buffer) => {
        if (err) return reject(err)
        resolve({ bytesWritten, buffer });
      });
    })
  }

  return new Promise((resolve, reject) => {
    gracefulFs.write(fd, buffer, a, b, c, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer });
    });
  })
};
});
var fs_2 = fs_1$2.exists;
var fs_3 = fs_1$2.read;
var fs_4 = fs_1$2.write;

// get drive on windows
function getRootPath (p) {
  p = path.normalize(path.resolve(p)).split(path.sep);
  if (p.length > 0) return p[0]
  return null
}

// http://stackoverflow.com/a/62888/10333 contains more accurate
// TODO: expand to include the rest
const INVALID_PATH_CHARS = /[<>:"|?*]/;

function invalidWin32Path (p) {
  const rp = getRootPath(p);
  p = p.replace(rp, '');
  return INVALID_PATH_CHARS.test(p)
}

var win32 = {
  getRootPath,
  invalidWin32Path
};

const invalidWin32Path$1 = win32.invalidWin32Path;

const o777 = parseInt('0777', 8);

function mkdirs (p, opts, callback, made) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  } else if (!opts || typeof opts !== 'object') {
    opts = { mode: opts };
  }

  if (process.platform === 'win32' && invalidWin32Path$1(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.');
    errInval.code = 'EINVAL';
    return callback(errInval)
  }

  let mode = opts.mode;
  const xfs = opts.fs || gracefulFs;

  if (mode === undefined) {
    mode = o777 & (~process.umask());
  }
  if (!made) made = null;

  callback = callback || function () {};
  p = path.resolve(p);

  xfs.mkdir(p, mode, er => {
    if (!er) {
      made = made || p;
      return callback(null, made)
    }
    switch (er.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) return callback(er)
        mkdirs(path.dirname(p), opts, (er, made) => {
          if (er) callback(er, made);
          else mkdirs(p, opts, callback, made);
        });
        break

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) => {
          // if the stat fails, then that's super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made);
          else callback(null, made);
        });
        break
    }
  });
}

var mkdirs_1 = mkdirs;

const invalidWin32Path$2 = win32.invalidWin32Path;

const o777$1 = parseInt('0777', 8);

function mkdirsSync (p, opts, made) {
  if (!opts || typeof opts !== 'object') {
    opts = { mode: opts };
  }

  let mode = opts.mode;
  const xfs = opts.fs || gracefulFs;

  if (process.platform === 'win32' && invalidWin32Path$2(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.');
    errInval.code = 'EINVAL';
    throw errInval
  }

  if (mode === undefined) {
    mode = o777$1 & (~process.umask());
  }
  if (!made) made = null;

  p = path.resolve(p);

  try {
    xfs.mkdirSync(p, mode);
    made = made || p;
  } catch (err0) {
    switch (err0.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) throw err0
        made = mkdirsSync(path.dirname(p), opts, made);
        mkdirsSync(p, opts, made);
        break

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        let stat;
        try {
          stat = xfs.statSync(p);
        } catch (err1) {
          throw err0
        }
        if (!stat.isDirectory()) throw err0
        break
    }
  }

  return made
}

var mkdirsSync_1 = mkdirsSync;

const u = universalify.fromCallback;
const mkdirs$1 = u(mkdirs_1);


var mkdirs_1$2 = {
  mkdirs: mkdirs$1,
  mkdirsSync: mkdirsSync_1,
  // alias
  mkdirp: mkdirs$1,
  mkdirpSync: mkdirsSync_1,
  ensureDir: mkdirs$1,
  ensureDirSync: mkdirsSync_1
};

const u$1 = universalify.fromPromise;


function pathExists (path$$1) {
  return fs_1$2.access(path$$1).then(() => true).catch(() => false)
}

var pathExists_1 = {
  pathExists: u$1(pathExists),
  pathExistsSync: fs_1$2.existsSync
};

// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
function hasMillisResSync () {
  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2));
  tmpfile = path.join(os.tmpdir(), tmpfile);

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862);
  gracefulFs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141');
  const fd = gracefulFs.openSync(tmpfile, 'r+');
  gracefulFs.futimesSync(fd, d, d);
  gracefulFs.closeSync(fd);
  return gracefulFs.statSync(tmpfile).mtime > 1435410243000
}

function hasMillisRes (callback) {
  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2));
  tmpfile = path.join(os.tmpdir(), tmpfile);

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862);
  gracefulFs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {
    if (err) return callback(err)
    gracefulFs.open(tmpfile, 'r+', (err, fd) => {
      if (err) return callback(err)
      gracefulFs.futimes(fd, d, d, err => {
        if (err) return callback(err)
        gracefulFs.close(fd, err => {
          if (err) return callback(err)
          gracefulFs.stat(tmpfile, (err, stats) => {
            if (err) return callback(err)
            callback(null, stats.mtime > 1435410243000);
          });
        });
      });
    });
  });
}

function timeRemoveMillis (timestamp) {
  if (typeof timestamp === 'number') {
    return Math.floor(timestamp / 1000) * 1000
  } else if (timestamp instanceof Date) {
    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
  } else {
    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
  }
}

function utimesMillis (path$$1, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  gracefulFs.open(path$$1, 'r+', (err, fd) => {
    if (err) return callback(err)
    gracefulFs.futimes(fd, atime, mtime, futimesErr => {
      gracefulFs.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr);
      });
    });
  });
}

function utimesMillisSync (path$$1, atime, mtime) {
  const fd = gracefulFs.openSync(path$$1, 'r+');
  gracefulFs.futimesSync(fd, atime, mtime);
  return gracefulFs.closeSync(fd)
}

var utimes = {
  hasMillisRes,
  hasMillisResSync,
  timeRemoveMillis,
  utimesMillis,
  utimesMillisSync
};

const mkdirp = mkdirs_1$2.mkdirs;
const pathExists$1 = pathExists_1.pathExists;
const utimes$2 = utimes.utimesMillis;

const notExist = Symbol('notExist');
const existsReg = Symbol('existsReg');

function copy (src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === 'function') {
    opts = {filter: opts};
  }

  cb = cb || function () {};
  opts = opts || {};

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  src = path.resolve(src);
  dest = path.resolve(dest);

  // don't allow src and dest to be the same
  if (src === dest) return cb(new Error('Source and destination must not be the same.'))

  if (opts.filter) return handleFilter(checkParentDir, src, dest, opts, cb)
  return checkParentDir(src, dest, opts, cb)
}

function checkParentDir (src, dest, opts, cb) {
  const destParent = path.dirname(dest);
  pathExists$1(destParent, (err, dirExists) => {
    if (err) return cb(err)
    if (dirExists) return startCopy(src, dest, opts, cb)
    mkdirp(destParent, err => {
      if (err) return cb(err)
      return startCopy(src, dest, opts, cb)
    });
  });
}

function startCopy (src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, src, dest, opts, cb)
  return getStats(src, dest, opts, cb)
}

function handleFilter (onInclude, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest))
    .then(include => {
      if (include) return onInclude(src, dest, opts, cb)
      return cb()
    }, error => cb(error));
}

function getStats (src, dest, opts, cb) {
  const stat = opts.dereference ? gracefulFs.stat : gracefulFs.lstat;
  stat(src, (err, st) => {
    if (err) return cb(err)

    if (st.isDirectory()) return onDir(st, src, dest, opts, cb)
    else if (st.isFile() ||
             st.isCharacterDevice() ||
             st.isBlockDevice()) return onFile(st, src, dest, opts, cb)
    else if (st.isSymbolicLink()) return onLink(src, dest, opts, cb)
  });
}

function onFile (srcStat, src, dest, opts, cb) {
  checkDest(dest, (err, resolvedPath) => {
    if (err) return cb(err)
    if (resolvedPath === notExist) {
      return copyFile(srcStat, src, dest, opts, cb)
    } else if (resolvedPath === existsReg) {
      return mayCopyFile(srcStat, src, dest, opts, cb)
    } else {
      if (src === resolvedPath) return cb()
      return mayCopyFile(srcStat, src, dest, opts, cb)
    }
  });
}

function mayCopyFile (srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    gracefulFs.unlink(dest, err => {
      if (err) return cb(err)
      return copyFile(srcStat, src, dest, opts, cb)
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`))
  } else return cb()
}

function copyFile (srcStat, src, dest, opts, cb) {
  if (typeof gracefulFs.copyFile === 'function') {
    return gracefulFs.copyFile(src, dest, err => {
      if (err) return cb(err)
      return setDestModeAndTimestamps(srcStat, dest, opts, cb)
    })
  }
  return copyFileFallback(srcStat, src, dest, opts, cb)
}

function copyFileFallback (srcStat, src, dest, opts, cb) {
  const rs = gracefulFs.createReadStream(src);
  rs.on('error', err => cb(err))
    .once('open', () => {
      const ws = gracefulFs.createWriteStream(dest, { mode: srcStat.mode });
      ws.on('error', err => cb(err))
        .on('open', () => rs.pipe(ws))
        .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
    });
}

function setDestModeAndTimestamps (srcStat, dest, opts, cb) {
  gracefulFs.chmod(dest, srcStat.mode, err => {
    if (err) return cb(err)
    if (opts.preserveTimestamps) {
      return utimes$2(dest, srcStat.atime, srcStat.mtime, cb)
    }
    return cb()
  });
}

function onDir (srcStat, src, dest, opts, cb) {
  checkDest(dest, (err, resolvedPath) => {
    if (err) return cb(err)
    if (resolvedPath === notExist) {
      if (isSrcSubdir(src, dest)) {
        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`))
      }
      return mkDirAndCopy(srcStat, src, dest, opts, cb)
    } else if (resolvedPath === existsReg) {
      if (isSrcSubdir(src, dest)) {
        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`))
      }
      return mayCopyDir(src, dest, opts, cb)
    } else {
      if (src === resolvedPath) return cb()
      return copyDir(src, dest, opts, cb)
    }
  });
}

function mayCopyDir (src, dest, opts, cb) {
  gracefulFs.stat(dest, (err, st) => {
    if (err) return cb(err)
    if (!st.isDirectory()) {
      return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
    }
    return copyDir(src, dest, opts, cb)
  });
}

function mkDirAndCopy (srcStat, src, dest, opts, cb) {
  gracefulFs.mkdir(dest, srcStat.mode, err => {
    if (err) return cb(err)
    gracefulFs.chmod(dest, srcStat.mode, err => {
      if (err) return cb(err)
      return copyDir(src, dest, opts, cb)
    });
  });
}

function copyDir (src, dest, opts, cb) {
  gracefulFs.readdir(src, (err, items) => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  });
}

function copyDirItems (items, src, dest, opts, cb) {
  const item = items.pop();
  if (!item) return cb()
  startCopy(path.join(src, item), path.join(dest, item), opts, err => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  });
}

function onLink (src, dest, opts, cb) {
  gracefulFs.readlink(src, (err, resolvedSrcPath) => {
    if (err) return cb(err)

    if (opts.dereference) {
      resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath);
    }

    checkDest(dest, (err, resolvedDestPath) => {
      if (err) return cb(err)

      if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {
        // if dest already exists, fs throws error anyway,
        // so no need to guard against it here.
        return gracefulFs.symlink(resolvedSrcPath, dest, cb)
      } else {
        if (opts.dereference) {
          resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath);
        }
        if (resolvedDestPath === resolvedSrcPath) return cb()

        // prevent copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        gracefulFs.stat(dest, (err, st) => {
          if (err) return cb(err)
          if (st.isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {
            return cb(new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`))
          }
          return copyLink(resolvedSrcPath, dest, cb)
        });
      }
    });
  });
}

function copyLink (resolvedSrcPath, dest, cb) {
  gracefulFs.unlink(dest, err => {
    if (err) return cb(err)
    return gracefulFs.symlink(resolvedSrcPath, dest, cb)
  });
}

// check if dest exists and/or is a symlink
function checkDest (dest, cb) {
  gracefulFs.readlink(dest, (err, resolvedPath) => {
    if (err) {
      if (err.code === 'ENOENT') return cb(null, notExist)

      // dest exists and is a regular file or directory, Windows may throw UNKNOWN error.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return cb(null, existsReg)

      return cb(err)
    }
    return cb(null, resolvedPath) // dest exists and is a symlink
  });
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir (src, dest) {
  const baseDir = dest.split(path.dirname(src) + path.sep)[1];
  if (baseDir) {
    const destBasename = baseDir.split(path.sep)[0];
    if (destBasename) {
      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src)
    }
    return false
  }
  return false
}

var copy_1 = copy;

const u$2 = universalify.fromCallback;
var copy$2 = {
  copy: u$2(copy_1)
};

/* eslint-disable node/no-deprecated-api */
var buffer = function (size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    try {
      return Buffer.allocUnsafe(size)
    } catch (e) {
      return new Buffer(size)
    }
  }
  return new Buffer(size)
};

const mkdirpSync = mkdirs_1$2.mkdirsSync;
const utimesSync = utimes.utimesMillisSync;

const notExist$1 = Symbol('notExist');
const existsReg$1 = Symbol('existsReg');

function copySync (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = {filter: opts};
  }

  opts = opts || {};
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  src = path.resolve(src);
  dest = path.resolve(dest);

  // don't allow src and dest to be the same
  if (src === dest) throw new Error('Source and destination must not be the same.')

  if (opts.filter && !opts.filter(src, dest)) return

  const destParent = path.dirname(dest);
  if (!gracefulFs.existsSync(destParent)) mkdirpSync(destParent);
  return startCopy$1(src, dest, opts)
}

function startCopy$1 (src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats$1(src, dest, opts)
}

function getStats$1 (src, dest, opts) {
  const statSync = opts.dereference ? gracefulFs.statSync : gracefulFs.lstatSync;
  const st = statSync(src);

  if (st.isDirectory()) return onDir$1(st, src, dest, opts)
  else if (st.isFile() ||
           st.isCharacterDevice() ||
           st.isBlockDevice()) return onFile$1(st, src, dest, opts)
  else if (st.isSymbolicLink()) return onLink$1(src, dest, opts)
}

function onFile$1 (srcStat, src, dest, opts) {
  const resolvedPath = checkDest$1(dest);
  if (resolvedPath === notExist$1) {
    return copyFile$1(srcStat, src, dest, opts)
  } else if (resolvedPath === existsReg$1) {
    return mayCopyFile$1(srcStat, src, dest, opts)
  } else {
    if (src === resolvedPath) return
    return mayCopyFile$1(srcStat, src, dest, opts)
  }
}

function mayCopyFile$1 (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    gracefulFs.unlinkSync(dest);
    return copyFile$1(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile$1 (srcStat, src, dest, opts) {
  if (typeof gracefulFs.copyFileSync === 'function') {
    gracefulFs.copyFileSync(src, dest);
    gracefulFs.chmodSync(dest, srcStat.mode);
    if (opts.preserveTimestamps) {
      return utimesSync(dest, srcStat.atime, srcStat.mtime)
    }
    return
  }
  return copyFileFallback$1(srcStat, src, dest, opts)
}

function copyFileFallback$1 (srcStat, src, dest, opts) {
  const BUF_LENGTH = 64 * 1024;
  const _buff = buffer(BUF_LENGTH);

  const fdr = gracefulFs.openSync(src, 'r');
  const fdw = gracefulFs.openSync(dest, 'w', srcStat.mode);
  let bytesRead = 1;
  let pos = 0;

  while (bytesRead > 0) {
    bytesRead = gracefulFs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
    gracefulFs.writeSync(fdw, _buff, 0, bytesRead);
    pos += bytesRead;
  }

  if (opts.preserveTimestamps) gracefulFs.futimesSync(fdw, srcStat.atime, srcStat.mtime);

  gracefulFs.closeSync(fdr);
  gracefulFs.closeSync(fdw);
}

function onDir$1 (srcStat, src, dest, opts) {
  const resolvedPath = checkDest$1(dest);
  if (resolvedPath === notExist$1) {
    if (isSrcSubdir$1(src, dest)) {
      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`)
    }
    return mkDirAndCopy$1(srcStat, src, dest, opts)
  } else if (resolvedPath === existsReg$1) {
    if (isSrcSubdir$1(src, dest)) {
      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`)
    }
    return mayCopyDir$1(src, dest, opts)
  } else {
    if (src === resolvedPath) return
    return copyDir$1(src, dest, opts)
  }
}

function mayCopyDir$1 (src, dest, opts) {
  if (!gracefulFs.statSync(dest).isDirectory()) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
  }
  return copyDir$1(src, dest, opts)
}

function mkDirAndCopy$1 (srcStat, src, dest, opts) {
  gracefulFs.mkdirSync(dest, srcStat.mode);
  gracefulFs.chmodSync(dest, srcStat.mode);
  return copyDir$1(src, dest, opts)
}

function copyDir$1 (src, dest, opts) {
  gracefulFs.readdirSync(src).forEach(item => {
    startCopy$1(path.join(src, item), path.join(dest, item), opts);
  });
}

function onLink$1 (src, dest, opts) {
  let resolvedSrcPath = gracefulFs.readlinkSync(src);

  if (opts.dereference) {
    resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath);
  }

  let resolvedDestPath = checkDest$1(dest);
  if (resolvedDestPath === notExist$1 || resolvedDestPath === existsReg$1) {
    // if dest already exists, fs throws error anyway,
    // so no need to guard against it here.
    return gracefulFs.symlinkSync(resolvedSrcPath, dest)
  } else {
    if (opts.dereference) {
      resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath);
    }
    if (resolvedDestPath === resolvedSrcPath) return

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (gracefulFs.statSync(dest).isDirectory() && isSrcSubdir$1(resolvedDestPath, resolvedSrcPath)) {
      throw new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`)
    }
    return copyLink$1(resolvedSrcPath, dest)
  }
}

function copyLink$1 (resolvedSrcPath, dest) {
  gracefulFs.unlinkSync(dest);
  return gracefulFs.symlinkSync(resolvedSrcPath, dest)
}

// check if dest exists and/or is a symlink
function checkDest$1 (dest) {
  let resolvedPath;
  try {
    resolvedPath = gracefulFs.readlinkSync(dest);
  } catch (err) {
    if (err.code === 'ENOENT') return notExist$1

    // dest exists and is a regular file or directory, Windows may throw UNKNOWN error
    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return existsReg$1

    throw err
  }
  return resolvedPath // dest exists and is a symlink
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir$1 (src, dest) {
  const baseDir = dest.split(path.dirname(src) + path.sep)[1];
  if (baseDir) {
    const destBasename = baseDir.split(path.sep)[0];
    if (destBasename) {
      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src)
    }
    return false
  }
  return false
}

var copySync_1 = copySync;

var copySync$1 = {
  copySync: copySync_1
};

const isWindows = (process.platform === 'win32');

function defaults (options) {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ];
  methods.forEach(m => {
    options[m] = options[m] || gracefulFs[m];
    m = m + 'Sync';
    options[m] = options[m] || gracefulFs[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
}

function rimraf (p, options, cb) {
  let busyTries = 0;

  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert.equal(typeof cb, 'function', 'rimraf: callback function required');
  assert(options, 'rimraf: invalid options argument provided');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  defaults(options);

  rimraf_(p, options, function CB (er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) {
        busyTries++;
        let time = busyTries * 100;
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
      }

      // already gone
      if (er.code === 'ENOENT') er = null;
    }

    cb(er);
  });
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null)
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb)
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb)
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null)
        }
        if (er.code === 'EPERM') {
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb)
        }
      }
      return cb(er)
    });
  });
}

function fixWinEPERM (p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');
  if (er) {
    assert(er instanceof Error);
  }

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}

function fixWinEPERMSync (p, options, er) {
  let stats;

  assert(p);
  assert(options);
  if (er) {
    assert(er instanceof Error);
  }

  try {
    options.chmodSync(p, 0o666);
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}

function rmdir (p, options, originalEr, cb) {
  assert(p);
  assert(options);
  if (originalEr) {
    assert(originalEr instanceof Error);
  }
  assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb);
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}

function rmkids (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.readdir(p, (er, files) => {
    if (er) return cb(er)

    let n = files.length;
    let errState;

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState) {
          return
        }
        if (er) return cb(errState = er)
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  let st;

  options = options || {};
  defaults(options);

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert(options, 'rimraf: missing options');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    } else if (er.code !== 'EISDIR') {
      throw er
    }
    rmdirSync(p, options, er);
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p);
  assert(options);
  if (originalEr) {
    assert(originalEr instanceof Error);
  }

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options);
    } else if (er.code !== 'ENOENT') {
      throw er
    }
  }
}

function rmkidsSync (p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options));

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  const retries = isWindows ? 100 : 1;
  let i = 0;
  do {
    let threw = true;
    try {
      const ret = options.rmdirSync(p, options);
      threw = false;
      return ret
    } finally {
      if (++i < retries && threw) continue // eslint-disable-line
    }
  } while (true)
}

var rimraf_1 = rimraf;
rimraf.sync = rimrafSync;

const u$3 = universalify.fromCallback;


var remove = {
  remove: u$3(rimraf_1),
  removeSync: rimraf_1.sync
};

var _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = fs;
}

function readFile (file, options, callback) {
  if (callback == null) {
    callback = options;
    options = {};
  }

  if (typeof options === 'string') {
    options = {encoding: options};
  }

  options = options || {};
  var fs$$1 = options.fs || _fs;

  var shouldThrow = true;
  if ('throws' in options) {
    shouldThrow = options.throws;
  }

  fs$$1.readFile(file, options, function (err, data) {
    if (err) return callback(err)

    data = stripBom(data);

    var obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + ': ' + err2.message;
        return callback(err2)
      } else {
        return callback(null, null)
      }
    }

    callback(null, obj);
  });
}

function readFileSync (file, options) {
  options = options || {};
  if (typeof options === 'string') {
    options = {encoding: options};
  }

  var fs$$1 = options.fs || _fs;

  var shouldThrow = true;
  if ('throws' in options) {
    shouldThrow = options.throws;
  }

  try {
    var content = fs$$1.readFileSync(file, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = file + ': ' + err.message;
      throw err
    } else {
      return null
    }
  }
}

function stringify (obj, options) {
  var spaces;
  var EOL = '\n';
  if (typeof options === 'object' && options !== null) {
    if (options.spaces) {
      spaces = options.spaces;
    }
    if (options.EOL) {
      EOL = options.EOL;
    }
  }

  var str = JSON.stringify(obj, options ? options.replacer : null, spaces);

  return str.replace(/\n/g, EOL) + EOL
}

function writeFile (file, obj, options, callback) {
  if (callback == null) {
    callback = options;
    options = {};
  }
  options = options || {};
  var fs$$1 = options.fs || _fs;

  var str = '';
  try {
    str = stringify(obj, options);
  } catch (err) {
    // Need to return whether a callback was passed or not
    if (callback) callback(err, null);
    return
  }

  fs$$1.writeFile(file, str, options, callback);
}

function writeFileSync (file, obj, options) {
  options = options || {};
  var fs$$1 = options.fs || _fs;

  var str = stringify(obj, options);
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs$$1.writeFileSync(file, str, options)
}

function stripBom (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8');
  content = content.replace(/^\uFEFF/, '');
  return content
}

var jsonfile = {
  readFile: readFile,
  readFileSync: readFileSync,
  writeFile: writeFile,
  writeFileSync: writeFileSync
};

var jsonfile_1 = jsonfile;

const u$4 = universalify.fromCallback;


var jsonfile$1 = {
  // jsonfile exports
  readJson: u$4(jsonfile_1.readFile),
  readJsonSync: jsonfile_1.readFileSync,
  writeJson: u$4(jsonfile_1.writeFile),
  writeJsonSync: jsonfile_1.writeFileSync
};

const pathExists$2 = pathExists_1.pathExists;


function outputJson (file, data, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const dir = path.dirname(file);

  pathExists$2(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return jsonfile$1.writeJson(file, data, options, callback)

    mkdirs_1$2.mkdirs(dir, err => {
      if (err) return callback(err)
      jsonfile$1.writeJson(file, data, options, callback);
    });
  });
}

var outputJson_1 = outputJson;

function outputJsonSync (file, data, options) {
  const dir = path.dirname(file);

  if (!gracefulFs.existsSync(dir)) {
    mkdirs_1$2.mkdirsSync(dir);
  }

  jsonfile$1.writeJsonSync(file, data, options);
}

var outputJsonSync_1 = outputJsonSync;

const u$5 = universalify.fromCallback;


jsonfile$1.outputJson = u$5(outputJson_1);
jsonfile$1.outputJsonSync = outputJsonSync_1;
// aliases
jsonfile$1.outputJSON = jsonfile$1.outputJson;
jsonfile$1.outputJSONSync = jsonfile$1.outputJsonSync;
jsonfile$1.writeJSON = jsonfile$1.writeJson;
jsonfile$1.writeJSONSync = jsonfile$1.writeJsonSync;
jsonfile$1.readJSON = jsonfile$1.readJson;
jsonfile$1.readJSONSync = jsonfile$1.readJsonSync;

var json = jsonfile$1;

// most of this code was written by Andrew Kelley
// licensed under the BSD license: see
// https://github.com/andrewrk/node-mv/blob/master/package.json

// this needs a cleanup

const u$6 = universalify.fromCallback;



const remove$3 = remove.remove;
const mkdirp$1 = mkdirs_1$2.mkdirs;

function move (src, dest, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const overwrite = options.overwrite || options.clobber || false;

  isSrcSubdir$2(src, dest, (err, itIs) => {
    if (err) return callback(err)
    if (itIs) return callback(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`))
    mkdirp$1(path.dirname(dest), err => {
      if (err) return callback(err)
      doRename();
    });
  });

  function doRename () {
    if (path.resolve(src) === path.resolve(dest)) {
      gracefulFs.access(src, callback);
    } else if (overwrite) {
      gracefulFs.rename(src, dest, err => {
        if (!err) return callback()

        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST') {
          remove$3(dest, err => {
            if (err) return callback(err)
            options.overwrite = false; // just overwriteed it, no need to do it again
            move(src, dest, options, callback);
          });
          return
        }

        // weird Windows shit
        if (err.code === 'EPERM') {
          setTimeout(() => {
            remove$3(dest, err => {
              if (err) return callback(err)
              options.overwrite = false;
              move(src, dest, options, callback);
            });
          }, 200);
          return
        }

        if (err.code !== 'EXDEV') return callback(err)
        moveAcrossDevice(src, dest, overwrite, callback);
      });
    } else {
      gracefulFs.link(src, dest, err => {
        if (err) {
          if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
            return moveAcrossDevice(src, dest, overwrite, callback)
          }
          return callback(err)
        }
        return gracefulFs.unlink(src, callback)
      });
    }
  }
}

function moveAcrossDevice (src, dest, overwrite, callback) {
  gracefulFs.stat(src, (err, stat) => {
    if (err) return callback(err)

    if (stat.isDirectory()) {
      moveDirAcrossDevice(src, dest, overwrite, callback);
    } else {
      moveFileAcrossDevice(src, dest, overwrite, callback);
    }
  });
}

function moveFileAcrossDevice (src, dest, overwrite, callback) {
  const flags = overwrite ? 'w' : 'wx';
  const ins = gracefulFs.createReadStream(src);
  const outs = gracefulFs.createWriteStream(dest, { flags });

  ins.on('error', err => {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);

    // may want to create a directory but `out` line above
    // creates an empty file for us: See #108
    // don't care about error here
    gracefulFs.unlink(dest, () => {
      // note: `err` here is from the input stream errror
      if (err.code === 'EISDIR' || err.code === 'EPERM') {
        moveDirAcrossDevice(src, dest, overwrite, callback);
      } else {
        callback(err);
      }
    });
  });

  outs.on('error', err => {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);
    callback(err);
  });

  outs.once('close', onClose);
  ins.pipe(outs);

  function onClose () {
    gracefulFs.unlink(src, callback);
  }
}

function moveDirAcrossDevice (src, dest, overwrite, callback) {
  const options = {
    overwrite: false
  };

  if (overwrite) {
    remove$3(dest, err => {
      if (err) return callback(err)
      startCopy();
    });
  } else {
    startCopy();
  }

  function startCopy () {
    copy_1(src, dest, options, err => {
      if (err) return callback(err)
      remove$3(src, callback);
    });
  }
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir$2 (src, dest, cb) {
  gracefulFs.stat(src, (err, st) => {
    if (err) return cb(err)
    if (st.isDirectory()) {
      const baseDir = dest.split(path.dirname(src) + path.sep)[1];
      if (baseDir) {
        const destBasename = baseDir.split(path.sep)[0];
        if (destBasename) return cb(null, src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src))
        return cb(null, false)
      }
      return cb(null, false)
    }
    return cb(null, false)
  });
}

var move_1 = {
  move: u$6(move)
};

const copySync$3 = copySync$1.copySync;
const removeSync = remove.removeSync;
const mkdirpSync$1 = mkdirs_1$2.mkdirsSync;


function moveSync (src, dest, options) {
  options = options || {};
  const overwrite = options.overwrite || options.clobber || false;

  src = path.resolve(src);
  dest = path.resolve(dest);

  if (src === dest) return gracefulFs.accessSync(src)

  if (isSrcSubdir$3(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`)

  mkdirpSync$1(path.dirname(dest));
  tryRenameSync();

  function tryRenameSync () {
    if (overwrite) {
      try {
        return gracefulFs.renameSync(src, dest)
      } catch (err) {
        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {
          removeSync(dest);
          options.overwrite = false; // just overwriteed it, no need to do it again
          return moveSync(src, dest, options)
        }

        if (err.code !== 'EXDEV') throw err
        return moveSyncAcrossDevice(src, dest, overwrite)
      }
    } else {
      try {
        gracefulFs.linkSync(src, dest);
        return gracefulFs.unlinkSync(src)
      } catch (err) {
        if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
          return moveSyncAcrossDevice(src, dest, overwrite)
        }
        throw err
      }
    }
  }
}

function moveSyncAcrossDevice (src, dest, overwrite) {
  const stat = gracefulFs.statSync(src);

  if (stat.isDirectory()) {
    return moveDirSyncAcrossDevice(src, dest, overwrite)
  } else {
    return moveFileSyncAcrossDevice(src, dest, overwrite)
  }
}

function moveFileSyncAcrossDevice (src, dest, overwrite) {
  const BUF_LENGTH = 64 * 1024;
  const _buff = buffer(BUF_LENGTH);

  const flags = overwrite ? 'w' : 'wx';

  const fdr = gracefulFs.openSync(src, 'r');
  const stat = gracefulFs.fstatSync(fdr);
  const fdw = gracefulFs.openSync(dest, flags, stat.mode);
  let bytesRead = 1;
  let pos = 0;

  while (bytesRead > 0) {
    bytesRead = gracefulFs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
    gracefulFs.writeSync(fdw, _buff, 0, bytesRead);
    pos += bytesRead;
  }

  gracefulFs.closeSync(fdr);
  gracefulFs.closeSync(fdw);
  return gracefulFs.unlinkSync(src)
}

function moveDirSyncAcrossDevice (src, dest, overwrite) {
  const options = {
    overwrite: false
  };

  if (overwrite) {
    removeSync(dest);
    tryCopySync();
  } else {
    tryCopySync();
  }

  function tryCopySync () {
    copySync$3(src, dest, options);
    return removeSync(src)
  }
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir$3 (src, dest) {
  try {
    return gracefulFs.statSync(src).isDirectory() &&
           src !== dest &&
           dest.indexOf(src) > -1 &&
           dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src)
  } catch (e) {
    return false
  }
}

var moveSync_1 = {
  moveSync
};

const u$7 = universalify.fromCallback;





const emptyDir = u$7(function emptyDir (dir, callback) {
  callback = callback || function () {};
  fs.readdir(dir, (err, items) => {
    if (err) return mkdirs_1$2.mkdirs(dir, callback)

    items = items.map(item => path.join(dir, item));

    deleteItem();

    function deleteItem () {
      const item = items.pop();
      if (!item) return callback()
      remove.remove(item, err => {
        if (err) return callback(err)
        deleteItem();
      });
    }
  });
});

function emptyDirSync (dir) {
  let items;
  try {
    items = fs.readdirSync(dir);
  } catch (err) {
    return mkdirs_1$2.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path.join(dir, item);
    remove.removeSync(item);
  });
}

var empty$1 = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};

const u$8 = universalify.fromCallback;



const pathExists$3 = pathExists_1.pathExists;

function createFile (file, callback) {
  function makeFile () {
    gracefulFs.writeFile(file, '', err => {
      if (err) return callback(err)
      callback();
    });
  }

  gracefulFs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback()
    const dir = path.dirname(file);
    pathExists$3(dir, (err, dirExists) => {
      if (err) return callback(err)
      if (dirExists) return makeFile()
      mkdirs_1$2.mkdirs(dir, err => {
        if (err) return callback(err)
        makeFile();
      });
    });
  });
}

function createFileSync (file) {
  let stats;
  try {
    stats = gracefulFs.statSync(file);
  } catch (e) {}
  if (stats && stats.isFile()) return

  const dir = path.dirname(file);
  if (!gracefulFs.existsSync(dir)) {
    mkdirs_1$2.mkdirsSync(dir);
  }

  gracefulFs.writeFileSync(file, '');
}

var file = {
  createFile: u$8(createFile),
  createFileSync
};

const u$9 = universalify.fromCallback;



const pathExists$4 = pathExists_1.pathExists;

function createLink (srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    gracefulFs.link(srcpath, dstpath, err => {
      if (err) return callback(err)
      callback(null);
    });
  }

  pathExists$4(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    gracefulFs.lstat(srcpath, (err, stat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        return callback(err)
      }

      const dir = path.dirname(dstpath);
      pathExists$4(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdirs_1$2.mkdirs(dir, err => {
          if (err) return callback(err)
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}

function createLinkSync (srcpath, dstpath, callback) {
  const destinationExists = gracefulFs.existsSync(dstpath);
  if (destinationExists) return undefined

  try {
    gracefulFs.lstatSync(srcpath);
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink');
    throw err
  }

  const dir = path.dirname(dstpath);
  const dirExists = gracefulFs.existsSync(dir);
  if (dirExists) return gracefulFs.linkSync(srcpath, dstpath)
  mkdirs_1$2.mkdirsSync(dir);

  return gracefulFs.linkSync(srcpath, dstpath)
}

var link = {
  createLink: u$9(createLink),
  createLinkSync
};

const pathExists$5 = pathExists_1.pathExists;

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths (srcpath, dstpath, callback) {
  if (path.isAbsolute(srcpath)) {
    return gracefulFs.lstat(srcpath, (err, stat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink');
        return callback(err)
      }
      return callback(null, {
        'toCwd': srcpath,
        'toDst': srcpath
      })
    })
  } else {
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    return pathExists$5(relativeToDst, (err, exists) => {
      if (err) return callback(err)
      if (exists) {
        return callback(null, {
          'toCwd': relativeToDst,
          'toDst': srcpath
        })
      } else {
        return gracefulFs.lstat(srcpath, (err, stat) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink');
            return callback(err)
          }
          return callback(null, {
            'toCwd': srcpath,
            'toDst': path.relative(dstdir, srcpath)
          })
        })
      }
    })
  }
}

function symlinkPathsSync (srcpath, dstpath) {
  let exists;
  if (path.isAbsolute(srcpath)) {
    exists = gracefulFs.existsSync(srcpath);
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      'toCwd': srcpath,
      'toDst': srcpath
    }
  } else {
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    exists = gracefulFs.existsSync(relativeToDst);
    if (exists) {
      return {
        'toCwd': relativeToDst,
        'toDst': srcpath
      }
    } else {
      exists = gracefulFs.existsSync(srcpath);
      if (!exists) throw new Error('relative srcpath does not exist')
      return {
        'toCwd': srcpath,
        'toDst': path.relative(dstdir, srcpath)
      }
    }
  }
}

var symlinkPaths_1 = {
  symlinkPaths,
  symlinkPathsSync
};

function symlinkType (srcpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;
  if (type) return callback(null, type)
  gracefulFs.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file')
    type = (stats && stats.isDirectory()) ? 'dir' : 'file';
    callback(null, type);
  });
}

function symlinkTypeSync (srcpath, type) {
  let stats;

  if (type) return type
  try {
    stats = gracefulFs.lstatSync(srcpath);
  } catch (e) {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

var symlinkType_1 = {
  symlinkType,
  symlinkTypeSync
};

const u$10 = universalify.fromCallback;



const mkdirs$2 = mkdirs_1$2.mkdirs;
const mkdirsSync$2 = mkdirs_1$2.mkdirsSync;


const symlinkPaths$1 = symlinkPaths_1.symlinkPaths;
const symlinkPathsSync$1 = symlinkPaths_1.symlinkPathsSync;


const symlinkType$1 = symlinkType_1.symlinkType;
const symlinkTypeSync$1 = symlinkType_1.symlinkTypeSync;

const pathExists$6 = pathExists_1.pathExists;

function createSymlink (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;

  pathExists$6(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    symlinkPaths$1(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err)
      srcpath = relative.toDst;
      symlinkType$1(relative.toCwd, type, (err, type) => {
        if (err) return callback(err)
        const dir = path.dirname(dstpath);
        pathExists$6(dir, (err, dirExists) => {
          if (err) return callback(err)
          if (dirExists) return gracefulFs.symlink(srcpath, dstpath, type, callback)
          mkdirs$2(dir, err => {
            if (err) return callback(err)
            gracefulFs.symlink(srcpath, dstpath, type, callback);
          });
        });
      });
    });
  });
}

function createSymlinkSync (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;

  const destinationExists = gracefulFs.existsSync(dstpath);
  if (destinationExists) return undefined

  const relative = symlinkPathsSync$1(srcpath, dstpath);
  srcpath = relative.toDst;
  type = symlinkTypeSync$1(relative.toCwd, type);
  const dir = path.dirname(dstpath);
  const exists = gracefulFs.existsSync(dir);
  if (exists) return gracefulFs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync$2(dir);
  return gracefulFs.symlinkSync(srcpath, dstpath, type)
}

var symlink = {
  createSymlink: u$10(createSymlink),
  createSymlinkSync
};

var ensure = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};

const u$11 = universalify.fromCallback;



const pathExists$7 = pathExists_1.pathExists;

function outputFile (file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding;
    encoding = 'utf8';
  }

  const dir = path.dirname(file);
  pathExists$7(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return gracefulFs.writeFile(file, data, encoding, callback)

    mkdirs_1$2.mkdirs(dir, err => {
      if (err) return callback(err)

      gracefulFs.writeFile(file, data, encoding, callback);
    });
  });
}

function outputFileSync (file, data, encoding) {
  const dir = path.dirname(file);
  if (gracefulFs.existsSync(dir)) {
    return gracefulFs.writeFileSync.apply(gracefulFs, arguments)
  }
  mkdirs_1$2.mkdirsSync(dir);
  gracefulFs.writeFileSync.apply(gracefulFs, arguments);
}

var output = {
  outputFile: u$11(outputFile),
  outputFileSync
};

const fs$5 = {};

// Export graceful-fs:
assign_1(fs$5, fs_1$2);
// Export extra methods:
assign_1(fs$5, copy$2);
assign_1(fs$5, copySync$1);
assign_1(fs$5, mkdirs_1$2);
assign_1(fs$5, remove);
assign_1(fs$5, json);
assign_1(fs$5, move_1);
assign_1(fs$5, moveSync_1);
assign_1(fs$5, empty$1);
assign_1(fs$5, ensure);
assign_1(fs$5, output);
assign_1(fs$5, pathExists_1);

var lib = fs$5;

function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject$1(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


var isNothing_1      = isNothing;
var isObject_1       = isObject$1;
var toArray_1        = toArray;
var repeat_1         = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1         = extend;

var common = {
	isNothing: isNothing_1,
	isObject: isObject_1,
	toArray: toArray_1,
	repeat: repeat_1,
	isNegativeZero: isNegativeZero_1,
	extend: extend_1
};

// YAML error class. http://stackoverflow.com/questions/8458984

function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


var exception = YAMLException;

function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


var mark = Mark;

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

var type = Type;

/*eslint-disable max-len*/






function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type$$1, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type$$1) {
    result[type$$1.kind][type$$1.tag] = result['fallback'][type$$1.tag] = type$$1;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type$$1) {
    if (type$$1.loadKind && type$$1.loadKind !== 'scalar') {
      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new exception('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new exception('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type$$1) { return type$$1 instanceof type; })) {
    throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


var schema = Schema;

var str = new type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

var seq = new type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

var map = new type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

var _null = new type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

var bool = new type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

var int_1 = new type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

var float_1 = new type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

var json$2 = new schema({
  include: [
    failsafe
  ],
  implicit: [
    _null,
    bool,
    int_1,
    float_1
  ]
});

var core = new schema({
  include: [
    json$2
  ]
});

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

var timestamp = new type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

var merge = new type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = commonjsRequire;
  NodeBuffer = _require('buffer').Buffer;
} catch (__) {}




// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

var binary = new type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

var omap = new type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

var _toString$1 = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString$1.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

var pairs = new type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty$1.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

var set = new type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

var default_safe = new schema({
  include: [
    core
  ],
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

var _undefined = new type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

var regexp = new type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require$1 = commonjsRequire;
  esprima = _require$1('esprima');
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}



function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        ast.body[0].expression.type !== 'FunctionExpression') {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      ast.body[0].expression.type !== 'FunctionExpression') {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

var _function = new type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

var default_full = schema.DEFAULT = new schema({
  include: [
    default_safe
  ],
  explicit: [
    _undefined,
    regexp,
    _function
  ]
});

/*eslint-disable max-len,no-use-before-define*/








var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i$1 = 0; i$1 < 256; i$1++) {
  simpleEscapeCheck[i$1] = simpleEscapeSequence(i$1) ? 1 : 0;
  simpleEscapeMap[i$1] = simpleEscapeSequence(i$1);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || default_full;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new exception(
    message,
    new mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty$2.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty$2.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty$2.call(overridableKeys, keyNode) &&
        _hasOwnProperty$2.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty$2.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty$2.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty$2.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: default_safe }, options));
  } else {
    return loadAll(input, common.extend({ schema: default_safe }, options));
  }
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: default_safe }, options));
}


var loadAll_1     = loadAll;
var load_1        = load;
var safeLoadAll_1 = safeLoadAll;
var safeLoad_1    = safeLoad;

var loader = {
	loadAll: loadAll_1,
	load: load_1,
	safeLoadAll: safeLoadAll_1,
	safeLoad: safeLoad_1
};

/*eslint-disable no-use-before-define*/






var _toString$2       = Object.prototype.toString;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty$3.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State$1(options) {
  this.schema       = options['schema'] || default_full;
  this.indent       = Math.max(1, (options['indent'] || 2));
  this.skipInvalid  = options['skipInvalid'] || false;
  this.flowLevel    = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap     = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys     = options['sortKeys'] || false;
  this.lineWidth    = options['lineWidth'] || 80;
  this.noRefs       = options['noRefs'] || false;
  this.noCompatMode = options['noCompatMode'] || false;
  this.condenseFlow = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    && c !== CHAR_COLON
    && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (string[0] === ' ' && indentPerLevel > 9) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new exception('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = (string[0] === ' ') ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new exception('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString$2.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty$3.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString$2.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new exception('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State$1(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: default_safe }, options));
}

var dump_1     = dump;
var safeDump_1 = safeDump;

var dumper = {
	dump: dump_1,
	safeDump: safeDump_1
};

function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


var Type$2                = type;
var Schema$2              = schema;
var FAILSAFE_SCHEMA     = failsafe;
var JSON_SCHEMA         = json$2;
var CORE_SCHEMA         = core;
var DEFAULT_SAFE_SCHEMA$1 = default_safe;
var DEFAULT_FULL_SCHEMA$1 = default_full;
var load$1                = loader.load;
var loadAll$1             = loader.loadAll;
var safeLoad$1            = loader.safeLoad;
var safeLoadAll$1         = loader.safeLoadAll;
var dump$1                = dumper.dump;
var safeDump$1            = dumper.safeDump;
var YAMLException$2       = exception;

// Deprecated schema names from JS-YAML 2.0.x
var MINIMAL_SCHEMA = failsafe;
var SAFE_SCHEMA    = default_safe;
var DEFAULT_SCHEMA = default_full;

// Deprecated functions from JS-YAML 1.x.x
var scan           = deprecated('scan');
var parse          = deprecated('parse');
var compose        = deprecated('compose');
var addConstructor = deprecated('addConstructor');

var jsYaml = {
	Type: Type$2,
	Schema: Schema$2,
	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
	JSON_SCHEMA: JSON_SCHEMA,
	CORE_SCHEMA: CORE_SCHEMA,
	DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA$1,
	DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA$1,
	load: load$1,
	loadAll: loadAll$1,
	safeLoad: safeLoad$1,
	safeLoadAll: safeLoadAll$1,
	dump: dump$1,
	safeDump: safeDump$1,
	YAMLException: YAMLException$2,
	MINIMAL_SCHEMA: MINIMAL_SCHEMA,
	SAFE_SCHEMA: SAFE_SCHEMA,
	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
	scan: scan,
	parse: parse,
	compose: compose,
	addConstructor: addConstructor
};

var jsYaml$2 = jsYaml;

/*
© 2017-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/
const m = 'typeVerifiers';

function setMDebug(o, instance, name) {
  o = Object(o);
  const ti = typeof instance;
  if (ti !== 'object') throw new Error(`${m} setMDebug: instance not object: type: ${ti}`);
  name = o.name || name;
  const tn = typeof name;
  if (!name || tn !== 'string') throw new Error(`${m} setMDebug: name not non-empty string: type: ${tn}`);

  instance.m = name;
  o.debug && (instance.debug = true);

  return o;
}

function getNonEmptyString(firstArgument, defaultValue) {
  const { name, value = defaultValue, s } = getSNameValue(firstArgument);
  const vt = typeof value;
  if (!value && vt !== 'string') return s.text = `not non-empty string: type: ${vt}`;
  s.properties[name] = value;
}

function getNonEmptyStringOrUndefined(firstArgument, defaultValue) {
  const { name, value = defaultValue, s } = getSNameValue(firstArgument);
  if (value === undefined) return;
  const vt = typeof value;
  if (!value && vt !== 'string') return s.text = `not non-empty string or undefined: type: ${vt}`;
  s.properties[name] = value;
}

function getStringOrFunctionOrUndefined(firstArgument, defaultValue) {
  const { name, value = defaultValue, s } = getSNameValue(firstArgument);
  if (value === undefined) return;
  const vt = typeof value;
  if (vt !== 'string' && vt !== 'function') return s.text = `not non-empty string or function or undefined: type: ${vt}`;
  s.properties[name] = value;
}

function getFn(firstArgument, defaultValue) {
  const { name, value = defaultValue, s } = getSNameValue(firstArgument);
  const ft = typeof value;
  if (ft !== 'function') return s.text = `not function: type: ${ft}`;
  s.properties[name] = value;
}

function getSNameValue(firstArgument) {
  if (!firstArgument) throw new Error(`${m}: first argument not object`);
  const { s } = firstArgument;
  if (!s) throw new Error(`${m}: first argument s property null`);
  const properties = Object.keys(Object(firstArgument)).filter(property => property !== 's');
  if (properties.length !== 1) throw new Error(`${m} first argument has more than 1 property other than s`);
  const name = properties[0];
  const value = firstArgument[name];
  if (!s.properties) s.properties = {};
  return { name, value, s };
}

/*
© 2017-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/
function throwWithMethod(e, method) {
  console.error(`${method}:`);
  throw Object.assign(e, { method });
}

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class TemplateManager {

  constructor(o) {
    this.renderDir = '/home/data/salt/aws';
    this.renderExt = '.yaml';
    this.fileTemplate = 'NAME.yaml';
    this.fileTemplateRegexp = /NAME/g;

    const { debug } = setMDebug(o, this, 'TemplateManager');
    debug && this.constructor === TemplateManager && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`);
  }

  async renderTemplate(o) {
    const { filename, stackName, patches } = o || false;
    let s = {};
    if (getNonEmptyString({ filename, s })) throw new Error(`${this.m}.renderTemplate: filename: ${s.text}`);
    if (!(await lib.pathExists(filename))) throw new Error(`${this.m} template file does not exist: ${filename}`);
    let yamlText = await lib.readFile(filename, 'utf8');
    if (Array.isArray(patches)) for (let i = 0; i < patches.length; i += 2) {
      const regExp = patches[i];
      const value = patches[i + 1];
      yamlText = yamlText.replace(regExp, value);
    }

    const { renderDir, fileTemplate, fileTemplateRegexp } = this;
    await lib.ensureDir(renderDir);
    const outfile = path.join(renderDir, fileTemplate.replace(fileTemplateRegexp, stackName));
    if (await lib.pathExists(outfile)) throw new Error(`${this.m} file already exists: ${outfile}`);
    return lib.writeFile(outfile, yamlText);
  }

  async getRenderedTemplates() {
    // /home/data/salt/aws/*.yaml-> [c1, c2, …]
    const templates = [];
    const { renderDir, renderExt } = this;
    if (await lib.pathExists(renderDir)) {
      for (let file of await lib.readdir(renderDir)) {
        const ext = path.extname(file);
        if (ext === renderExt) {
          templates.push({
            name: file.slice(0, -ext.length),
            fspath: path.join(renderDir, file)
          });
        }
      }
    }
    return templates;
  }

  async getTemplateBody(stackName) {
    const { renderDir, renderExt } = this;
    const absolute = path.join(renderDir, stackName + renderExt);
    if (!(await lib.pathExists(absolute))) throw new Error(`${this.m}: template has not been rendered: ${absolute}`);
    return lib.readFile(absolute, 'utf8');
  }
}

var _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

class EC2Template extends TemplateManager {

  constructor(o) {
    super(_extends$2({ name: 'EC2Template' }, o));
    this.debug && this.constructor === EC2Template && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`);
  }

  async renderTemplate({ stackName, imageId, availabilityZone }) {
    const { templateFile: filename, rImageId, rAvailabilityZone } = EC2Template;
    const patches = [rImageId, imageId];
    availabilityZone && patches.push(rAvailabilityZone, availabilityZone);
    return super.renderTemplate({ filename, stackName, patches });
  }
}
EC2Template.templateFile = path.resolve('config', 'EC2Template.yaml');
EC2Template.rImageId = /IMAGEID/g;
EC2Template.rAvailabilityZone = /us-west-2a #AVZO/g;

var Node_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var Node = /** @class */ (function () {
    // tslint:disable-next-line:no-any
    function Node(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        Object.keys(options).forEach(function (key) {
            _this[key] = options[key];
        });
    }
    return Node;
}());
exports.default = Node;

});

unwrapExports(Node_1);

var Comment_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var Comment = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment(
    /**
     * Indicates the start of a comment (e.g., # or ;).
     */
    indicator, 
    /**
     * The text that follows the comment indicator.
     */
    text) {
        var _this = _super.call(this) || this;
        _this.indicator = indicator;
        _this.text = text;
        _this.raws = {};
        return _this;
    }
    Comment.parse = function (text, options) {
        var comment = options.comment, isCommentCharInProp = options.isCommentCharInProp;
        if (!comment) {
            return null;
        }
        var firstChar = text[0];
        if (!comment.test(firstChar)) {
            return null;
        }
        var indicator = '';
        for (var _i = 0, text_1 = text; _i < text_1.length; _i++) {
            var char = text_1[_i];
            if (indicator) {
                if ([' ', '['].indexOf(char) !== -1) {
                    return new Comment(indicator, text.substr(1));
                }
                break;
            }
            indicator = char;
            if (!isCommentCharInProp) {
                return new Comment(indicator, text.substr(1));
            }
        }
        return null;
    };
    Comment.prototype.toString = function () {
        var _a = this, indicator = _a.indicator, text = _a.text;
        return [
            indicator,
            text,
        ].join('');
    };
    Comment.type = 'comment';
    return Comment;
}(Node_1.default));
exports.default = Comment;

});

unwrapExports(Comment_1);

var common$3 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Attempts to parse a string value with `JSON.parse`. If unsuccessful,
 * returns input string untouched.
 */
function parseValue(value) {
    if (!value) {
        return value;
    }
    if (value[0] === '"') {
        return value;
    }
    try {
        return JSON.parse(value);
    }
    catch (_a) {
        return value;
    }
}
exports.parseValue = parseValue;

});

unwrapExports(common$3);
var common_1 = common$3.parseValue;

var Property_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


var Property = /** @class */ (function (_super) {
    __extends(Property, _super);
    function Property(
    /**
     * The key or name of the property.
     */
    key, _a) {
        var _b = _a === void 0 ? {} : _a, delimiter = _b.delimiter, value = _b.value, _c = _b.raws, raws = _c === void 0 ? {
            after: '',
        } : _c;
        return _super.call(this, {
            key: key,
            delimiter: delimiter,
            value: value,
            raws: raws,
        }) || this;
    }
    Property.parse = function (text, options) {
        var comment = options.comment, isCommentCharInProp = options.isCommentCharInProp, delimiter = options.delimiter, resolve = options.resolve;
        var key;
        var value;
        var isKey = false;
        var isValue = false;
        var isSingleQuoted = false;
        var isDoubleQuoted = false;
        var isQuoted = false;
        var isEscaped = false;
        var isBracketed = false;
        var endQuotePos = 0;
        var acc = '';
        var delimiterValue;
        var isComment = false;
        var endPos = 0;
        var spaceCount = 0;
        for (var _i = 0, text_1 = text; _i < text_1.length; _i++) {
            var char = text_1[_i];
            endPos++;
            if (isComment) {
                if (char === ' ') {
                    endPos--;
                    break;
                }
                isComment = false;
            }
            if (isEscaped) {
                isEscaped = false;
                acc += char;
                if (!isValue) {
                    isKey = true;
                }
                continue;
            }
            if (char === '\\') {
                isEscaped = true;
                spaceCount = 0;
                continue;
            }
            if (isValue && (!resolve || /[\{\[]/.test(char))) {
                isBracketed = true;
                acc += char;
                spaceCount = 0;
                continue;
            }
            if (char === '"' && !isSingleQuoted) {
                isQuoted = isDoubleQuoted = !isDoubleQuoted;
                if (isBracketed) {
                    acc += char;
                }
                if (!isQuoted) {
                    endQuotePos = acc.length;
                }
                spaceCount = 0;
                continue;
            }
            if (char === '\'' && !isDoubleQuoted) {
                isQuoted = isSingleQuoted = !isSingleQuoted;
                if (!isQuoted) {
                    endQuotePos = acc.length;
                }
                spaceCount = 0;
                continue;
            }
            if (isQuoted) {
                acc += char;
                if (!isValue) {
                    isKey = true;
                }
                continue;
            }
            if (comment && comment.test(char)) {
                if (isCommentCharInProp) {
                    isComment = true;
                    if (isValue && /\s$/.test(acc)) {
                        endPos--;
                        break;
                    }
                    acc += char;
                    continue;
                }
                if (!isValue && !acc && !endQuotePos) {
                    return null;
                }
                endPos--;
                break;
            }
            if (char === ' ') {
                spaceCount++;
            }
            else {
                spaceCount = 0;
            }
            if (isKey && delimiter.test(char)) {
                delimiterValue = char;
                key = trim(acc, endQuotePos);
                endQuotePos = 0;
                isKey = isQuoted = isSingleQuoted = isDoubleQuoted = false;
                isValue = true;
                acc = '';
                spaceCount = 0;
                continue;
            }
            if (acc || /\S/.test(char)) {
                acc += char;
                if (!isValue) {
                    isKey = true;
                }
            }
        }
        var raws = {
            after: text.substr(endPos - spaceCount),
        };
        if (isKey) {
            key = trim(acc, endQuotePos);
            return new Property(key, { raws: raws });
        }
        if (isValue) {
            value = trim(acc, endQuotePos);
            return new Property(key, {
                delimiter: delimiterValue,
                value: resolveValue(value, key),
                raws: raws,
            });
        }
        return null;
        function resolveValue(value2, key2) {
            if (resolve === true) {
                return common$3.parseValue(value2);
            }
            if (resolve) {
                return resolve(value2, key2, common$3.parseValue);
            }
            return value2;
        }
    };
    Property.prototype.toString = function () {
        var _a = this, delimiter = _a.delimiter, key = _a.key, value = _a.value, after = _a.raws.after;
        return [
            key,
            delimiter,
            value,
            after,
        ].join(' ');
    };
    Property.type = 'property';
    return Property;
}(Node_1.default));
exports.default = Property;
function trim(value, endQuotePos) {
    var trimmed = value.trim();
    return (trimmed.length > endQuotePos)
        ? trimmed
        : value.substring(0, endQuotePos);
}

});

unwrapExports(Property_1);

var Section_1 = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var Section = /** @class */ (function (_super) {
    __extends(Section, _super);
    function Section(_a) {
        var _b = _a === void 0 ? {} : _a, name = _b.name, _c = _b.newline, newline = _c === void 0 ? '\n' : _c, _d = _b.nodes, nodes = _d === void 0 ? [] : _d, _e = _b.raws, raws = _e === void 0 ? {
            after: '',
        } : _e;
        return _super.call(this, {
            name: name,
            newline: newline,
            nodes: nodes,
            raws: raws,
        }) || this;
    }
    Section.parse = function (text) {
        var isEscaped = false;
        var depth = 0;
        var name = '';
        var slashCount = 0;
        for (var _i = 0, text_1 = text; _i < text_1.length; _i++) {
            var char = text_1[_i];
            if (depth) {
                if (isEscaped) {
                    isEscaped = false;
                    if (!/[\\\[\]]/.test(char)) {
                        name += '\\';
                    }
                    name += char;
                    continue;
                }
                if (char === '\\') {
                    isEscaped = true;
                    slashCount++;
                    continue;
                }
            }
            if (char === '[') {
                if (++depth > 1) {
                    name += char;
                }
                continue;
            }
            if (char === ']') {
                if (--depth === 0) {
                    break;
                }
                name += char;
                continue;
            }
            if (depth) {
                name += char;
                continue;
            }
            return null;
        }
        var after = text.substr(name.length + 2 + slashCount);
        return new Section({
            name: name.trim(),
            raws: {
                after: after,
            },
        });
    };
    Section.prototype.toString = function () {
        var _a = this, name = _a.name, newline = _a.newline, nodes = _a.nodes, after = _a.raws.after;
        return (typeof name === 'string' ? ["[" + name + "]" + after] : []).concat(nodes.map(function (node) { return node.toString(); })).join(newline);
    };
    Section.type = 'section';
    return Section;
}(Node_1.default));
exports.default = Section;

});

unwrapExports(Section_1);

var Sections_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

var Sections = /** @class */ (function () {
    function Sections(options) {
        if (options === void 0) { options = {}; }
        var _a = options.items, items = _a === void 0 ? [] : _a, _b = options.newline, newline = _b === void 0 ? '\n' : _b;
        this.items = items;
        this.newline = newline;
    }
    Object.defineProperty(Sections.prototype, "current", {
        get: function () {
            return this.items[this.items.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    Sections.prototype.pushNode = function (node) {
        var newline = this.newline;
        if (!node) {
            return;
        }
        if (node instanceof Section_1.default) {
            this.items.push(node);
            return;
        }
        if (!this.items.length) {
            this.items.push(new Section_1.default({
                newline: newline,
            }));
        }
        this.current.nodes.push(node);
    };
    Sections.prototype.toString = function () {
        return this.items.join(this.newline + this.newline);
    };
    return Sections;
}());
exports.default = Sections;

});

unwrapExports(Sections_1);

var iniParser = createCommonjsModule(function (module, exports) {
var __assign = (commonjsGlobal && commonjsGlobal.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });

exports.Comment = Comment_1.default;

exports.Property = Property_1.default;

exports.Section = Section_1.default;

exports.Sections = Sections_1.default;
/**
 * Parser for the informal INI file format.
 */
var Parser = /** @class */ (function () {
    function Parser(options) {
        if (options === void 0) { options = {}; }
        this.resetConfiguration();
        this.configure(options);
    }
    /**
     * Resets configuration to default settings as if you created a
     * `new Parser()`.
     */
    Parser.prototype.resetConfiguration = function () {
        this.options = __assign({}, Parser.defaultOptions);
    };
    /**
     * Sets configuration options, preserving existing configuration and
     * overriding only the new keys you provide.
     */
    Parser.prototype.configure = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        Object.keys(options).forEach(function (key) {
            var validators = Parser.optionValidators[key];
            if (!validators) {
                throw new Error("Invalid option: " + key);
            }
            resolveOption.call.apply(resolveOption, [_this, key].concat(validators));
        });
        function resolveOption(key) {
            var validators = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                validators[_i - 1] = arguments[_i];
            }
            var value = options[key];
            for (var _a = 0, validators_1 = validators; _a < validators_1.length; _a++) {
                var validator = validators_1[_a];
                if (validator(value)) {
                    this.options[key] = value;
                    return;
                }
            }
            throw new Error([
                "Invalid option: " + key,
                "Expected: " + validators.map(function (v) { return v.name; }).join(' | '),
            ].join('; '));
        }
    };
    /**
     * Parses INI file contents as a string. The result will be an array:
     * - Index `0` will have any/all root properties.
     * - Index `1` will have an array of any/all sections that follow.
     * Note: repeated sections will also be repeated in the array.
     * @param contents INI file contents.
     */
    Parser.prototype.parse = function (contents) {
        this.sections = new Sections_1.default();
        if (contents) {
            contents
                .split(this.options.newline)
                .forEach(this.parseLine.bind(this));
        }
        return this.sections;
    };
    Parser.prototype.parseLine = function (text) {
        var options = this.options;
        text = text.trim();
        this.sections.pushNode(Comment_1.default.parse(text, options) ||
            Section_1.default.parse(text) ||
            Property_1.default.parse(text, options));
    };
    Parser.defaultOptions = {
        comment: /[#;]/,
        delimiter: /[=:]/,
        isCommentCharInProp: false,
        newline: /\r?\n/,
        resolve: true,
    };
    Parser.optionValidators = {
        comment: [isRegExp, isFalse],
        delimiter: [isRegExp],
        isCommentCharInProp: [isBoolean],
        newline: [isRegExp],
        resolve: [isBoolean, isFunction],
    };
    return Parser;
}());
exports.default = Parser;
// tslint:disable-next-line:no-any
function isRegExp(value) {
    return (value)
        ? !!value.compile
        : false;
}
// tslint:disable-next-line:no-any
function isFalse(value) {
    return value === false;
}
// tslint:disable-next-line:no-any
function isBoolean(value) {
    return value === true || value === false;
}
// tslint:disable-next-line:no-any
function isFunction(value) {
    return typeof value === 'function';
}

});

var IniParser = unwrapExports(iniParser);
var iniParser_1 = iniParser.Comment;
var iniParser_2 = iniParser.Property;
var iniParser_3 = iniParser.Section;
var iniParser_4 = iniParser.Sections;

/*
© 2017-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class AwsSdk {

  constructor(o) {
    this._serviceInterfaceObjects = {};

    const { name, debug } = o || false;
    this.m = String(name || 'AwsSdk');
    debug && (this.debug = true) && this.constructor === AwsSdk && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`);
  }

  getService(serviceName) {
    const st = typeof serviceName;
    if (!serviceName || st !== 'string') throw new Error(`${this.m} service not non-empty string: ${st}`);

    // cached service interface objects
    const { _serviceInterfaceObjects: awsServices } = this;
    const awsService = awsServices[serviceName];
    if (awsService) return awsService;

    // instantiate
    const construct = AWS[serviceName];
    if (typeof construct !== 'function') {
      console.error(`Available AWS services: ${this.getServiceList({ string: true })}`);
      throw new Error(`${this.m} service not in aws-sdk: ${serviceName}`);
    }
    // have constructor populate service.config.credentials service.config.region
    process.env.AWS_SDK_LOAD_CONFIG = 1; // use: AWS_PROFILE ~/.aws/config ~/.aws/credentials
    const service = awsServices[serviceName] = new construct(); // service interface object
    if (!service.config.credentials) {
      const p = process.env.AWS_PROFILE;
      const value = p !== undefined ? `'${p}'` : 'undefined';
      throw new Error(`${this.m} credentials missing: set AWS_PROFILE to one of: ${this.getProfilesSync().join(' ')}. AWS_PROFILE was: ${value}`);
    }
    if (!service.config.region) {
      const { profile } = service.config.credentials;
      throw new Error(`${this.m} region not set in ~/.aws/config for profile: '${profile}`);
    }
    return service;
  }

  hasCredentials() {
    return !!AWS.config.credentials;
  }

  getProfilesSync() {
    const { awsCredentialsPath: file } = AwsSdk;
    if (lib.pathExistsSync(file)) return this._parseProfiles(lib.readFileSync(file, 'utf8'));
  }

  async getProfiles() {
    const { awsCredentialsPath: file } = AwsSdk;
    if (await lib.pathExists(file)) return this._parseProfiles((await lib.readFile(file, 'utf8')));
  }

  setRegion({ region, profile, service }) {
    if (region === undefined && profile) {
      const { awsConfigPath: file } = AwsSdk;
      if (lib.pathExistsSync(file)) {
        const data = new IniParser().parse(lib.readFileSync(file, 'utf8'));
        const key = `profile ${profile}`;
        for (let section of data.items) {
          const { name, nodes } = section;
          if (name === key) {
            for (let node of nodes) {
              if (node.key === 'region') {
                region = node.value;
                break;
              }
            }
          }
          if (region) break;
        }
      }
    } else if (typeof region !== 'string') region = String(region);
    if (region !== undefined) {
      if (region === null) region = undefined;
      if (!service) service = AWS;
      //service.config.update({region}) // this fails b/c service CloudFormation domain is undefined
    }
  }

  getServiceList(o) {
    const { string } = o || false;
    let services = [];
    for (let [serviceName, fn] of Object.entries(Object(AWS))) if (typeof fn === 'function') services.push(serviceName);
    services = services.sort();
    return !string ? services : services.join(' ');
  }

  _parseProfiles(text) {
    const profiles = new Set();
    for (let section of new IniParser().parse(text).items) {
      const { name, nodes } = section;
      name && nodes && nodes.length && profiles.add(name);
    }
    return Array.from(profiles).sort();
  }
}
AwsSdk.awsCredentialsPath = path.join(os.homedir(), '.aws', 'credentials');
AwsSdk.awsConfigPath = path.join(os.homedir(), '.aws', 'config');

var _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

class StackBase extends AwsSdk {
  constructor(o) {
    super(_extends$3({ name: 'StackBase' }, o));

    this.throwE = (e, m) => {
      console.error(`${this.m} ${m}:`);
      throw e;
    };

    const { stackName, stackId, region } = Object(o);
    let s = {};
    if (getNonEmptyStringOrUndefined({ stackName, s })) throw new Error(`${this.m} stackName: ${s.text}`);
    if (getNonEmptyStringOrUndefined({ stackId, s })) throw new Error(`${this.m} stackId: ${s.text}`);
    if (getNonEmptyStringOrUndefined({ region, s })) throw new Error(`${this.m} stackName: ${s.text}`);
    Object.assign(this, s.properties);
    this.cfo = this.getService('CloudFormation');
    this.debug && this.constructor === StackBase && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`);
  }

  async verifyState(state) {
    const { stackStatus } = await this.getOneStack();
    if (stackStatus !== state) {
      await this.getEvents();
      throw new Error(`Unexpected state: ${stackStatus}, expected ${state} for stack ${this.getStackDescription()} Check CloudFormation Stacks Events on AWS Web site https://console.aws.amazon.com/cloudformation`);
    }
    return stackStatus;
  }

  getStackDescription() {
    const { stackName, stackId } = this;
    if (!stackName && !stackId) throw new Error(`${this.m} getStackDescription assert`);
    const spacing = stackName && stackId ? '\x20' : '';
    return `${stackName}${spacing}${stackId}`;
  }

  async getEvents() {
    const { stackName: StackName, cfo } = this;
    const r = await cfo.describeStackEvents({ StackName }).promise().catch(e => this.throwE(e, 'getEvents'));
    /*
      {ResponseMetadata: { RequestId: 'a75262f6-178a-11e8-a168-2f9d0017f855' },
      StackEvents: [{
        StackId: 'arn:aws:cloudformation:us-west-2:038774786854:stack/c33/d2450460-176e-11e8-b1fe-503ac9841afd',
        EventId: '96d9acd0-1784-11e8-966d-500c33711061',
        StackName: 'c33',
        LogicalResourceId: 'c33',
        PhysicalResourceId: 'arn:aws:cloudformation:us-west-2:038774786854:stack/c33/d2450460-176e-11e8-b1fe-503ac9841afd',
        ResourceType: 'AWS::CloudFormation::Stack',
        Timestamp: 2018-02-22T03:58:06.867Z,
        ResourceStatus: 'CREATE_COMPLETE' },
    */
    const recs = Object(r).StackEvents;
    if (!Array.isArray(recs)) throw new Error(`${this.m} AWS bad describeStackEvents response`);
    for (let _ref of recs) {
      let { ResourceStatus, ResourceStatusReason } = _ref;
      console.log({ ResourceStatus, ResourceStatusReason });
    }
  }

  async createStack(o) {
    const { templateBody, availabilityZone } = o || false;
    const { stackName, cfo } = this;
    let s = {};
    if (getNonEmptyString({ templateBody, s })) throw new Error(`${this.m} templateBody: ${s.text}`);
    const args = {
      StackName: stackName,
      Capabilities: ['CAPABILITY_IAM'],
      TemplateBody: templateBody
    };
    availabilityZone && Object.assign(args, { Parameters: [{
        ParameterKey: 'AvailabilityZone',
        ParameterValue: availabilityZone
      }] });
    let e;
    const response = await cfo.createStack(args).promise().catch(ee => e = ee);
    /*
    {ResponseMetadata: {RequestId: '16a6aba3-1764-11e8-af53-d1eaaf262ac0' },
      StackId: 'arn:aws:cloudformation:us-west-2:038774786854:stack/undefined/16ae4bd0-1764-11e8-a64e-503ac9ec2435' }
     */
    if (e) {
      await this.getEvents().catch(console.error);
      this.throwE(e, 'createStack');
    }
    const stackId = Object(response).StackId;
    if (getNonEmptyString({ stackId, s })) throw new Error(`${this.m}: aws response stackId: ${s.text}`);
    return stackId;
  }

  async updateStack(o) {
    const { templateBody, availabilityZone } = Object(o);
    const { stackName, cfo } = this;
    let s = {};
    if (getNonEmptyString({ templateBody, s })) throw new Error(`${this.m} templateBody: ${s.text}`);
    const args = {
      StackName: stackName,
      Capabilities: ['CAPABILITY_IAM'],
      TemplateBody: templateBody
    };
    availabilityZone && Object.assign(args, { Parameters: [{
        ParameterKey: 'AvailabilityZone',
        ParameterValue: availabilityZone
      }] });
    let e;
    const response = await cfo.updateStack(args).promise().catch(ee => e = ee);
    /*
    {ResponseMetadata: {RequestId: '16a6aba3-1764-11e8-af53-d1eaaf262ac0' },
      StackId: 'arn:aws:cloudformation:us-west-2:038774786854:stack/undefined/16ae4bd0-1764-11e8-a64e-503ac9ec2435' }
     */
    if (e) {
      await this.getEvents().catch(console.error);
      this.throwE(e, 'createStack');
    }

    const stackId = Object(response).StackId;
    if (getNonEmptyString({ stackId, s })) throw new Error(`${this.m}: aws response stackId: ${s.text}`);
    return stackId;
  }

  async waitWhile(whileInState) {
    // 171222 hr: aws-sdk has waitFor but it hangs. This here is similar
    for (;;) {
      const { stackStatus } = await this.getOneStack();
      if (stackStatus !== whileInState) return stackStatus;
      await new Promise((resolve, reject) => setTimeout(resolve, 5e3));
    }
  }

  async deleteStack(stackNameOrId) {
    return this.cfo.deleteStack({ StackName: stackNameOrId }).promise();
  }

  async getStacks() {
    // array
    const sums = Object((await this.cfo.listStacks().promise().catch(e => throwWithMethod(`${this.m}.getStacks`)))).StackSummaries;
    /*
      {ResponseMetadata: { RequestId: '126cb8af-1769-11e8-a674-3b6924dcda09' },
      StackSummaries: [{
        StackId: 'arn:aws:cloudformation:us-west-2:038774786854:stack/c33/f5095520-1767-11e8-9d05-50d5ca789ee6',
        StackName: 'c33',
        TemplateDescription: 'Amazon CloudFormation template for EC2 instance\n',
        CreationTime: 2018-02-22T00:33:09.495Z,
        DeletionTime: 2018-02-22T00:33:14.976Z,
        StackStatus: 'ROLLBACK_COMPLETE'
      }]}
      */
    if (!Array.isArray(sums)) throw new Error(`${this.m}: bad AWS response for listStacks`);
    return sums;
  }

  filterStacks(stacks) {
    const { stackName, stackId } = this;
    return stacks.filter(({ StackName: n, StackId: i }) => (!stackName || stackName === n) && (!stackId || stackId === i));
  }

  ensureOneStack(stacks) {
    const no = stacks.length;
    if (no !== 1) throw Object.assign(new Error(`${this.m} not exactly 1 stack matching: ${no}`), { no });
    const stack = stacks[0];
    const { StackName: stackName, StackId: stackId, StackStatus: stackStatus } = stack;
    if (!stackId) {
      console.error(stacks);
      throw new Error(`${this.m} ensureOneStack assert`);
    }
    Object.assign(this, { stackName, stackId });
    return { stackName, stackId, stackStatus };
  }

  async getOneStack() {
    return this.ensureOneStack(this.filterStacks((await this.getStacks())));
  }

  async getStackNames() {
    // array of nestring
    const m = `${this.m} AWS listStack`;
    return (await this.getStacks()).map(summary => {
      const { StackName, StackId, StackStatus } = summary || false;
      let s = {};
      if (getNonEmptyString({ StackName, s })) throw new Error(`${m}: bad stack name: ${s.text}`);
      if (getNonEmptyString({ StackId, s })) throw new Error(`${m}: bad stack id: ${s.text}`);
      return { stackName: StackName, stackId: StackId, stackStatus: StackStatus };
    });
  }

  async getStackStatus() {
    // nestring or null
    const { stackName } = this;
    for (let stack of await this.getStacks()) {
      const { StackName, StackStatus } = stack || false;
      if (!StackName || typeof StackName !== 'string') throw new Error(`${this.m}: bad AWS StackName`);
      if (StackName === stackName) {
        if (!StackStatus || typeof StackStatus !== 'string') throw new Error(`${this.m}: bad AWS StackStatus`);
        return StackStatus;
      }
    }
    return null;
  }

  getRegion() {
    return Object(this.cfo.config).region; // 'us-west-2'
  }
}

/*
© 2017-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class StackCreator extends StackBase {

  async create({ templateBody }) {
    const { typicalCreateSeconds } = StackCreator;
    console.log(`Finding matching stacks for: ${this.getStackDescription()}`);
    let e;
    await this.getOneStack().catch(ee => e = ee);
    const { no } = e || false;
    if (e && no !== 0) {
      // 2 or more stacks matched
      console.log(`matching count: ${no}. Use stack identifier`);
      throw e;
    } else if (no === 1) console.log(`Unique match: ${this.getStackDescription()}`);
    const { stackName } = this;
    console.log(`Checking status of stack: ${stackName}`);
    const stackStatus = await this.getStackStatus();
    console.log(`${stackName}: ${stackStatus || 'does not exist'}`);
    /* eslint-disable no-fallthrough */
    switch (stackStatus) {
      case 'ROLLBACK_IN_PROGRESS':
        console.log(`waiting for: ${stackName} ${new Date().toISOString()}…`);
        await this.waitWhile('ROLLBACK_IN_PROGRESS');
      case 'ROLLBACK_COMPLETE':
        console.log(`Initiating delete of ${stackName}…`);
        await this.deleteStack();
      case 'DELETE_IN_PROGRESS':
        console.log(`waiting for: ${stackName} ${new Date().toISOString()}…`);
        await this.waitWhile('DELETE_IN_PROGRESS');
      case 'DELETE_COMPLETE':
      case null:
        // the task does not exist at all
        console.log(`Initiating create of ${stackName}…`);
        const stackId = await this.createStack({ templateBody });
        console.log(`stack id: ${stackId}`);
      case 'CREATE_IN_PROGRESS':
        const t0 = Date.now();
        console.log(`waiting for: ${stackName} [${typicalCreateSeconds} s] ${new Date(t0).toISOString()}`);
        await this.waitWhile('CREATE_IN_PROGRESS');
        const duration = (Date.now() - t0) / 1e3;
        console.log(`Done in ${duration.toFixed(1)} s! verifying…`);
        const newState = await this.verifyState('CREATE_COMPLETE');
        console.log(`${stackName}: ${newState}`);
      case 'CREATE_COMPLETE':
        break;
      default:
        throw new Error(`Unknown stack state for ${stackName}: ${stackStatus}`);
    }
    /* eslint-enable no-fallthrough */
  }
}
StackCreator.typicalCreateSeconds = 40;

/*
© 2017-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class StackDeleter extends StackCreator {
  async delete() {
    const { stackName, stackId, stackStatus } = await this.getOneStack(this.filterStacks((await this.getStacks())));
    console.log(`stack: ${this.getStackDescription()}`);
    console.log(`status: ${stackStatus}`);
    /* eslint-disable no-fallthrough */
    switch (stackStatus) {
      case 'ROLLBACK_IN_PROGRESS':
      case 'CREATE_IN_PROGRESS':
        console.log(`waiting for: ${stackName} ${new Date().toISOString()}…`);
        await this.waitWhile(stackStatus);
      case 'ROLLBACK_COMPLETE':
      case 'CREATE_COMPLETE':
        console.log(`Initiating delete of ${stackName}…`);
        await this.deleteStack(stackId);
      case 'DELETE_IN_PROGRESS':
        console.log(`waiting for: ${stackName} ${new Date().toISOString()}…`);
        await this.waitWhile('DELETE_IN_PROGRESS');
        const newState = await this.verifyState('DELETE_COMPLETE');
        console.log(`${stackName}: ${newState}`);
      case 'DELETE_COMPLETE':
      case null:
        // the stack does not exist at all
        break;
      default:
        throw new Error(`Unknown stack state for ${stackName}: ${stackStatus}`);
    }
    /* eslint-enable no-fallthrough */
  }
}

/*
© 2017-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class StackUpdater extends StackDeleter {
  async update({ templateBody }) {
    console.log(`finding matching stacks for: ${this.getStackDescription()}`);
    let { stackStatus } = await this.getOneStack();
    const { stackName } = this;
    console.log(`stack: ${this.getStackDescription()}`);
    console.log(`status: ${stackStatus}`);
    for (;;) {
      let expect = undefined;
      /* eslint-disable no-fallthrough */
      switch (stackStatus) {
        case 'DELETE_IN_PROGRESS':
        case 'DELETE_COMPLETE':
          console.log(`stack is deleted. use -deploy`);
          return;
        case 'ROLLBACK_IN_PROGRESS':
          expect = 'ROLLBACK_COMPLETE';
          break;
        case 'CREATE_IN_PROGRESS':
          expect = 'CREATE_COMPLETE';
          break;
        case 'UPDATE_ROLLBACK':
          expect = 'UPDATE_ROLLBACK_COMPLETE';
          break;
        case 'ROLLBACK_COMPLETE':
        case 'CREATE_COMPLETE':
        case 'UPDATE_ROLLBACK_COMPLETE':
        case 'UPDATE_COMPLETE':
          break;
        default:
          throw new Error(`Unknown stack state for ${stackName}: ${stackStatus}`);
      }
      /* eslint-enable no-fallthrough */
      if (!expect) break;
      console.log(`waiting for: ${stackName} ${new Date().toISOString()}…`);
      stackStatus = await this.waitWhile(stackStatus);
      console.log(`status: ${stackStatus}`);
      if (stackStatus === expect) break;
    }
    console.log(`Initiating update of ${stackName}…`);
    const t0 = Date.now();
    await this.updateStack({ templateBody });
    await this.waitWhile('UPDATE_IN_PROGRESS');
    const duration = (Date.now() - t0) / 1e3;
    console.log(`Done in ${duration.toFixed(1)} s! verifying…`);
    await this.verifyState('UPDATE_COMPLETE'); // TODO what is the state?
    console.log('ok');
  }
}

var _extends$1$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

class StackManager extends StackUpdater {
  constructor(o) {
    super(_extends$1$1({ name: 'StackManager' }, o));
    this.debug && this.constructor === StackManager && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: 2 })}`);
  }

  setStackName(stackName) {
    this.stackName = stackName == null ? null : String(stackName);
  }

  async listStacks() {
    const { sm } = this;
    return (await sm.getStacks()).map(summary => summary.StackName);
  }
}

var _extends$2$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

class ImageManager extends AwsSdk {
  // in Canonical image description

  // current LTS as of 180221
  constructor(o) {
    super(_extends$2$1({ name: 'ImageManager' }, o));
    this.ec2 = this.getService('EC2');
    this.debug && this.constructor === ImageManager && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`);
  } // in Canonical image description


  async getUbuntuImageId(o) {
    // {imageId, desc}
    const { arch0, canonicalEc2Owner, root0, virt0, codename0, test, unsupported } = ImageManager;
    const { arch = arch0, owner = canonicalEc2Owner, root = root0, virt = virt0, codename = codename0 } = o || false;
    const { ec2, debug } = this;
    const params = {
      Owners: [String(owner)],
      Filters: [{ Name: 'virtualization-type', Values: [virt] }, { Name: 'architecture', Values: [arch] }, { Name: 'root-device-type', Values: [root] }] //--query 'reverse(Images.sort_by([], &CreationDate))[?contains(Name,`test`)==`false`]|[?contains(Name,`artful`)==`true`]|[0:20].[ImageId, Name]
    };
    debug && console.log(`${this.m} describeImages: ${util.inspect(params, { colors: true, depth: null })}`);
    const t = Date.now();
    const result = await ec2.describeImages(params).promise();
    const images = Object(result).Images;
    if (!Array.isArray(images)) throw new Error(`${this.m} unexpected result from AWS describeImages: Images not array`);
    debug && console.log(`${this.m} ${images.length} ${((Date.now() - t) / 1e3).toFixed(3)}`);
    /*
    { Architecture: 'x86_64',
       CreationDate: '2017-09-01T12:41:36.000Z',
       ImageId: 'ami-09a85d71',
       ImageLocation: '099720109477/ubuntu/images-testing/hvm-ssd/ubuntu-xenial-daily-amd64-server-20170830.1',           ImageType: 'machine',
       Public: true,
       OwnerId: '099720109477',
       ProductCodes: [],
       State: 'available',
       BlockDeviceMappings: [Array],
       Description: 'Canonical, Ubuntu, None LTS, UNSUPPORTED daily amd64 xenial image build on 2017-08-30',              EnaSupport: true,
       Hypervisor: 'xen',
       Name: 'ubuntu/images-testing/hvm-ssd/ubuntu-xenial-daily-amd64-server-20170830.1',
       RootDeviceName: '/dev/sda1',
       RootDeviceType: 'ebs',
       SriovNetSupport: 'simple',
       Tags: [],
       VirtualizationType: 'hvm' },
    }*/
    const image = images.filter(sum => {
      const desc = String(Object(sum).Description);
      return desc.match(codename) && !desc.match(test) && !desc.match(unsupported);
    }).sort((a, b) => a.CreationDate > b.CreationDate ? -1 : 1)[0];
    if (image) {
      const { ImageId: imageId, Description: desc } = image;
      return { imageId, desc };
    }
    return {};
  }
}
ImageManager.canonicalEc2Owner = '099720109477';
ImageManager.arch0 = 'x86_64';
ImageManager.codename0 = 'xenial';
ImageManager.root0 = 'ebs';
ImageManager.virt0 = 'hvm';
ImageManager.test = 'test';
ImageManager.unsupported = 'UNSUPPORTED';

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class Accounter {

  constructor(o) {
    const { debug } = setMDebug(o, this, 'Accounter');
    const { opts } = Accounter;
    for (let p of opts) if (o.hasOwnProperty(p)) this[p] = o[p];
    debug && this.constructor === Accounter && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`);
  }

  async run() {
    const { codename0, imageId0, searchS } = Accounter;
    const { render, listdeployable, deploy, list, codename = codename0, cachedid, debug, del, id, up } = this;

    if (render) {
      const stackName = render;
      let o;
      if (cachedid) o = { imageId: imageId0 };else {
        console.log(`Finding image id (${searchS} s)…`);
        o = await new ImageManager({ debug }).getUbuntuImageId({ codename });
      }
      const { imageId, desc } = o;
      if (imageId) console.log(`image id: ${imageId}${desc ? ` ${desc}` : ''}`);else throw new Error(`${this.m} failed to find an image`);
      await new EC2Template({ debug }).renderTemplate({ stackName, imageId });
    }

    if (listdeployable) {
      const templates = await new EC2Template({ debug }).getRenderedTemplates();
      if (templates.length) for (let _ref of templates) {
        let { name, fspath } = _ref;
        console.log(`${name} ${fspath}`);
      } else console.log('no templates has been rendered. Render using -render option');
    }

    if (deploy != null) {
      const stackName = deploy;
      const stackId = id;
      const templateBody = await new EC2Template({ debug }).getTemplateBody(stackName);
      await new StackManager({ stackName, stackId, debug }).create({ templateBody });
    }

    if (up != null) {
      const stackName = up;
      const stackId = id;
      const templateBody = await new EC2Template({ debug }).getTemplateBody(stackName);
      await new StackManager({ stackName, stackId, debug }).update({ templateBody });
    }

    if (list) {
      const stacks = await new StackManager({ debug }).getStackNames();
      console.log(stacks.length ? stacks.map(({ stackName, stackId, stackStatus }) => `${stackName} ${stackId} ${stackStatus}`).join('\n') : 'No stacks have been deployed. Deploy using -deploy');
    }

    if (del != null) {
      const stackName = del;
      const stackId = id;
      await new StackManager({ stackName, stackId, debug }).delete();
    }
  }
}
Accounter.codename0 = 'artful';
Accounter.imageId0 = 'ami-70873908';
Accounter.searchS = 7;
Accounter.opts = Object.keys({ deploy: 1, list: 1, render: 1, listdeployable: 1, debug: 1, cachedid: 1, codename: 1, id: 1, del: 1, up: 1 });

var name$1 = "awsaccounter";
var version = "0.0.1";
var description = "AWS CloudFormation account manager by Harald Rudell";
var author = "Harald Rudell <harald.rudell@gmail.com> (http://haraldrudell.com)";
var license = "UNLICENSED";
var main = "bin/awsaccounter";
var scripts = {"build":"rollup --config node:es2049package","watch":"rollup --watch --config node:es2049package","tw":"jest --watch","clean":"clean bin","test":"jest"};
var keywords = ["email"];
var repository = {"type":"git","url":"gt:sw"};
var rollup = {"dependencies":false,"external":"aws-sdk","targets":"mini","shebang":true};
var dependencies = {"@jedmao/ini-parser":"^0.2.0","es2049lib":"0.0.1","es2049options":"0.0.1"};
var devDependencies = {"es2049package":"^0.0.23","jest":"^22.4.2"};
var pjson = {
	name: name$1,
	version: version,
	description: description,
	author: author,
	license: license,
	main: main,
	scripts: scripts,
	keywords: keywords,
	repository: repository,
	rollup: rollup,
	dependencies: dependencies,
	devDependencies: devDependencies
};

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/
class OnRejected {
  constructor() {
    this.onRejected = this.onRejected.bind(this);
    this.m = 'launchProcess';
  }

  static launchProcess(o) {
    // {run, name, version, debug, exit}
    const instance = new OnRejected();
    return instance.invokeRun(o).catch(instance.onRejected);
  }

  static invokeExit(e, o) {
    const { m, debug, exit } = OnRejected.getDefaults(o);
    debug && console.error(`${m} onRejected:`);
    if (!(e instanceof Error)) e = new Error(`Error value: ${typeof e}, '${e}'`);
    console.error(!debug ? e.message : e);
    exit(OnRejected.exitCode);
  }

  static getDefaults(o) {
    let { m, debug, exit } = o || false;
    if (typeof exit !== 'function') exit = process.exit;
    if (!m || typeof m !== 'string') m = 'OnRejected';
    return { m, debug, exit };
  }

  async invokeRun(o) {
    const { onRejected } = this;
    const { run, name, version } = this.getArguments(o);
    return run({ onRejected, name, version, OnRejected: this });
  }

  setDebug() {
    return this.debug = true;
  }

  onRejected(e) {
    OnRejected.invokeExit(e, this);
  }

  getArguments(o) {
    let { run, name, version, debug, exit } = o || false;
    let s;
    if (s = this.verifyNonEmptyString(name)) throw new Error(`${this.m}: package.json key name: ${s}`);
    this.m = name;
    debug && (this.debug = true);
    if (s = this.verifyFn(run)) throw new Error(`${this.m} launchProcess run argument: ${s}`);
    if (s = this.verifyNonEmptyString(version)) throw new Error(`${this.m}: package.json key version: ${s}`);
    if (exit !== undefined) {
      if (s = this.verifyFn(exit)) throw new Error(`${this.m} launchProcess exit argument: ${s}`);
      this.exit = exit;
    }
    return { run, name, version };
  }

  verifyNonEmptyString(value) {
    const vt = typeof value;
    if (!value || vt !== 'string') return `not non-empty string: type: ${vt}`;
  }

  verifyFn(value, defaultValue) {
    value === undefined && (value = defaultValue);
    const vt = typeof value;
    if (vt !== 'function') return `not function: type: ${vt}`;
  }
}
OnRejected.exitCode = 1;

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class ParserBase {
  constructor(o) {
    const { optionsData } = setMDebug(o, this, 'ParserBase');
    const { exit } = Object(optionsData);
    let s = {};
    if (getFn({ exitFn: exit, s }, this.defaultExit.bind(this))) throw new Error(`${this.m} optionsData.exit: ${s.text}`);
    Object.assign(this, s.properties);
  }

  defaultExit(code) {
    process.exit(code);
  }
}

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/
const NONE = 0;
const ISDEFAULT = 1;
const ISMANDATORY = 2;
const MORETHANONCE = 4;
const ISPROHIBITED = 8;

const numeralitiesMap = {
  optional: ISDEFAULT + MORETHANONCE,
  optionalOnce: NONE,
  mandatory: ISMANDATORY,
  mandatoryMany: ISMANDATORY + MORETHANONCE,
  none: ISPROHIBITED
};

const numeralities = Object.keys(numeralitiesMap).reduce((acc, name) => {
  acc[name] = name;
  return acc;
}, {});

function NumeralityHOC(BaseClass) {
  var _class, _temp;

  return _temp = _class = class Numerality extends BaseClass {

    constructor(o) {
      super(o);
      this.setNumerality(Object(o).numerality);
      this.numeralityCount = 0;
    }

    setNumerality(numerality) {
      const num = numerality !== undefined ? numerality : Numerality.defaultNumerality;
      const v = numeralitiesMap[num];
      if (v === undefined) throw new Error(`Unknown numerality: ${numerality}, expected one of: ${Numerality.numeralityString}`);
      for (let p of Numerality.numeralityProperties) if (this.hasOwnProperty(p)) delete this[p];
      v & ISMANDATORY && (this.isNumeralityMandatory = true);
      v & ISPROHIBITED && (this.isNumeralityNever = true);
      v & MORETHANONCE && (this.isNumeralityMultiple = true);
      this._setNumeralityDescription();
    }

    addNumeralityOccurrence() {
      this.numeralityCount++;
    }

    isNumeralityBad() {
      const { numeralityCount, isNumeralityMandatory, isNumeralityNever, isNumeralityMultiple } = this;
      if (isNumeralityMandatory && !numeralityCount) return 'is mandatory';
      if (isNumeralityNever && numeralityCount) return 'is prohibited';
      if (!isNumeralityMultiple && numeralityCount > 1) return 'can only be provided once';
    }

    _setNumeralityDescription() {
      // default understanding is that the flag is optional and can be specified multiple times
      const { isNumeralityMandatory, isNumeralityMultiple, isNumeralityNever } = this;
      const { numeralityMandatory, numeralityNever, numeralityOnce } = Numerality;
      const s = [];
      if (isNumeralityMandatory) s.push(numeralityMandatory);else if (isNumeralityNever) s.push(numeralityNever);
      if (!isNumeralityNever && !isNumeralityMultiple) s.push(numeralityOnce);
      this.numeralityDescription = s.join(' ');
    }
  }, _class.numeralityProperties = Object.keys({ isNumeralityMandatory: 1, isNumeralityNever: 1, isNumeralityMultiple: 1 }), _class.defaultNumerality = Object.keys(numeralitiesMap).filter(numerality => numeralitiesMap[numerality] & ISDEFAULT)[0], _class.numeralityString = Object.keys(numeralitiesMap).join(', '), _class.numeralityMandatory = 'mandatory', _class.numeralityNever = 'prohibited', _class.numeralityOnce = 'once', _temp;
}

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/
class OptionBase {
  constructor(o) {
    !o && (o = false);
    this.m = String(o.name || this.constructor.name || 'OptionBase');
    o.debug && (this.debug = true);
  }
}

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/
const NONE$1 = 0;
const ISDEFAULT$1 = 1;
const NEVER = 2;
const ALWAYS = 4;

const valueFlagsMap = {
  never: NEVER + ISDEFAULT$1,
  may: NONE$1,
  always: ALWAYS
};

const valueFlags = Object.keys(valueFlagsMap).reduce((acc, name) => {
  acc[name] = name;
  return acc;
}, {});

function ValueFlagHOC(BaseClass) {
  var _class, _temp;

  return _temp = _class = class ValueFlag extends BaseClass {

    constructor(o) {
      super(o);
      this.setValueFlag(Object(o).hasValue);
    }

    setValueFlag(hasValue0) {
      const { defaultHasValue, valueFlagString, valueFlagProperties } = ValueFlag;
      const hasValue = hasValue0 !== undefined ? hasValue0 : defaultHasValue;
      const v = valueFlagsMap[hasValue];
      if (v === undefined) throw new Error(`Unknown hasValue: ${hasValue0}, expected one of: ${valueFlagString}`);
      for (let p of valueFlagProperties) if (this.hasOwnProperty(p)) delete this[p];
      v & NEVER && (this.isHasValueNever = true);
      v & ALWAYS && (this.isHasValueAlways = true);
      this._setValueFlagDescription();
    }

    _setValueFlagDescription() {
      // default understanding is that the option flag cannot have value
      const { isHasValueNever, isHasValueAlways } = this;
      const { valueFlagMust, valueFlagMay } = ValueFlag;
      this.valueFlagDescription = isHasValueNever ? '' : isHasValueAlways ? valueFlagMust : valueFlagMay;
    }
  }, _class.valueFlagProperties = Object.keys({ isHasValueNever: 1, isHasValueAlways: 1 }), _class.defaultHasValue = Object.keys(valueFlagsMap).filter(valueFlag => valueFlagsMap[valueFlag] & ISDEFAULT$1)[0], _class.valueFlagString = Object.keys(valueFlags).join(', '), _class.valueFlagMust = 'mandatory value', _class.valueFlagMay = 'may have value', _temp;
}

var _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

class Option extends ValueFlagHOC(NumeralityHOC(OptionBase)) {

  constructor(o) {
    super(o);
    const { names, property, value, valueName, help, debug, key } = Object(o);
    const { deletedProperties } = Option;
    let s = {};
    const { type } = this.constructor; // fetch static type member from derived class
    if (getNonEmptyString({ type, s })) throw new Error(`${this.m} option class static type member: ${s.text}: instantiating base Option class?`);
    delete s.properties.type;
    if (typeof (this.names = s.text = this._getOptionNames(names, property, key)) === 'string') throw new Error(`${this.m} option type: ${type}: names property: ${s.text}`);
    if (getNonEmptyStringOrUndefined({ property, s }, key)) throw new Error(`${this.m} property: ${s.text}`);
    if (value !== undefined) this.value = value; // any type
    if (getStringOrFunctionOrUndefined({ valueName, s })) throw new Error(`${this.m} valueName property: ${s.text}`);
    if (valueName === undefined && !this.isHasValueNever) this.valueName = Option.valueName;
    if (getStringOrFunctionOrUndefined({ help, s })) throw new Error(`${this.m}: help property: ${s.text}`);
    const props = _extends$4({}, o);
    for (let p of deletedProperties) delete props[p];
    Object.assign(this, s.properties, { count: 0, props });
    debug && this.constructor === Option && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`);
  }

  anotherInvocationOk() {
    return ++this.count < 2 || this.isNumeralityMultiple;
  }

  async help() {
    const { numeralityDescription, valueFlagDescription } = this;
    const s = [];
    numeralityDescription && s.push(numeralityDescription); // mandatory/prohibited/once
    valueFlagDescription && s.push(valueFlagDescription); // mandatory value/may have value
    return s.join(', ');
  }

  _getOptionNames(names, property, key) {
    // names must be a non-empty array of non-empty strings starting with a hyphen
    // defult value is hyphenated: key from optionsData.properties or property
    const nameList = names === undefined ? [`-${key || property}`] : Array.isArray(names) ? names : [names];
    for (let [index, name] of nameList.entries()) {
      const nt = typeof name;
      if (!name || typeof nt !== 'string') return `index #${index}: not non-empty string: type: ${nt}`;
      if (!name.startsWith('-')) return `index #${index}: option name not starting with hypen: ${name}`;
    }
    return nameList;
  }
}
Option.type = '';
Option.valueName = 'value';
Option.deletedProperties = Object.keys({ names: 1, property: 1, type: 1, numerality: 1, hasValue: 1, valuename: 1, value: 1, help: 1, debug: 1, key: 1 });

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

const m$1 = 'OptionHOC';

function OptionHOC(fn, name) {
  var _class, _temp2;

  {
    let s = {};
    if (getFn({ fn, s })) throw new Error(`${m$1} fn: ${s.text}`);
    if (getNonEmptyString({ name, s })) throw new Error(`${m$1} name: ${s.text}`);
  }
  return _temp2 = _class = class OptionCustom extends Option {
    constructor(...args) {
      var _temp;

      return _temp = super(...args), this.valueName = 'value', _temp;
    }

    execute(o) {
      return fn(o);
    }
  }, _class.type = name, _temp2;
}

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class OptionBoolean extends Option {

  constructor(o) {
    super(Object.assign({ hasValue: valueFlags.never, numerality: numeralities.optionalOnce }, o));
    this.debug && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`, valueFlags.never, numeralities.optionalOnce);
  }

  execute({ name, value, i: { options } }) {
    if (value === undefined) value = true;else value = !!value;
    const { property } = this;
    property && (options[property] = value);
  }
}
OptionBoolean.type = 'boolean';

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class OptionTrue extends OptionBoolean {

  constructor(o) {
    super(Object.assign({ value: true }, o));
  }

  execute({ name, value, i: { options } }) {
    if (value === undefined) value = false;else value = !!value;
    const { property } = this;
    property && (options[property] = value);
  }

  _getOptionNames(names, property, key) {
    if (names === undefined && (property || key)) names = `-no-${property || key}`;
    return super._getOptionNames(names, property);
  }
}
OptionTrue.type = 'true';

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class OptionString extends Option {

  constructor(o) {
    super(Object.assign({ hasValue: valueFlags.always, valueName: 'string' }, o));
  }

  execute({ value, i: { options } }) {
    if (value === undefined) value = '';
    const { property } = this;
    if (property) {
      const optionsValue = options[property];
      if (optionsValue === undefined) options[property] = value;else if (!Array.isArray(optionsValue)) options[property] = [optionsValue, value];else optionsValue.puah(value);
    }
  }
}
OptionString.type = 'string';

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class OptionNeString extends OptionString {

  constructor(o) {
    super(o);
    this.debug && this.constructor === OptionNeString && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`);
  }

  execute(o) {
    const { value, name } = o;
    if (!value) return `option ${name} not non-empty string: ${typeof value}`;
    super.execute(o);
  }
}
OptionNeString.type = 'nestring';

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class OptionFilename extends Option {

  constructor(o) {
    super(o);
    this.valueName = 'filename';
    const { property, names } = this;
    if (!property) throw new Error(`${this.m} option ${names[0]} of filename type: property cannot be empty`);
  }

  execute({ name, value, i: { options } }) {
    const { isHasValueAlways, property } = this;
    if (!value && isHasValueAlways) return `option ${name} of filename type: filename cannot be empty`;
    options[property] = value ? path.resolve(value) : '';
  }
}
OptionFilename.type = 'filename';

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class OptionInteger extends Option {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.valueName = 'integer', _temp;
  }

  execute(o) {
    const { name, value, i: { options } } = o;
    const { props, property } = this;
    const m = `option ${name}`;
    const number = +value;
    if (isNaN(number)) return `${m}: value not numeric: ${value}`;
    if (!Number.isInteger(number)) return `${m}: value not integer: ${value} ${number}`;
    const { min, max } = props;
    if (typeof min === 'number' && value < min) return `${m}: ${value} cannot be less than ${min}`;
    if (typeof max === 'number' && value > max) return `${m}: ${value} cannot be greater than ${max}`;
    options[property] = number;
  }
}
OptionInteger.type = 'integer';

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class OptionPort extends OptionInteger {

  constructor(o) {
    super(Object.assign({ hasValue: valueFlags.always }, o));
    this.valueName = 'port';
    const { props } = this;
    if (props.min == null) props.min = 1;
    if (props.max == null) props.min = 65535;
  }
}
OptionPort.type = 'port';

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/


var builtInOptions = Object.freeze({
	OptionBoolean: OptionBoolean,
	OptionTrue: OptionTrue,
	OptionString: OptionString,
	OptionNeString: OptionNeString,
	OptionFilename: OptionFilename,
	OptionInteger: OptionInteger,
	OptionPort: OptionPort
});

var _extends$1$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

class ParserOptionsData extends NumeralityHOC(ParserBase) {

  constructor(o) {
    super(_extends$1$2({ numerality: Object(Object(o).optionsData).args }, o));
    this.optionList = [];
    this.optionIndex = {};
    this.initialOptions = {};
    this.optionTypeList = [];
    this.optionTypeIndex = {};
    this.anonymousOptionTypeCounter = 0;
    this._addBuiltInOptionTypes(Object.values(Object(builtInOptions)));
    const { properties, optionTypes } = Object(o).optionsData || false;
    this._addOptionTypesMap(optionTypes);
    this._addPropertiesMap(properties);
  }

  getInitialOptions() {
    return _extends$1$2({}, this.initialOptions);
  }

  getOptionName(token) {
    const equalIndex = String(token).indexOf('=');
    const optionName = !~equalIndex ? String(token) : String(token).substring(0, equalIndex);
    const optionValue = !~equalIndex ? undefined : String(token).substring(equalIndex + 1);
    return { optionName, optionValue };
  }

  getOptionByName({ optionName }) {
    // '-debug'
    const { optionList, optionIndex } = this;
    const matchingOptions = [];
    const nameLength = String(optionName).length;
    for (let [name, optionNo] of Object.entries(optionIndex)) {
      const option = optionList[optionNo];
      if (optionName === name) return option; // exact match
      if (optionName === name.substring(0, nameLength)) matchingOptions.push({ name, option });
    }
    if (matchingOptions.length === 1) return matchingOptions[0].option;
    if (matchingOptions.length === 0) return `unknown option: ${optionName}: try -help`;
    const optionNames = matchingOptions.map(({ name: n }) => n).join(' ');
    return `ambiguous option: ${optionName} matches: ${optionNames}`;
  }

  getOptionValue({ option, optionName, optionValue, optionalValue }) {
    const result = { indexIncrement: 1 };
    const { isHasValueNever, isHasValueAlways } = option;
    const m = `option ${optionName}`;

    if (isHasValueNever) {
      if (optionValue != null) result.errorText = `${m}: does not accept a value`;
    } else {
      if (optionValue != null) result.value = optionValue;else if (optionalValue != null) {
        result.value = optionalValue;
        result.indexIncrement++;
      } else if (isHasValueAlways) result.errorText = `${m}: requires a value`;
    }
    return result;
  }

  getOptionIndexNotEmpty() {
    return this.optionIndex.length !== 0;
  }

  checkForMandatoryOptions() {
    const { optionList } = this;
    const missing = [];
    for (let option of optionList) {
      const errorText = option.isNumeralityBad();
      errorText && missing.push(option.names[0]);
    }
    if (missing.length) return `Missing mandatory options: ${missing.join(' ')}`;
  }

  addOptionType(optionConstructor) {
    const { optionTypeList, optionTypeIndex } = this;
    const { type } = Object(optionConstructor);
    let s = {};
    if (getFn({ optionConstructor, s })) throw new Error(`${this.m} addOptionType option-type constructor: ${s.text}`);
    if (getNonEmptyString({ type, s })) throw new Error(`${this.m} addOptionType option-type constructor type name: ${s.text}`);
    const currentIndex = optionTypeIndex[type];
    if (currentIndex == null) {
      optionTypeIndex[type] = optionTypeList.length;
      optionTypeList.push(optionConstructor);
    } else optionTypeList[currentIndex] = optionConstructor;
  }

  createOption(optionData) {
    const od = _extends$1$2({}, optionData);
    const { type } = od;
    let optionConstructor = this._getOrRegisterOptionType(type);
    const tt = typeof optionConstructor;
    if (tt !== 'function') throw new Error(`${this.m} createOption: ${optionConstructor} optionData:`, optionData);
    delete od.type;
    this.debug && (od.debug = true);
    this.addOption(new optionConstructor(od));
  }

  addOption(option) {
    const { optionList, initialOptions, optionIndex } = this;
    if (!(option instanceof Option)) throw new Error(`${this.m} addOption: option not instanceof Options`);

    // initial value
    const { value, property: p } = option;
    if (value !== undefined && p) initialOptions[p] = value;

    // index
    const index = optionList.length;
    optionList.push(option);
    const { names } = option; // string or list of string
    for (let name of names) {
      if (optionIndex[name] != null) throw new Error(`${this.m} duplicate option name: ${name}`);
      optionIndex[name] = index;
    }
  }

  async getOptionsHelp() {
    const { optionList } = this;
    let helpList = [];
    for (let option of optionList) {
      const { names, valueName, help } = option;
      helpList.push({ names, valueName, help: typeof help === 'function' ? await option.help() : help });
    }
    return helpList;
  }

  _addPropertiesMap(propertiesMap) {
    for (let [key, values] of Object.entries(Object(propertiesMap))) {
      const od = _extends$1$2({}, values);
      const { type } = od;
      const optionConstructor = this._getOrRegisterOptionType(type);
      if (typeof optionConstructor !== 'function') throw new Error(`${this.m} optionsData.properties key: ${key}: ${optionConstructor}`);
      delete od.type;
      this.debug && (od.debug = true);
      this.addOption(new optionConstructor(_extends$1$2({ key }, od)));
    }
  }

  _addBuiltInOptionTypes(builtInList) {
    if (!Array.isArray(builtInList)) throw new Error(`${this.m} built-in option types list not array`);
    let s = {};
    for (let [index, builtInConstructor] of builtInList.entries()) {
      let indexStr = `index#${index}`;
      const bt = typeof builtInConstructor;
      if (bt !== 'function') throw new Error(`${this.m} built-in option type constructor not function: ${indexStr} type: ${bt}`);
      indexStr = `class name: ${bt.name} ${indexStr}`;
      const { type } = builtInConstructor;
      if (getNonEmptyString({ type, s })) throw new Error(`${this.m} built-in option type does not have static type name: ${indexStr} constructor name: ${name}`);
      this.addOptionType(builtInConstructor);
    }
  }

  _addOptionTypesMap(types) {
    for (let [type, fn] of Object.entries(Object(types))) {
      const errStr = `${this.m} optionsData.optionTypes key: ${type}`;
      const tf = typeof fn;
      if (tf !== 'function') throw new Error(`${errStr} value not function: type: ${tf}`);
      const { type: fnType } = fn;
      if (!fnType) fn = OptionHOC(fn, type);
      this.addOptionType(fn);
    }
  }

  _getOrRegisterOptionType(type) {
    if (type !== undefined) {
      const tt = typeof type;
      if (tt !== 'string') {
        if (tt !== 'function') return `not function or non-empty string: type: ${tt}`;
        const { type: typeVal } = type;
        if (typeVal) return type; // an inline Option or OptionHOC
        // optionsData.properties.type is simple function: on-the-fly OptionHOC
        const name = `customType${++this.anonymousOptionTypeCounter}`;
        return OptionHOC(type, name); // won’t fail
      }
    }
    const { optionTypeIndex, optionTypeList } = this;
    const index = type !== undefined ? optionTypeIndex[type] : 0;
    const optionConstructor = optionTypeList[index];
    if (typeof optionConstructor === 'function') return optionConstructor;
    return `unknown option type: '${type}' available types: ${Object.keys(optionTypeIndex).length}[${Object.keys(optionTypeIndex).join('\x20')}]`;
  }
}

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class ParserUsage extends ParserOptionsData {

  constructor(o) {
    super(o);
    const { optionsData, name, version } = Object(o);
    const { help, helpArgs, usage } = Object(optionsData);
    let s = {};
    if (getFn({ usageFn: usage, s }, this.defaultUsage.bind(this))) throw new Error(`${this.m} optionsData.usage: ${s.text}`);
    if (getNonEmptyString({ name, s })) throw new Error(`${this.m} name property: ${s.text}`);
    if (getNonEmptyStringOrUndefined({ version, s })) throw new Error(`${this.m} version property: ${s.text}`);
    if (getStringOrFunctionOrUndefined({ help, s })) throw new Error(`${this.m} optionsData.help: ${s.text}`);
    if (getStringOrFunctionOrUndefined({ helpArgs, s })) throw new Error(`${this.m} optionsData.helpArgs: ${s.text}`);
    Object.assign(this, s.properties);
  }

  async doUsage() {
    const { usageFn, exitFn, name, version } = this;
    console.log((await usageFn({ name, version })));
    exitFn(ParserUsage.statusCodeOk);
  }

  async doError(message) {
    const { usageFn, exitFn, name, version } = this;
    console.error(`${message}\n\n${await usageFn({ name, version })}`);
    exitFn(ParserUsage.statusCodeUsage);
  }

  async defaultUsage({ name, version }) {
    const { help, helpArgs, isNumeralityMultiple, isNumeralityNever, isNumeralityMandatory } = this;
    let usage = [];

    // 'command [options] args…'
    let s0 = `${name}`;
    if (this.getOptionIndexNotEmpty()) s0 += ` [options]`;
    if (helpArgs == null) {
      if (!isNumeralityNever) {
        const { argsSingle, argsMultiple } = ParserUsage;
        let s01 = isNumeralityMultiple ? argsMultiple : argsSingle;
        if (isNumeralityMandatory) s01 = `[${s01}]`;
        s0 += ` ${s01}`;
      }
    } else if (helpArgs) s0 += ` ${typeof helpArgs === 'function' ? await this.helpArgs() : helpArgs}`;
    usage.push(s0);

    // 'version: 1.2.3'
    version && usage.push(this._indent(`version: ${version}`, 2));

    // 'description'
    if (help) {
      const helpS = typeof help === 'function' ? await this.help() : help;
      if (helpS) usage.push(this._indent(helpS));
    }

    // options table: 2 columns
    // '-h -help --help' 'display usage'
    const left = [];
    const right = [];
    let leftWidth = 0;
    let entryCount = 0;

    // populate table content
    const helpList = await this.getOptionsHelp();
    for (let _ref of helpList) {
      let { names, valueName, help: optionHelp } = _ref;

      let flags = names.join(' ');
      if (valueName) flags += ` ${valueName}`;
      const flagsLength = flags.length;
      if (flagsLength > leftWidth) leftWidth = flagsLength;
      left.push(flags);
      right.push(String(optionHelp || ''));
      entryCount++;
    }

    // format table
    const leftSpacing = '\x20'.repeat(leftWidth + 1);
    for (let index = 0; index < entryCount; index++) {

      // first line
      const leftLine = left[index];
      const leftLineLength = leftLine.length;
      const rightLines = right[index].split('\n');
      let sx = leftLine;
      if (rightLines[0]) sx += `${leftSpacing.substring(leftLineLength)}${rightLines[0]}`;
      usage.push(this._indent(sx, 1));

      // subsequent lines on the right
      for (let ii = 1; ii < rightLines.length; ii++) usage.push(this._indent(`${leftSpacing}${rightLines[ii]}`, 1));
    }

    return usage.join('\n');
  }

  _indent(s, x) {
    const indentString = '\x20'.repeat(x >= 0 ? 2 * +x : 2);
    return s ? `${indentString}${String(s).replace(/\n/g, `\n${indentString}`)}` : '';
  }
}
ParserUsage.statusCodeOk = 0;
ParserUsage.statusCodeUsage = 2;
ParserUsage.argsSingle = 'args';
ParserUsage.argsMultiple = 'args…';

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class OptionHelp extends Option {

  constructor(o) {
    super(o);
    const { props: { fn } } = this;
    const ft = typeof fn;
    if (ft !== 'function') throw new Error(`${this.m} fn not function: ${ft}`);
  }

  execute(o) {
    const { props: { fn } } = this;
    return fn(o);
  }
}
OptionHelp.type = 'help';

var _extends$2$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

class ParserDefaults extends ParserUsage {

  constructor(o) {
    super(o);
    const { optionsData } = o || false;
    const { defaults, profiles, readYaml } = optionsData || false;
    const doAddDefaults = defaults !== false;
    const { helpOption, debugOption, profileOption, noYamlOption } = ParserDefaults;

    const optionList = [];
    if (doAddDefaults) {
      optionList.push(_extends$2$2({}, helpOption, { fn: this.doUsage.bind(this) }), debugOption);
    }
    if (profiles || profiles === undefined && readYaml) optionList.push(_extends$2$2({}, profileOption, { help: this.profileHelp.bind(this) }), noYamlOption);
    for (let option of optionList) this.createOption(option);
  }

  async profileHelp() {
    const { readYaml } = this;
    const key = typeof readYaml !== 'string' ? ParserDefaults.defaultYamlKey : readYaml;
    const basenames = `${this.getYamlBasenames().join('\x20')}`;
    let s = [`key is used to fetch from yaml top-level 'profiles' dictionary`, `yaml filenames searched are: ${basenames}`, `paths searched are ~/apps .. /etc`, `option defaults are fetched from the top-level '${key}' dictionary`].join('\n');
    const filename = await this.getYamlFilename();
    if (filename) {
      const yamlObject = await this.getYaml(filename);
      const keys = Object.keys(Object(yamlObject).profiles);
      if (keys.length) s += `\nprofiles in '${filename}': '${keys.join(`'\x20'`)}'`;
    }
    return s;
  }
}
ParserDefaults.defaultYamlKey = 'options';
ParserDefaults.yamlDisableOption = '-no-yaml';
ParserDefaults.helpOption = {
  names: ['-help', '--help'],
  type: OptionHelp,
  numerality: numeralities.optionalOnce,
  hasValue: valueFlags.never,
  help: 'display usage'
};
ParserDefaults.debugOption = {
  property: 'debug',
  help: 'display diagnostic output'
};
ParserDefaults.profileOption = {
  names: ['-profile'],
  type: 'nestring',
  property: 'optionsFileProfile',
  valueName: 'key'
};
ParserDefaults.noYamlOption = {
  names: [ParserDefaults.yamlDisableOption],
  type: 'true',
  help: 'ignore yaml files'
};

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

class ParserYaml extends ParserDefaults {
  constructor(o) {
    super(o);
    const { optionsData } = o || false;
    const { readYaml } = optionsData || false;
    if (readYaml != null) this.readYaml = readYaml;
  }

  getYamlBasenames() {
    const { name } = this;
    const hostname = os.hostname().replace(/\..*$/, ''); // remove possible file extension
    return [`${name}-${hostname}.yaml`, `${name}.yaml`];
  }

  async getYamlFilename(noneIsOk = true) {
    // get path list
    const paths = [];
    for (let basename of this.getYamlBasenames()) paths.push(basename, path.join(os.homedir(), 'apps', basename), path.join('..', basename), path.join('/etc', basename));
    for (let aPath of paths) {
      if (await lib.pathExists(aPath)) return aPath;
    }
    if (!noneIsOk) throw new Error(`Parameter files not found: ${paths.join(', ')}`);
  }

  async getYaml(filename, key) {
    this.debug && console.log(`${this.m} getYaml ${filename}`);
    const data = Object((await jsYaml$2.safeLoad((await lib.readFile(filename, 'utf-8')))));
    return key ? Object(data[key]) : data;
  }
}

/*
© 2017-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/
/*
const optionsData = {
  properties: {
    debug: {
      names: optional string of string array option names like '-debug', default properties key name preceded by hyphen '-'
      property: optional string, default properties key name: false for none. The property in the resulting options object
      type: optional string or function({value, i: {argv, index, options}, parser, action}) default 'boolean': option type name
      numerality: optional string default 'optionalOnce': 'optional' 'optionalOnce' 'mandatory' 'mandatoryMany' 'none'
      hasValue: optional string default 'never': 'never' 'may' 'always'
      valueName: optional string or async function returning string: name describing the value. default defined by option type
      value: value initially present in resulting options object, default none
      help: optional string or async function returning string: help text, default defined by option type
    }
  }
  optionTypes: {
    'float': value: class extends Option or function
  }
  exit: optional function(statusCode): default process.exit
  usage: optional async function({name, version}) generate usage string, default: internally generated
  args: optional string numerality-value: allowable non-option string, default 'optional'
  defaults: bolean default true: add -h/-help/--help/-debug/-profile flags to options
  profiles: add -profile flag to options. default value is readYaml
  readYaml: optional boolean default false: read [app]-[hostname].yaml or [app].yaml from . ~/apps .. /etc. true: use 'options' key in yaml. string: use this key name
  help: optional string or async function returning string: help text, default no description
  helpArgs: optional string or async function returning string: help text for args, default 'args…'
}
*/

class Parser extends ParserYaml {
  constructor(o) {
    super(o);
    this.debug && console.log(`${this.m} constructor: ${util.inspect(this, { colors: true, depth: null })}`);
  }

  async parseOptions(argv) {
    const { debug, readYaml } = this;
    const options = this.getInitialOptions();
    const i = { options, argv, index: 0 };
    let yamlProfiles, s;

    if (readYaml) {
      const { yamlDisableOption } = Parser;
      if (!argv.includes(yamlDisableOption)) {
        const optionsFile = await this.getYamlFilename();
        if (optionsFile) {
          const optionsFileProp = typeof readYaml === 'string' ? readYaml : Parser.defaultYamlKey;
          const data = Object((await this.getYaml(optionsFile)));
          yamlProfiles = Object(data.profiles);
          const yamlOptions = Object(data[optionsFileProp]);
          debug && console.log(`${this.m} merging yaml options from ${optionsFile} key: ${optionsFileProp}:`, yamlOptions);
          Object.assign(options, yamlOptions, { optionsFile, optionsFileProp });
        }
      }
    }

    debug && console.log(`${this.m} parseOptions argv:`, argv, 'initialOptions:', options);
    const maxIndex = argv.length;
    while (i.index < maxIndex) {

      // non-options
      const token = argv[i.index];
      if (!token.startsWith('-')) {
        debug && console.log(`${this.m} non-option: ${token}`);
        this.addNumeralityOccurrence();
        if (s = this.isNumeralityBad()) return this.doError(s);
        const { args } = options;
        if (!args) options.args = [token];else args.push(token);
        i.index++;
        continue;
      }

      // option name and value
      const { optionName, optionValue } = this.getOptionName(token);
      const option = this.getOptionByName({ optionName, token });
      if (typeof option === 'string') return this.doError(option);
      const nextIndex = i.index + 1;
      const nextToken = nextIndex < maxIndex ? argv[nextIndex] : undefined;
      const optionalValue = nextToken && !nextToken.startsWith('-') ? nextToken : undefined;
      const { value, indexIncrement, errorText } = this.getOptionValue({ option, optionName, optionValue, optionalValue });
      if (errorText) return this.doError(errorText);
      option.addNumeralityOccurrence();
      if (s = option.isNumeralityBad()) return this.doError(`option ${optionName}: ${s}`);

      // execute option
      debug && console.log(`${this.m} execute option: ${option.constructor.type}`, { name: optionName, value, i, indexIncrement });
      const optionResult = await option.execute({ name: optionName, value, i, indexIncrement });
      if (typeof optionResult === 'string') return this.doError(optionResult);else if (optionResult === true) continue;
      i.index += indexIncrement;
    }
    if (s = this.checkForMandatoryOptions()) return this.doError(s);
    const { optionsFileDefault, optionsFileProfile } = options;
    if (optionsFileProfile == null && optionsFileDefault) options.optionsFileProfile = optionsFileDefault;
    if (optionsFileDefault || optionsFileProfile) options.optionsFileProfiles = Object(yamlProfiles); // -profile strings provided

    return options;
  }
}

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/
const launchProcess = OnRejected.launchProcess;

/*
© 2018-present Harald Rudell <harald.rudell@gmail.com> (http://www.haraldrudell.com)
All rights reserved.
*/

const optionsData = {
  properties: {
    render: {
      type: 'nestring',
      help: 'render a stack of current Ubuntu EC2 instance',
      valueName: 'stackName'
    },
    'list-deployable': {
      property: 'listdeployable',
      help: 'list rendered stacks.\nRendered stack may be deployed to Amazon'
    },
    deploy: {
      type: 'nestring',
      valueName: 'stackName'
    },
    del: {
      type: 'string',
      hasValue: 'may',
      valueName: 'stackName'
    },
    'id': {
      type: 'nestring',
      valueName: 'stackId'
    },
    up: {
      type: 'nestring',
      valueName: 'stackName'
    },
    list: { help: 'list stacks deployed with Amazon' },
    cachedid: { help: 'use cached imageId for -render, saves 7 s' },
    codename: { help: 'Ubuntu codename, default artful' }
  },
  readYaml: true,
  args: 'none'
};

launchProcess({ run: run$1, name: pjson && pjson.name, version: pjson && pjson.version });

async function run$1({ name, version: version$$1, OnRejected }) {
  const options = await new Parser({ optionsData, name, version: version$$1 }).parseOptions(process.argv.slice(2));
  options.debug && OnRejected.setDebug() && console.log(`${name} options:`, options);
  return new Accounter(options).run();
}
