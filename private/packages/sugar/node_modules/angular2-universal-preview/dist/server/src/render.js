/// <reference path="../typings/tsd.d.ts" />
var application_1 = require('./core/application');
var helper_1 = require('./helper');
var stringifyElement_1 = require('./stringifyElement');
var ng_preboot_1 = require('./ng_preboot');
var preboot_1 = require('preboot');
var lang_1 = require('angular2/src/core/facade/lang');
var dom_adapter_1 = require('angular2/src/core/dom/dom_adapter');
var shared_styles_host_1 = require('angular2/src/core/render/dom/shared_styles_host');
var http_1 = require('angular2/http');
var angular2_1 = require('angular2/angular2');
exports.serverDirectiveResolver = new angular2_1.DirectiveResolver();
function selectorResolver(componentType) {
    return exports.serverDirectiveResolver.resolve(componentType).selector;
}
exports.selectorResolver = selectorResolver;
/* Document */
function createServerDocument(appComponentType) {
    // 1ms
    var serverDocument = dom_adapter_1.DOM.createHtmlDocument();
    var el = dom_adapter_1.DOM.createElement(appComponentType, serverDocument);
    dom_adapter_1.DOM.appendChild(serverDocument.body, el);
    return serverDocument;
}
exports.createServerDocument = createServerDocument;
function serializeApplication(element, styles, cache) {
    // serialize all style hosts
    var serializedStyleHosts = styles.length >= 1 ? '<style>' + styles.join('\n') + '</style>' : '';
    // serialize Top Level Component
    var serializedCmp = stringifyElement_1.stringifyElement(element);
    // serialize App Data
    var serializedData = !cache ? '' : '' +
        '<script>' +
        'window.' + 'ngPreloadCache' + ' = ' + JSON.stringify(cache, null, 2) +
        '</script>';
    '';
    return serializedStyleHosts + serializedCmp + serializedData;
}
exports.serializeApplication = serializeApplication;
function appRefSyncRender(appRef) {
    // grab parse5 html element
    var element = appRef.location.nativeElement;
    // TODO: we need a better way to manage the style host for server/client
    var sharedStylesHost = appRef.injector.get(shared_styles_host_1.SharedStylesHost);
    var styles = sharedStylesHost.getAllStyles();
    // TODO: we need a better way to manage data serialized data for server/client
    var http = appRef.injector.getOptional(http_1.Http);
    var cache = lang_1.isPresent(http) ? helper_1.arrayFlattenTree(http._rootNode.children, []) : null;
    var serializedApp = serializeApplication(element, styles, cache);
    return serializedApp;
}
exports.appRefSyncRender = appRefSyncRender;
function renderToString(AppComponent, serverProviders) {
    if (serverProviders === void 0) { serverProviders = []; }
    return application_1.bootstrap(AppComponent, serverProviders)
        .then(function (appRef) {
        var http = appRef.injector.getOptional(http_1.Http);
        // TODO: fix zone.js ensure overrideOnEventDone callback when there are no pending tasks
        // ensure all xhr calls are done
        return new Promise(function (resolve) {
            var ngZone = appRef.injector.get(angular2_1.NgZone);
            // ngZone
            ngZone.overrideOnEventDone(function () {
                if (lang_1.isBlank(http) || lang_1.isBlank(http._async) || http._async <= 0) {
                    var html = appRefSyncRender(appRef);
                    appRef.dispose();
                    resolve(html);
                }
            }, true);
        });
    });
}
exports.renderToString = renderToString;
function renderToStringWithPreboot(AppComponent, serverProviders, prebootConfig) {
    if (serverProviders === void 0) { serverProviders = []; }
    if (prebootConfig === void 0) { prebootConfig = {}; }
    return renderToString(AppComponent, serverProviders)
        .then(function (html) {
        if (typeof prebootConfig === 'boolean' && prebootConfig === false) {
            return html;
        }
        var config = ng_preboot_1.prebootConfigDefault(prebootConfig);
        return preboot_1.getClientCode(config)
            .then(function (code) { return html + ng_preboot_1.createPrebootHTML(code, config); });
    });
}
exports.renderToStringWithPreboot = renderToStringWithPreboot;
//# sourceMappingURL=render.js.map